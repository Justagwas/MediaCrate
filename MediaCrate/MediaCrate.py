#Check out my other projects! https://justagwas.com/projects
#You can find the OFFICIAL CODE of this program here - https://github.com/Justagwas/mediacrate
import tkinter as tk
from tkinter import messagebox, ttk
from yt_dlp import YoutubeDL
from yt_dlp.utils import DownloadCancelled
import threading
import os
import sys
import time
import queue
import logging
import requests
import shutil
import zipfile
import platform
import subprocess
from urllib.parse import urlparse, parse_qs
import ctypes as ct
from packaging.version import Version, InvalidVersion
from pathvalidate import sanitize_filename
import re
import xml.etree.ElementTree as ET
import json
import webbrowser

logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

THEME = {
    "bg": "#0f1115",
    "surface": "#171a22",
    "surface_alt": "#202637",
    "surface_alt_hover": "#2a3246",
    "border": "#2c354a",
    "text": "#e8ecf1",
    "muted": "#9aa4b2",
    "accent": "#4ac3ff",
    "accent_hover": "#2f9bd4",
    "success": "#22c55e",
    "success_hover": "#16a34a",
    "danger": "#f87171",
    "danger_hover": "#ef4444",
    "disabled_bg": "#242a38",
    "disabled_fg": "#6b7280",
}

LIGHT_THEME = {
    "bg": "#f6f7fb",
    "surface": "#ffffff",
    "surface_alt": "#eef1f6",
    "surface_alt_hover": "#e1e6ee",
    "border": "#d6dbe5",
    "text": "#0f1115",
    "muted": "#5a6475",
    "accent": "#0ea5e9",
    "accent_hover": "#0284c7",
    "success": "#16a34a",
    "success_hover": "#15803d",
    "danger": "#ef4444",
    "danger_hover": "#dc2626",
    "disabled_bg": "#e5e7eb",
    "disabled_fg": "#9aa3b2",
}

def enable_high_dpi():
    if not sys.platform.startswith("win"):
        return
    try:
        ct.windll.shcore.SetProcessDpiAwareness(2)
    except Exception:
        try:
            ct.windll.user32.SetProcessDPIAware()
        except Exception:
            pass

if platform.system() == "Windows":
    import win32event, win32api, winerror
    mutex = win32event.CreateMutex(None, False, "MediaCrateMutex")
    if win32api.GetLastError() == winerror.ERROR_ALREADY_EXISTS:
        sys.exit("Application is already running.")

class MediaDownloader:
    def _appdata_dir(self):
        base = os.environ.get("LOCALAPPDATA")
        if base:
            return os.path.join(base, "MediaCrate")
        return os.path.join(os.path.expanduser("~"), "MediaCrate")

    def _is_dir_writable(self, path):
        try:
            os.makedirs(path, exist_ok=True)
            test_path = os.path.join(path, ".mc_write_test")
            with open(test_path, "a"):
                pass
            os.remove(test_path)
            return True
        except Exception:
            return False

    def load_config(self):
        script_dir = self._app_dir()
        appdata_dir = self._appdata_dir()
        config_name = "MediaCrate_config.json"
        app_config = os.path.join(script_dir, config_name)
        appdata_config = os.path.join(appdata_dir, config_name)
        source_path = app_config if os.path.exists(app_config) else appdata_config if os.path.exists(appdata_config) else None
        target_dir = script_dir if self._is_dir_writable(script_dir) else appdata_dir
        self.config_path = os.path.join(target_dir, config_name)
        default_config = {
            'WARNING:': "This file is generated by MediaCrate. DO NOT CHANGE the contents of this file unless you know what you are doing.",
            'first_launch_complete': False,
            'ui_scale_confirmed': False,
            'theme': "dark",
            'disable_warnings': False,
            'allow_batch_downloads': False,
            'disable_already_downloaded_prompts': False,
            'auto_check_updates': True,
            'enable_window_resizing': False,
            'ui_scale': 100,
            'default_format_selection': "",
            'ui_queue_cap': self._default_ui_queue_cap(),
            'download_location': self._default_download_dir(),
            'batch_concurrency': self._default_batch_concurrency(),
            'batch_retry_attempts': 1,
            'preserve_batch_links': False,
            'max_batch_lines': self._default_batch_line_limit(),
            'disable_char_limits': False,
            'proxy': "",
            'cookies_use': False,
            'cookies_browser': "chrome",
            'enable_batch_fallbacks': False
        }
        if source_path and os.path.exists(source_path):
            try:
                with open(source_path, 'r') as f:
                    config = json.load(f)
                had_ui_scale_confirmed = 'ui_scale_confirmed' in config
                for k, v in default_config.items():
                    if k not in config:
                        config[k] = v
                if not had_ui_scale_confirmed:
                    config['ui_scale_confirmed'] = False
                if config.get('theme') not in ("dark", "light"):
                    config['theme'] = "dark"
                config['batch_concurrency'] = self._normalize_batch_concurrency(config.get('batch_concurrency'))
                config['max_batch_lines'] = self._normalize_batch_line_limit(config.get('max_batch_lines'))
                config['ui_queue_cap'] = self._normalize_ui_queue_cap(config.get('ui_queue_cap'))
                self.config = config
            except Exception:
                self.config = default_config
        else:
            self.config = default_config
        if not os.path.exists(self.config_path) or (source_path and os.path.abspath(source_path) != os.path.abspath(self.config_path)):
            try:
                os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
                with open(self.config_path, 'w') as f:
                    json.dump(self.config, f, indent=2)
            except Exception:
                pass

    def save_config(self):
        try:
            os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
            with open(self.config_path, 'w') as f:
                json.dump(self.config, f, indent=2)
        except Exception:
            pass

    def _is_windows(self):
        return sys.platform.startswith("win")

    def _app_dir(self):
        base = sys.executable if getattr(sys, 'frozen', False) else __file__
        return os.path.dirname(os.path.abspath(base))

    def _default_batch_concurrency(self):
        cpu_count = os.cpu_count() or 2
        return max(2, min(8, cpu_count))

    def _default_batch_line_limit(self):
        return 64

    def _default_ui_queue_cap(self):
        return 50

    def _default_download_dir(self):
        return os.path.join(os.path.expanduser("~"), "Downloads", "MediaCrate")

    def _resolve_ffmpeg_location(self):
        ffmpeg_name = "ffmpeg.exe" if self._is_windows() else "ffmpeg"
        for base_dir in (self._app_dir(), self._appdata_dir()):
            ffmpeg_path = os.path.join(base_dir, ffmpeg_name)
            if os.path.isfile(ffmpeg_path):
                return base_dir
        return None

    def _resolve_js_runtime(self):
        node_name = "node.exe" if self._is_windows() else "node"
        for base_dir in (self._app_dir(), self._appdata_dir()):
            node_path = os.path.join(base_dir, node_name)
            if os.path.isfile(node_path):
                return f"node:{node_path}"
        path_node = shutil.which("node")
        if path_node:
            return f"node:{path_node}"
        return None

    def _normalize_batch_concurrency(self, value):
        try:
            value = int(value)
        except (TypeError, ValueError):
            return self._default_batch_concurrency()
        return max(1, min(64, value))

    def _normalize_batch_line_limit(self, value):
        try:
            value = int(value)
        except (TypeError, ValueError):
            return self._default_batch_line_limit()
        return max(1, min(1024, value))

    def _normalize_batch_retries(self, value):
        try:
            value = int(value)
        except (TypeError, ValueError):
            return 1
        return max(1, min(5, value))

    def _normalize_ui_queue_cap(self, value):
        try:
            value = int(value)
        except (TypeError, ValueError):
            return self._default_ui_queue_cap()
        return max(1, min(500, value))

    def _display_path(self, path):
        try:
            return os.path.normpath(os.path.expanduser(path))
        except Exception:
            return path

    def _theme_icon(self):
        return "☀" if self._theme_name == "dark" else "☾"

    def _toggle_theme_and(self, rebuild_fn=None):
        if getattr(self, "downloading", False):
            return
        new_name = "light" if self._theme_name == "dark" else "dark"
        self._set_theme(new_name, rebuild=False)
        if rebuild_fn:
            rebuild_fn()

    def _set_theme(self, name, rebuild=True):
        theme_name = str(name or "").strip().lower()
        if theme_name not in ("dark", "light"):
            theme_name = "dark"
        if theme_name == self._theme_name:
            return
        self._theme_name = theme_name
        self.theme = LIGHT_THEME if theme_name == "light" else THEME
        self.config["theme"] = theme_name
        self.save_config()
        try:
            self.root.configure(bg=self.theme["bg"])
        except Exception:
            pass
        self.configure_styles()
        self._pending_main_rebuild = True
        if getattr(self, "progress", None):
            self._set_progress_style("normal")
        if not rebuild:
            return
        if getattr(self, "_current_view", None) == "settings":
            self.show_settings()
        else:
            self.create_widgets(force_rebuild=True, switch_view=True)

    def toggle_theme(self):
        if getattr(self, "downloading", False):
            return
        new_name = "light" if self._theme_name == "dark" else "dark"
        self._set_theme(new_name, rebuild=True)

    def _sanitize_title(self, title):
        sanitized = self.sanitize_filename(title or "")
        sanitized = ''.join(c for c in sanitized if c.isalnum() or c in (' ', '.', '_', '-')).strip()
        return sanitized or 'media_file'

    def _sanitize_id(self, media_id):
        sanitized = self.sanitize_filename(str(media_id or ""))
        sanitized = ''.join(c for c in sanitized if c.isalnum() or c in ('-', '_')).strip()
        return sanitized

    def _build_base_filename(self, title, media_id):
        safe_title = self._sanitize_title(title)
        safe_id = self._sanitize_id(media_id)
        if safe_id:
            return f"{safe_title} [{safe_id}]"
        return safe_title

    def _register_active_temp(self, download_dir, temp_base):
        if not download_dir or not temp_base:
            return
        with self._active_part_lock:
            self._active_part_targets.add((download_dir, temp_base))

    def _unregister_active_temp(self, download_dir, temp_base):
        if not download_dir or not temp_base:
            return
        with self._active_part_lock:
            self._active_part_targets.discard((download_dir, temp_base))

    def _cleanup_temp_files(self, download_dir, temp_base, max_attempts=25, delay=0.2):
        if not download_dir or not temp_base:
            return
        prefix = (temp_base + ".").lower()
        remaining = True
        attempts = 0
        while remaining and attempts < max_attempts:
            remaining = False
            try:
                for fname in os.listdir(download_dir):
                    if not fname.lower().startswith(prefix):
                        continue
                    fpath = os.path.join(download_dir, fname)
                    try:
                        os.remove(fpath)
                    except PermissionError:
                        remaining = True
                    except FileNotFoundError:
                        pass
                    except Exception:
                        remaining = True
            except Exception:
                break
            if remaining:
                time.sleep(delay)
            attempts += 1

    def _cleanup_partial_downloads(self, max_attempts=25, delay=0.2):
        with self._active_part_lock:
            targets = list(self._active_part_targets)
            self._active_part_targets.clear()
        for download_dir, temp_base in targets:
            self._cleanup_temp_files(download_dir, temp_base, max_attempts=max_attempts, delay=delay)

    def _cleanup_orphan_parts(self, download_dir, temp_base=None):
        if not download_dir or not os.path.isdir(download_dir):
            return
        prefix = (temp_base + ".").lower() if temp_base else None
        candidates = []
        try:
            for fname in os.listdir(download_dir):
                lower = fname.lower()
                if not lower.endswith((".part", ".ytdl", ".tmp", ".temp")):
                    continue
                if prefix and lower.startswith(prefix):
                    candidates.append(fname)
                else:
                    fpath = os.path.join(download_dir, fname)
                    try:
                        if os.path.getsize(fpath) == 0:
                            candidates.append(fname)
                    except Exception:
                        continue
        except Exception:
            return
        for fname in candidates:
            try:
                os.remove(os.path.join(download_dir, fname))
            except Exception:
                pass

    def _register_active_proc(self, proc):
        if not proc:
            return
        self._active_procs.add(proc)

    def _unregister_active_proc(self, proc):
        if not proc:
            return
        self._active_procs.discard(proc)

    def _kill_active_procs(self):
        procs = list(self._active_procs)
        self._active_procs.clear()
        for proc in procs:
            try:
                if proc.poll() is None:
                    if self._is_windows():
                        subprocess.run(
                            ["taskkill", "/F", "/T", "/PID", str(proc.pid)],
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL,
                            creationflags=subprocess.CREATE_NO_WINDOW if self._is_windows() else 0,
                            startupinfo=subprocess.STARTUPINFO() if self._is_windows() else None
                        )
                    else:
                        proc.kill()
            except Exception:
                pass

    def open_url(self, url):
        try:
            webbrowser.open(url, new=2)
        except Exception as e:
            logging.error(f"Failed to open URL: {e}")

    def open_downloads_folder(self):
        downloads_dir = self._display_path(self.config.get('download_location', self._default_download_dir()))
        try:
            os.makedirs(downloads_dir, exist_ok=True)
            if self._is_windows():
                os.startfile(downloads_dir)
            elif sys.platform == "darwin":
                subprocess.run(["open", downloads_dir], check=False)
            else:
                subprocess.run(["xdg-open", downloads_dir], check=False)
        except Exception as e:
            logging.error(f"Failed to open downloads folder: {e}")
            self.run_on_ui_thread(messagebox.showerror, "Error", "Failed to open the downloads folder.")

    def set_controls_state(self, enabled):
        self.run_on_ui_thread(self._set_controls_state, enabled)

    def mark_progress_complete(self):
        self.run_on_ui_thread(self._mark_progress_complete)

    def _mark_progress_complete(self):
        if self.progress and isinstance(self.progress, tk.Canvas):
            self._set_progress_style("complete")
            self._set_progress_value(100)
            self._set_progress_text("100%")

    def _reset_progress_bar(self):
        if self.progress and isinstance(self.progress, tk.Canvas):
            self._set_progress_style("normal")
            self._set_progress_value(0)
            self._set_progress_text("0%")

    def _set_progress_text(self, text):
        if self._last_progress_text == text:
            return
        self._last_progress_text = text
        self._update_progress_canvas()

    def _set_progress_value(self, value):
        try:
            val = float(value)
        except Exception:
            val = 0.0
        val = max(0.0, min(100.0, val))
        if getattr(self, "_progress_value", None) == val:
            return
        self._progress_value = val
        self._update_progress_canvas()

    def _set_progress_style(self, style_name):
        if not self.progress or not isinstance(self.progress, tk.Canvas):
            return
        theme = self.theme
        if style_name == "complete":
            self._progress_fill_color = theme["success"]
        elif style_name == "disabled":
            self._progress_fill_color = theme["disabled_fg"]
        else:
            self._progress_fill_color = theme["accent"]
        self._update_progress_canvas()

    def _update_progress_canvas(self):
        canvas = self.progress
        if not canvas or not isinstance(canvas, tk.Canvas) or not canvas.winfo_exists():
            return
        if not getattr(self, "progress_fill_id", None) or not getattr(self, "progress_text_id", None):
            return
        width = canvas.winfo_width()
        height = canvas.winfo_height()
        if width <= 1 or height <= 1:
            return
        value = getattr(self, "_progress_value", 0.0)
        fill_width = int(width * (value / 100.0))
        canvas.coords(self.progress_fill_id, 0, 0, fill_width, height)
        canvas.itemconfig(self.progress_fill_id, fill=self._progress_fill_color)
        canvas.coords(self.progress_text_id, width / 2, height / 2)
        text = self._last_progress_text
        if text is None:
            text = f"{int(value)}%"
        canvas.itemconfig(self.progress_text_id, text=text)
        text_color = self.theme["bg"] if value >= 50 else self.theme["text"]
        canvas.itemconfig(self.progress_text_id, fill=text_color)

    def _set_text_var(self, var, text):
        if var is None:
            return
        try:
            key = var._name
        except Exception:
            key = str(var)
        self._pending_text_vars[key] = (var, text)
        if self._pending_text_vars_scheduled:
            return
        self._pending_text_vars_scheduled = True
        self.run_on_ui_thread(self._flush_text_vars)

    def _flush_text_vars(self):
        pending = self._pending_text_vars
        self._pending_text_vars = {}
        self._pending_text_vars_scheduled = False
        for key, payload in pending.items():
            if isinstance(payload, tuple) and len(payload) == 2:
                var, text = payload
            elif hasattr(key, "set"):
                var, text = key, payload
            else:
                continue
            try:
                var.set(text)
            except Exception:
                pass
        if self._pending_text_vars and not self._pending_text_vars_scheduled:
            self._pending_text_vars_scheduled = True
            self.run_on_ui_thread(self._flush_text_vars)

    def _is_descendant(self, widget, ancestor):
        try:
            while widget:
                if widget == ancestor:
                    return True
                parent_name = widget.winfo_parent()
                if not parent_name:
                    break
                widget = widget._nametowidget(parent_name)
        except Exception:
            return False
        return False

    def _begin_transition(self):
        if getattr(self, "_transitioning", False):
            return
        self._transitioning = True
        try:
            if getattr(self, "_transition_overlay", None):
                try:
                    self._transition_overlay.destroy()
                except Exception:
                    pass
            self.root.update_idletasks()
            w = self.root.winfo_width()
            h = self.root.winfo_height()
            inset = 6
            overlay = tk.Frame(self.root, bg=self.theme["bg"])
            overlay.place(
                x=inset,
                y=inset,
                width=max(1, w - inset * 2),
                height=max(1, h - inset * 2),
            )
            overlay.lift()
            self._transition_overlay = overlay
            self._transition_height = max(1, h - inset * 2)
        except Exception:
            self._transition_overlay = None
            self._transitioning = False

    def _fade_in(self, steps=8, delay=10):
        if not getattr(self, "_transitioning", False):
            return
        def step(i):
            try:
                overlay = getattr(self, "_transition_overlay", None)
                if overlay:
                    total = getattr(self, "_transition_height", overlay.winfo_height())
                    remaining = max(0, int(total - (total * (i / steps))))
                    if remaining > 0:
                        overlay.place_configure(height=remaining)
            except Exception:
                self._transitioning = False
                return
            if i < steps:
                self._after(delay, lambda: step(i + 1))
            else:
                try:
                    overlay = getattr(self, "_transition_overlay", None)
                    if overlay:
                        overlay.destroy()
                except Exception:
                    pass
                self._transition_overlay = None
                self._transitioning = False
        step(0)

    def _ensure_view_container(self):
        if getattr(self, "view_container", None) and self.view_container.winfo_exists():
            return
        self.view_container = tk.Frame(self.root, bg=self.theme["bg"])
        self.view_container.pack(fill="both", expand=True)
        self.view_container.grid_rowconfigure(0, weight=1)
        self.view_container.grid_columnconfigure(0, weight=1)
        self.main_view = tk.Frame(self.view_container, bg=self.theme["bg"])
        self.settings_view = tk.Frame(self.view_container, bg=self.theme["bg"])
        self.main_view.grid(row=0, column=0, sticky="nsew")
        self.settings_view.grid(row=0, column=0, sticky="nsew")

    def _show_view(self, view):
        self._current_view = view
        if view == "settings":
            self.settings_view.tkraise()
        else:
            self.main_view.tkraise()

    def _set_controls_state(self, enabled):
        state = tk.NORMAL if enabled else tk.DISABLED
        theme = self.theme
        if not enabled:
            self.update_format_buttons()
        self._set_theme_toggle_state(enabled and not self.downloading)
        if getattr(self, 'paste_button', None):
            self.paste_button.config(state=state, cursor="hand2" if enabled else "")
        if hasattr(self, 'url_entry') and self.url_entry.winfo_exists():
            self.url_entry.config(state=state)
        if hasattr(self, 'url_text') and self.url_text.winfo_exists():
            self.url_text.config(state=state)
        for btn in getattr(self, 'format_buttons', {}).values():
            if enabled:
                btn.config(state=tk.NORMAL, cursor="hand2")
            else:
                btn.config(
                    state=tk.DISABLED,
                    cursor="",
                    bg=btn.cget("bg"),
                    fg=btn.cget("fg"),
                )
        if hasattr(self, 'format_combo') and self.format_combo.winfo_exists():
            if enabled:
                combo_state = "readonly"
            else:
                combo_state = "disabled"
            self.format_combo.config(state=combo_state)
            try:
                self.format_combo.config(cursor="hand2" if combo_state != "disabled" else "")
            except tk.TclError:
                pass
        if hasattr(self, 'quality_combo') and self.quality_combo.winfo_exists():
            if enabled:
                combo_state = "readonly" if not self._is_audio_format(self.selected_format.get()) else "disabled"
            else:
                combo_state = "disabled"
            self.quality_combo.config(state=combo_state)
        if getattr(self, 'download_button', None):
            if self.download_button.cget("text") == "Download":
                if enabled:
                    self.download_button.config(
                        state=tk.NORMAL,
                        cursor="hand2",
                        bg=theme["success"],
                        fg=theme["bg"]
                    )
                else:
                    self.download_button.config(
                        state=tk.DISABLED,
                        cursor="",
                        bg=theme["disabled_bg"],
                        fg=theme["disabled_fg"]
                    )
            else:
                self.download_button.config(state=state, cursor="hand2" if enabled else "")
        if getattr(self, 'abort_button', None):
            if self.downloading:
                self.abort_button.config(
                    state=tk.NORMAL,
                    cursor="hand2",
                    bg=theme["danger"],
                    fg=theme["bg"]
                )
            else:
                self.abort_button.config(
                    state=tk.DISABLED,
                    cursor="",
                    bg=theme["disabled_bg"],
                    fg=theme["disabled_fg"]
                )
        if hasattr(self, 'gear_btn'):
            self.gear_btn.config(state=state, cursor="hand2" if enabled else "")

    def _register_theme_toggle(self, btn):
        if not btn:
            return
        if not hasattr(self, "_theme_toggle_buttons"):
            self._theme_toggle_buttons = []
        self._theme_toggle_buttons.append(btn)
        if getattr(self, "downloading", False):
            try:
                btn.config(state=tk.DISABLED, cursor="")
            except Exception:
                pass

    def _set_theme_toggle_state(self, enabled):
        buttons = getattr(self, "_theme_toggle_buttons", None) or []
        if not buttons:
            return
        alive = []
        for btn in buttons:
            if not btn or not getattr(btn, "winfo_exists", lambda: False)():
                continue
            try:
                btn.config(state=tk.NORMAL if enabled else tk.DISABLED, cursor="hand2" if enabled else "")
            except Exception:
                pass
            alive.append(btn)
        self._theme_toggle_buttons = alive

    def _show_reset_button(self):
        theme = self.theme
        if not getattr(self, 'download_button', None):
            return
        self.download_button.config(
            text="Reset",
            command=self.create_widgets,
            state=tk.NORMAL,
            bg=theme["surface_alt"],
            fg=theme["text"]
        )
        self.add_hover_effect(
            self.download_button,
            bg_normal=theme["surface_alt"],
            fg_normal=theme["text"],
            bg_hover=theme["surface_alt_hover"],
            fg_hover=theme["accent"]
        )

    def add_hover_effect(self, btn, *, is_selected_func=None, is_enabled_func=None, bg_normal=None, fg_normal=None, bg_hover=None, fg_hover=None, bg_selected=None, fg_selected=None, bg_disabled=None, fg_disabled=None, is_hover_enabled_func=None):
        theme = self.theme if hasattr(self, "theme") else THEME
        bg_normal = bg_normal or theme["surface_alt"]
        fg_normal = fg_normal or theme["text"]
        bg_hover = bg_hover or theme["surface_alt_hover"]
        fg_hover = fg_hover or theme["accent"]
        bg_selected = bg_selected or theme["accent"]
        fg_selected = fg_selected or theme["bg"]
        bg_disabled = bg_disabled or theme["disabled_bg"]
        fg_disabled = fg_disabled or theme["disabled_fg"]
        def is_widget_disabled():
            try:
                return str(btn.cget("state")) == "disabled"
            except Exception:
                return False
        def on_enter(e):
            if is_widget_disabled():
                return
            if is_hover_enabled_func and not is_hover_enabled_func():
                return
            if is_selected_func and is_selected_func():
                return
            if is_enabled_func and not is_enabled_func():
                return
            btn.config(bg=bg_hover, fg=fg_hover)
        def on_leave(e):
            if is_widget_disabled():
                return
            if is_enabled_func and not is_enabled_func():
                btn.config(bg=bg_disabled, fg=fg_disabled)
            elif is_selected_func and is_selected_func():
                btn.config(bg=bg_selected, fg=fg_selected)
            else:
                btn.config(bg=bg_normal, fg=fg_normal)
        btn.bind("<Enter>", on_enter)
        btn.bind("<Leave>", on_leave)

    def _disable_combo_scroll(self, combo):
        if not combo or not combo.winfo_exists():
            return
        def block(_event):
            return "break"
        combo.bind("<MouseWheel>", block)
        combo.bind("<Shift-MouseWheel>", block)
        combo.bind("<Button-4>", block)
        combo.bind("<Button-5>", block)

    def run_on_ui_thread(self, func, *args, **kwargs):
        if threading.current_thread() is threading.main_thread():
            func(*args, **kwargs)
        else:
            self.gui_queue.put(lambda: func(*args, **kwargs))
            self._schedule_gui_poll()

    def _ask_yesno_blocking(self, title, message):
        result = {"value": False}
        done = threading.Event()
        def ask():
            try:
                result["value"] = messagebox.askyesno(title, message)
            finally:
                done.set()
        self.run_on_ui_thread(ask)
        done.wait()
        return result["value"]

    def _after(self, delay_ms, callback, *, widget=None):
        target = widget or self.root
        safe_delay = max(0, int(delay_ms))
        return target.after(safe_delay, callback)

    def _window_has_focus(self):
        try:
            return self.root.focus_displayof() is not None
        except Exception:
            return False

    def process_gui_queue(self):
        if not self.status_polling:
            self._gui_poll_scheduled = False
            return
        try:
            processed = 0
            max_tasks = self._max_gui_tasks_per_tick
            while processed < max_tasks:
                func = self.gui_queue.get_nowait()
                try:
                    func()
                except Exception as e:
                    logging.error(f"Error running UI task: {e}")
                processed += 1
        except queue.Empty:
            pass
        if not self.gui_queue.empty():
            self._after(16, self.process_gui_queue)
        else:
            self._gui_poll_scheduled = False

    def _schedule_gui_poll(self):
        if not self.status_polling:
            return
        if self._gui_poll_scheduled:
            return
        self._gui_poll_scheduled = True
        self._after(16, self.process_gui_queue)

    def __init__(self, root):
        self.load_config()
        self.root = root
        self._theme_name = str(self.config.get("theme", "dark")).strip().lower()
        if self._theme_name == "light":
            self.theme = LIGHT_THEME
        else:
            self._theme_name = "dark"
            self.theme = THEME
        self._font_defs = {
            "title": ("Bahnschrift", 18, "bold"),
            "subtitle": ("Bahnschrift", 11),
            "label": ("Bahnschrift", 10, "bold"),
            "body": ("Bahnschrift", 12),
            "caption": ("Bahnschrift", 9),
            "button": ("Bahnschrift", 11, "bold"),
            "mono": ("Cascadia Mono", 10),
        }
        self.fonts = {}
        self._geometry_initialized = False
        self._active_part_targets = set()
        self._active_part_lock = threading.Lock()
        self._abort_notified = False
        self._percent_started = False
        self._batch_saved_links = None
        self._batch_wheel_bound = False
        self._batch_min_extra = 240
        self._resize_wrap_job = None
        self._resize_wrap_active = False
        self._console_wrap_before_resize = None
        self._resizing_ui = False
        self._last_progress_text = None
        self._progress_value = 0.0
        self._progress_fill_color = self.theme["accent"]
        self._closing = False
        self._pending_text_vars = {}
        self._pending_text_vars_scheduled = False
        self._current_view = None
        self._view_sizes = {}
        self._settings_enter_size = None
        self._settings_forced_size = None
        self._settings_user_resized = False
        self._batch_active = None
        self._batch_enter_size = None
        self._batch_forced_size = None
        self._batch_user_resized = False
        self._batch_resize_pending = False
        self._pending_main_rebuild = False
        self._window_resizing_enabled = bool(self.config.get('enable_window_resizing', True))
        self._url_dirty = False
        self._last_valid_url = None
        self._last_ready_url = None
        self._last_url_value = None
        self._last_ready_format = None
        self._quality_probe_job = None
        self._quality_probe_token = 0
        self._quality_probe_inflight = False
        self._quality_autopen = False
        self._quality_probe_url = None
        self._quality_probe_format = None
        self._quality_open_allow = False
        self._format_probe_job = None
        self._format_probe_token = 0
        self._format_probe_inflight = False
        self._format_probe_url = None
        self._format_cache = {}
        self._ui_scale_job = None
        self._ui_scale_percent = None
        self._ui_scale_factor = 1.0
        self._ui_scale_pending = None
        self._ui_scale_slider = None
        self._active_download_dir = None
        self._active_temp_base = None
        self._active_procs = set()
        self._nodejs_download_active = False
        self._nodejs_status_var = None
        self._nodejs_prompt_buttons = None
        self._ffmpeg_download_active = False
        self._ffmpeg_status_var = None
        self._ffmpeg_prompt_buttons = None
        self._theme_toggle_buttons = []
        try:
            self._base_tk_scaling = float(self.root.tk.call("tk", "scaling"))
        except Exception:
            self._base_tk_scaling = 1.0
        self._apply_ui_scale(self.config.get('ui_scale', 100), rebuild=False)
        self.root.title("MediaCrate") #Version 1.1.0
        self.root.configure(bg=self.theme["bg"])
        self.root.resizable(self._window_resizing_enabled, self._window_resizing_enabled)
        self.configure_styles()
        self.configure_geometry(prefer_tall=self.config.get('allow_batch_downloads', False))
        self._last_user_size = None
        self._ignore_resize = False
        self._gui_poll_scheduled = False
        self._status_poll_scheduled = False
        self._progress_poll_scheduled = False
        queue_cap = self._normalize_ui_queue_cap(self.config.get('ui_queue_cap'))
        self._max_gui_tasks_per_tick = queue_cap
        self._max_status_tasks_per_tick = queue_cap
        self._max_progress_updates_per_tick = queue_cap
        if self._window_resizing_enabled:
            self.root.bind("<Configure>", self._on_root_configure)
        self.root.protocol("WM_DELETE_WINDOW", self._on_window_close)
        self.status_queue = queue.Queue()
        self.progress_queue = queue.Queue()
        self.gui_queue = queue.Queue()
        self.downloading = False
        self.status_polling = True
        self.ydl = None
        self.abort_event = threading.Event()
        self.show_splash()
        self._after(100, self.deferred_startup)

    def center_window(self, width, height):
        self.root.update_idletasks()
        sw, sh = self.root.winfo_screenwidth(), self.root.winfo_screenheight()
        offset = int(min(200, sh * 0.12))
        x = int((sw / 2) - (width / 2))
        y = int((sh / 2) - (height / 2)) - offset
        x = max(0, x)
        y = max(0, y)
        self.root.geometry(f"{width}x{height}+{x}+{y}")

    def configure_geometry(self, prefer_tall=False):
        min_w, min_h = self._base_minsize()
        self.root.minsize(min_w, min_h)
        if not self._geometry_initialized:
            self._set_geometry_safe(min_w, min_h, center=True)
            self._geometry_initialized = True
            self._last_user_size = (min_w, min_h)

    def _base_minsize(self):
        screen_w = self.root.winfo_screenwidth()
        screen_h = self.root.winfo_screenheight()
        base_w = int(max(480, screen_w * 0.3)) + 80
        base_h = int(max(500, screen_h * 0.45))
        scale = getattr(self, "_ui_scale_factor", 1.0)
        min_w = int(base_w * scale)
        min_h = int(base_h * scale)
        return min_w, min_h

    def _record_view_size(self, view, width=None, height=None):
        if not view:
            return
        if width is None or height is None:
            width = self.root.winfo_width()
            height = self.root.winfo_height()
        if width < 1 or height < 1:
            return
        scale = getattr(self, "_ui_scale_factor", 1.0) or 1.0
        self._view_sizes[view] = (width / scale, height / scale)

    def _current_view_key(self, view=None):
        view = view or self._current_view or "main"
        if view == "main":
            is_batch = self.config.get('allow_batch_downloads', False)
            return "main_batch" if is_batch else "main"
        return view

    def _resolve_view_size(self, view):
        if not view:
            return None
        scale = getattr(self, "_ui_scale_factor", 1.0) or 1.0
        base = self._view_sizes.get(view)
        if base:
            return (
                max(1, int(round(base[0] * scale))),
                max(1, int(round(base[1] * scale)))
            )
        width = self.root.winfo_width()
        height = self.root.winfo_height()
        if width > 1 and height > 1:
            self._record_view_size(view, width, height)
            return (width, height)
        return None

    def _record_current_view_size(self):
        self._record_view_size(self._current_view_key())

    def _set_geometry_safe(self, width, height, *, center=False, manage_ignore=True):
        if manage_ignore:
            self._ignore_resize = True
        if center:
            self.center_window(width, height)
        else:
            self.root.geometry(f"{width}x{height}")
        if manage_ignore:
            self._after(120, lambda: setattr(self, "_ignore_resize", False))

    def _on_root_configure(self, event):
        if not getattr(self, "_window_resizing_enabled", True):
            return
        if event.widget is not self.root:
            return
        if self._ignore_resize:
            return
        if getattr(self, "_transitioning", False):
            return
        if self.root.state() != "normal":
            return
        if event.width < 1 or event.height < 1:
            return
        new_size = (event.width, event.height)
        if self._last_user_size == new_size:
            return
        if getattr(self, "_current_view", None) == "settings":
            forced_size = getattr(self, "_settings_forced_size", None)
            if not getattr(self, "_settings_user_resized", False) and forced_size:
                if abs(new_size[0] - forced_size[0]) <= 2 and abs(new_size[1] - forced_size[1]) <= 2:
                    self._settings_forced_size = new_size
                    return
                self._settings_user_resized = True
                if getattr(self, "_batch_active", False):
                    self._batch_user_resized = True
        if getattr(self, "_current_view", None) == "main" and getattr(self, "_batch_active", False):
            if getattr(self, "_batch_resize_pending", False):
                return
            forced_size = getattr(self, "_batch_forced_size", None)
            if not getattr(self, "_batch_user_resized", False) and forced_size:
                if abs(new_size[0] - forced_size[0]) <= 2 and abs(new_size[1] - forced_size[1]) <= 2:
                    self._batch_forced_size = new_size
                    return
                self._batch_user_resized = True
        self._last_user_size = new_size
        self._record_view_size(self._current_view_key(), event.width, event.height)
        self._begin_resize_wrap()

    def _begin_resize_wrap(self):
        self._resizing_ui = True
        if not self._resize_wrap_active:
            self._set_console_wrap_during_resize(True)
        if self._resize_wrap_job:
            self.root.after_cancel(self._resize_wrap_job)
        self._resize_wrap_job = self._after(60, self._end_resize_wrap)

    def _end_resize_wrap(self):
        self._resize_wrap_job = None
        self._set_console_wrap_during_resize(False)
        self._resizing_ui = False

    def _set_console_wrap_during_resize(self, active):
        console = getattr(self, "console", None)
        console_frame = getattr(self, "console_frame", None)
        if not console or not console.winfo_exists():
            self._resize_wrap_active = False
            return
        if not console_frame or not console_frame.winfo_exists():
            self._resize_wrap_active = False
            return
        try:
            if active:
                if not self._resize_wrap_active:
                    self._console_wrap_before_resize = console.cget("wrap")
                    self._resize_wrap_active = True
                if console.cget("wrap") != "none":
                    console.config(wrap="none")
            else:
                if self._resize_wrap_active:
                    console.config(wrap=self._console_wrap_before_resize or "word")
                self._resize_wrap_active = False
        except Exception:
            self._resize_wrap_active = False

    def _apply_window_constraints(self, *, min_extra=0):
        min_w, min_h = self._base_minsize()
        scale = getattr(self, "_ui_scale_factor", 1.0)
        target_min_h = min_h + int(min_extra * scale)
        self._ignore_resize = True
        self.root.minsize(min_w, target_min_h)
        if self._last_user_size:
            target_w = max(self._last_user_size[0], min_w)
            target_h = max(self._last_user_size[1], target_min_h)
        else:
            target_w = max(self.root.winfo_width(), min_w)
            target_h = max(self.root.winfo_height(), target_min_h)
        current_w = self.root.winfo_width()
        current_h = self.root.winfo_height()
        if target_w != current_w or target_h != current_h:
            self._set_geometry_safe(target_w, target_h, manage_ignore=False)
        self._after(120, lambda: setattr(self, "_ignore_resize", False))

    def configure_styles(self):
        theme = self.theme
        fonts = self.fonts if hasattr(self, "fonts") else None
        style = ttk.Style(self.root)
        style.theme_use("clam")
        style.configure("TFrame", background=theme["bg"])
        style.configure("TLabel", background=theme["bg"], foreground=theme["text"])
        style.configure(
            "Modern.Horizontal.TProgressbar",
            troughcolor=theme["surface_alt"],
            bordercolor=theme["border"],
            background=theme["accent"],
            lightcolor=theme["accent"],
            darkcolor=theme["accent"],
            thickness=self._px(72),
        )
        style.configure(
            "Modern.Small.Horizontal.TProgressbar",
            troughcolor=theme["surface_alt"],
            bordercolor=theme["border"],
            background=theme["accent"],
            lightcolor=theme["accent"],
            darkcolor=theme["accent"],
            thickness=self._px(16),
        )
        style.configure(
            "Modern.Small.Complete.Horizontal.TProgressbar",
            troughcolor=theme["surface_alt"],
            bordercolor=theme["border"],
            background=theme["success"],
            lightcolor=theme["success"],
            darkcolor=theme["success"],
            thickness=self._px(16),
        )
        style.configure(
            "Modern.Small.Disabled.Horizontal.TProgressbar",
            troughcolor=theme["surface_alt"],
            bordercolor=theme["border"],
            background=theme["disabled_fg"],
            lightcolor=theme["disabled_fg"],
            darkcolor=theme["disabled_fg"],
            thickness=self._px(16),
        )
        style.configure(
            "Modern.Complete.Horizontal.TProgressbar",
            troughcolor=theme["surface_alt"],
            bordercolor=theme["border"],
            background=theme["success"],
            lightcolor=theme["success"],
            darkcolor=theme["success"],
            thickness=self._px(72),
        )
        style.layout("Modern.Horizontal.TProgressbar",
            [('Horizontal.Progressbar.trough',
              {'children': [('Horizontal.Progressbar.pbar',
                             {'side': 'left', 'sticky': 'ns'})],
               'sticky': 'nswe'})]
        )
        style.layout("Modern.Small.Horizontal.TProgressbar",
            [('Horizontal.Progressbar.trough',
              {'children': [('Horizontal.Progressbar.pbar',
                             {'side': 'left', 'sticky': 'ns'})],
               'sticky': 'nswe'})]
        )
        style.layout("Modern.Small.Complete.Horizontal.TProgressbar",
            [('Horizontal.Progressbar.trough',
              {'children': [('Horizontal.Progressbar.pbar',
                             {'side': 'left', 'sticky': 'ns'})],
               'sticky': 'nswe'})]
        )
        style.layout("Modern.Small.Disabled.Horizontal.TProgressbar",
            [('Horizontal.Progressbar.trough',
              {'children': [('Horizontal.Progressbar.pbar',
                             {'side': 'left', 'sticky': 'ns'})],
               'sticky': 'nswe'})]
        )
        style.layout("Modern.Complete.Horizontal.TProgressbar",
            [('Horizontal.Progressbar.trough',
              {'children': [('Horizontal.Progressbar.pbar',
                             {'side': 'left', 'sticky': 'ns'})],
               'sticky': 'nswe'})]
        )
        combo_font = None
        listbox_font = None
        if fonts:
            combo_font = fonts["button"]
            listbox_font = (fonts["body"][0], max(9, fonts["button"][1] - 1))
        style.configure(
            "WhiteOnBlack.TCombobox",
            fieldbackground=theme["surface_alt"],
            background=theme["surface_alt"],
            foreground=theme["text"],
            selectforeground=theme["text"],
            selectbackground=theme["surface_alt"],
            arrowcolor=theme["text"],
            bordercolor=theme["border"],
            borderwidth=1,
            padding=self._px(14),
            focuscolor=theme["surface_alt"],
            focusthickness=0,
            font=combo_font
        )
        style.map(
            "WhiteOnBlack.TCombobox",
            fieldbackground=[('readonly', theme["surface_alt"]), ('disabled', theme["disabled_bg"]), ('focus', theme["surface_alt"])],
            background=[('readonly', theme["surface_alt"]), ('disabled', theme["disabled_bg"]), ('focus', theme["surface_alt"])],
            foreground=[('readonly', theme["text"]), ('disabled', theme["disabled_fg"]), ('focus', theme["text"])],
            selectbackground=[('readonly', theme["surface_alt"])],
            selectforeground=[('readonly', theme["text"])],
            arrowcolor=[('readonly', theme["text"]), ('disabled', theme["disabled_fg"])],
            bordercolor=[('focus', theme["border"]), ('!focus', theme["border"])],
            lightcolor=[('focus', theme["surface_alt"]), ('!focus', theme["surface_alt"])],
            darkcolor=[('focus', theme["surface_alt"]), ('!focus', theme["surface_alt"])],
        )
        style.configure(
            "AccentText.TCombobox",
            fieldbackground=theme["surface_alt"],
            background=theme["surface_alt"],
            foreground=theme["accent"],
            selectforeground=theme["accent"],
            selectbackground=theme["surface_alt"],
            arrowcolor=theme["text"],
            bordercolor=theme["border"],
            borderwidth=1,
            padding=self._px(14),
            focuscolor=theme["surface_alt"],
            focusthickness=0,
            font=combo_font
        )
        style.map(
            "AccentText.TCombobox",
            fieldbackground=[('readonly', theme["surface_alt"]), ('disabled', theme["disabled_bg"]), ('focus', theme["surface_alt"])],
            background=[('readonly', theme["surface_alt"]), ('disabled', theme["disabled_bg"]), ('focus', theme["surface_alt"])],
            foreground=[('readonly', theme["accent"]), ('disabled', theme["disabled_fg"]), ('focus', theme["accent"])],
            selectbackground=[('readonly', theme["surface_alt"])],
            selectforeground=[('readonly', theme["accent"])],
            arrowcolor=[('readonly', theme["text"]), ('disabled', theme["disabled_fg"])],
            bordercolor=[('focus', theme["border"]), ('!focus', theme["border"])],
            lightcolor=[('focus', theme["surface_alt"]), ('!focus', theme["surface_alt"])],
            darkcolor=[('focus', theme["surface_alt"]), ('!focus', theme["surface_alt"])],
        )
        style.configure(
            "Modern.Vertical.TScrollbar",
            background=theme["surface_alt"],
            troughcolor=theme["surface"],
            bordercolor=theme["border"],
            arrowcolor=theme["text"],
            lightcolor=theme["surface_alt"],
            darkcolor=theme["surface_alt"],
            width=self._px(16),
            arrowsize=self._px(16),
        )
        style.map(
            "Modern.Vertical.TScrollbar",
            background=[("active", theme["surface_alt_hover"]), ("pressed", theme["surface_alt_hover"])],
            arrowcolor=[("active", theme["text"]), ("pressed", theme["text"])],
        )
        style.configure(
            "Modern.Horizontal.TScrollbar",
            background=theme["surface_alt"],
            troughcolor=theme["surface"],
            bordercolor=theme["border"],
            arrowcolor=theme["text"],
            lightcolor=theme["surface_alt"],
            darkcolor=theme["surface_alt"],
            width=self._px(16),
            arrowsize=self._px(16),
        )
        style.map(
            "Modern.Horizontal.TScrollbar",
            background=[("active", theme["surface_alt_hover"]), ("pressed", theme["surface_alt_hover"])],
            arrowcolor=[("active", theme["text"]), ("pressed", theme["text"])],
        )
        self.root.option_add("*TCombobox*Listbox*Background", theme["surface"])
        self.root.option_add("*TCombobox*Listbox*Foreground", theme["text"])
        self.root.option_add("*TCombobox*Listbox*selectBackground", theme["accent"])
        self.root.option_add("*TCombobox*Listbox*selectForeground", theme["bg"])
        if listbox_font:
            self.root.option_add("*TCombobox*Listbox*Font", listbox_font)

    def _build_fonts(self, scale):
        fonts = {}
        for name, spec in self._font_defs.items():
            family = spec[0]
            size = spec[1]
            weight = spec[2] if len(spec) > 2 else None
            scaled_size = max(7, int(round(size * scale)))
            if weight:
                fonts[name] = (family, scaled_size, weight)
            else:
                fonts[name] = (family, scaled_size)
        return fonts

    def _px(self, value):
        scale = getattr(self, "_ui_scale_factor", 1.0) or 1.0
        if isinstance(value, (tuple, list)):
            return tuple(self._px(item) for item in value)
        try:
            return int(round(float(value) * scale))
        except Exception:
            return value

    def _update_ui_scale_slider(self):
        slider = getattr(self, "_ui_scale_slider", None)
        if not slider or not slider.winfo_exists():
            return
        try:
            slider.config(
                length=self._px(320),
                sliderlength=self._px(24),
                width=self._px(14),
                font=self.fonts.get("body") if hasattr(self, "fonts") else None,
            )
        except Exception:
            pass

    def _apply_ui_scale(self, percent, rebuild=True):
        try:
            percent = int(round(float(percent)))
        except Exception:
            percent = 100
        percent = max(50, min(200, percent))
        if percent == getattr(self, "_ui_scale_percent", None):
            return
        old_scale = getattr(self, "_ui_scale_factor", 1.0)
        try:
            width = self.root.winfo_width()
            height = self.root.winfo_height()
            if width > 1 and height > 1 and old_scale:
                view_key = self._current_view_key()
                self._view_sizes[view_key] = (width / old_scale, height / old_scale)
        except Exception:
            pass
        self._ui_scale_percent = percent
        scale = percent / 100.0
        self._ui_scale_factor = scale
        try:
            self.root.tk.call("tk", "scaling", self._base_tk_scaling * scale)
        except Exception:
            pass
        self.fonts = self._build_fonts(scale)
        self.configure_styles()
        self._update_ui_scale_slider()
        if rebuild:
            try:
                if self.root.state() == "normal":
                    width = self.root.winfo_width()
                    height = self.root.winfo_height()
                    if width > 1 and height > 1 and old_scale > 0:
                        ratio = scale / old_scale
                        new_w = max(1, int(width * ratio))
                        new_h = max(1, int(height * ratio))
                        self._set_geometry_safe(new_w, new_h, manage_ignore=False)
                        self._last_user_size = (new_w, new_h)
                        self._record_view_size(self._current_view_key(), new_w, new_h)
            except Exception:
                pass
        if not rebuild:
            return
        if getattr(self, "_current_view", None) == "settings":
            self._pending_main_rebuild = True
            self.show_settings()
        else:
            self._pending_main_rebuild = False
            self.create_widgets(force_rebuild=True, switch_view=True)

    def enforce_min_size(self):
        self.root.update_idletasks()
        req_w = self.root.winfo_reqwidth()
        req_h = self.root.winfo_reqheight()
        min_w, min_h = self.root.minsize()
        screen_w = self.root.winfo_screenwidth()
        screen_h = self.root.winfo_screenheight()
        self.root.minsize(
            min(max(min_w, req_w), screen_w),
            min(max(min_h, req_h), screen_h)
        )

    def _sync_card_heights(self, *cards):
        self.root.update_idletasks()
        heights = [card.winfo_reqheight() for card in cards if card.winfo_exists()]
        if not heights:
            return
        target = max(heights)
        for card in cards:
            if card.winfo_exists():
                card.configure(height=target)
                card.grid_propagate(False)

    def _configure_footer(self, footer, left_frame, right_frame, min_width=520):
        min_width = self._px(min_width)
        def layout(compact):
            if getattr(footer, "_compact", None) == compact:
                return
            for child in footer.grid_slaves():
                child.grid_forget()
            footer.grid_columnconfigure(0, weight=1)
            footer.grid_columnconfigure(1, weight=1 if not compact else 0)
            if compact:
                left_frame.grid(row=0, column=0, sticky="w")
                right_frame.grid(row=1, column=0, sticky="e", pady=self._px((4, 0)))
            else:
                left_frame.grid(row=0, column=0, sticky="w")
                right_frame.grid(row=0, column=1, sticky="e")
            footer._compact = compact

        def on_resize(event):
            if getattr(footer, "_resize_job", None):
                footer.after_cancel(footer._resize_job)
            footer._resize_job = self._after(60, lambda: layout(event.width < min_width), widget=footer)

        def initial_layout():
            if not footer.winfo_exists():
                return
            try:
                footer.update_idletasks()
            except Exception:
                pass
            width = max(footer.winfo_width(), footer.winfo_reqwidth())
            layout(width < min_width)

        footer.bind("<Configure>", on_resize)
        self._after(0, initial_layout, widget=footer)

    def _create_footer(self, parent, *, show_settings=False, show_back=False, show_downloads=False, rebuild_fn=None, min_width=520):
        if getattr(self, "_footer_bar", None) and self._footer_bar.winfo_exists():
            try:
                self._footer_bar.destroy()
            except Exception:
                pass
        theme = self.theme
        fonts = self.fonts
        bottom_bar = tk.Frame(parent, bg=theme["bg"], padx=self._px(24), pady=self._px(8))
        bottom_bar.pack(side="bottom", fill="x")
        bottom_left = tk.Frame(bottom_bar, bg=theme["bg"])
        bottom_right = tk.Frame(bottom_bar, bg=theme["bg"])

        toggle_cmd = (lambda: self._toggle_theme_and(rebuild_fn)) if rebuild_fn else self.toggle_theme
        theme_toggle_btn = tk.Button(
            bottom_left, text=self._theme_icon(), font=fonts["label"],
            bg=theme["bg"], fg=theme["muted"],
            activebackground=theme["bg"], activeforeground=theme["text"],
            relief="flat", bd=0, padx=self._px(6), pady=self._px(2), command=toggle_cmd, cursor="hand2"
        )
        theme_toggle_btn.pack(side="left", anchor="w", padx=self._px((0, 8)))
        self._register_theme_toggle(theme_toggle_btn)
        self.add_hover_effect(
            theme_toggle_btn,
            bg_normal=theme["bg"], fg_normal=theme["muted"],
            bg_hover=theme["bg"], fg_hover=theme["accent"]
        )

        if show_settings:
            settings_btn = tk.Button(
                bottom_left, text="Settings", font=fonts["label"],
                bg=theme["bg"], fg=theme["muted"],
                activebackground=theme["bg"], activeforeground=theme["text"],
                relief="flat", bd=0, padx=self._px(8), pady=self._px(2), command=self.show_settings, cursor="hand2"
            )
            settings_btn.pack(side="left", anchor="w")
            self.add_hover_effect(
                settings_btn,
                bg_normal=theme["bg"], fg_normal=theme["muted"],
                bg_hover=theme["bg"], fg_hover=theme["accent"],
                is_hover_enabled_func=lambda: not self.downloading
            )
            self.gear_btn = settings_btn

        if show_back:
            back_btn = tk.Button(
                bottom_left, text="Back", font=fonts["label"],
                bg=theme["bg"], fg=theme["muted"],
                activebackground=theme["bg"], activeforeground=theme["text"],
                relief="flat", bd=0, padx=self._px(8), pady=self._px(2), command=self.show_main_view, cursor="hand2"
            )
            back_btn.pack(side="left", anchor="w", padx=self._px((0, 8)))
            self.add_hover_effect(back_btn, bg_normal=theme["bg"], fg_normal=theme["muted"], bg_hover=theme["bg"], fg_hover=theme["accent"])

        if show_downloads:
            downloads_link = tk.Label(bottom_right, text="Open downloads folder", font=fonts["caption"], fg=theme["accent"], bg=theme["bg"], cursor="hand2")
            downloads_link.pack(side="right", anchor="e", padx=self._px((0, 12)))
            downloads_link.bind("<Button-1>", lambda e: self.open_downloads_folder())
            self.add_hover_effect(
                downloads_link,
                bg_normal=theme["bg"], fg_normal=theme["accent"],
                bg_hover=theme["bg"], fg_hover=theme["text"]
            )

        official_link = tk.Label(bottom_right, text="Official page", font=fonts["caption"], fg=theme["accent"], bg=theme["bg"], cursor="hand2")
        official_link.pack(side="right", anchor="e", padx=self._px((0, 12)))
        official_link.bind("<Button-1>", lambda e: self.open_url("https://justagwas.com/projects/mediacrate"))
        self.add_hover_effect(
            official_link,
            bg_normal=theme["bg"], fg_normal=theme["accent"],
            bg_hover=theme["bg"], fg_hover=theme["text"]
        )
        version_label = tk.Label(bottom_right, text="v1.1.0", font=fonts["caption"], fg=theme["muted"], bg=theme["bg"])
        version_label.pack(side="right", anchor="e", padx=self._px((0, 8)))

        self._configure_footer(bottom_bar, bottom_left, bottom_right, min_width=min_width)
        self._footer_bar = bottom_bar
        return bottom_bar

    def _clear_footer(self):
        if getattr(self, "_footer_bar", None) and self._footer_bar.winfo_exists():
            try:
                self._footer_bar.destroy()
            except Exception:
                pass
        self._footer_bar = None

    def show_splash(self):
        theme = self.theme
        fonts = self.fonts
        self.splash_frame = tk.Frame(self.root, bg=theme["bg"])
        self.splash_frame.pack(fill="both", expand=True)
        tk.Label(self.splash_frame, text="MediaCrate", font=fonts["title"], fg=theme["text"], bg=theme["bg"]).pack(pady=self._px(40))
        tk.Label(self.splash_frame, text="Loading, please wait...", font=fonts["subtitle"], fg=theme["muted"], bg=theme["bg"]).pack(pady=self._px(10))
        self.progress = ttk.Progressbar(self.splash_frame, mode="indeterminate", length=self._px(280), style="Modern.Small.Horizontal.TProgressbar")
        self.progress.pack(pady=self._px(20))
        self.progress.start(10)
        self._create_footer(self.splash_frame, rebuild_fn=self.show_splash)

    def deferred_startup(self):
        if not self.config.get('ui_scale_confirmed', False):
            self.set_icon(prompt_if_missing=False)
            self.show_ui_scale_prompt(on_complete=self._continue_startup)
            return
        self._continue_startup()

    def _continue_startup(self):
        self.set_icon()
        def after_updates():
            if not self.config.get('first_launch_complete', False):
                self.show_first_launch_wizard(on_complete=self.show_main_ui)
                return
            self.show_main_ui()
        def after_nodejs():
            if self.config.get('auto_check_updates', True):
                self.check_for_updates(on_complete=after_updates)
            else:
                after_updates()
        def after_ffmpeg():
            self._nodejs_callback = after_nodejs
            self.check_nodejs()
        self._ffmpeg_callback = after_ffmpeg
        self.check_ffmpeg()

    def show_main_ui(self):
        if getattr(self, 'splash_frame', None):
            self.splash_frame.destroy()
        self.create_widgets()
        is_batch = self.config.get('allow_batch_downloads', False)
        self._batch_active = is_batch
        self._after(0, lambda: self._apply_window_constraints(
            min_extra=self._batch_min_extra if is_batch else 0
        ))

    def show_ui_scale_prompt(self, on_complete=None, preserve_size=None):
        theme = self.theme
        fonts = self.fonts
        self._ui_scale_prompt_active = True
        for widget in self.root.winfo_children():
            widget.destroy()

        target_frame = tk.Frame(self.root, bg=theme["bg"])
        target_frame.pack(fill="both", expand=True)
        card = tk.Frame(target_frame, bg=theme["surface"], highlightthickness=1, highlightbackground=theme["border"])
        card.pack(fill="both", expand=True, padx=self._px(32), pady=self._px(32))
        content = tk.Frame(card, bg=theme["surface"])
        content.pack(fill="both", expand=True, padx=self._px(28), pady=self._px(24))
        footer = tk.Frame(card, bg=theme["surface"])
        footer.pack(fill="x", padx=self._px(28), pady=self._px(16))

        title_label = tk.Label(content, text="Choose your Window Size", font=fonts["subtitle"], fg=theme["text"], bg=theme["surface"])
        title_label.pack(anchor="w")
        desc_label = tk.Label(
            content,
            text="Set the overall size of text and controls. You can change this later in Settings.",
            font=fonts["body"],
            fg=theme["muted"],
            bg=theme["surface"],
            wraplength=self._px(560),
            justify="left"
        )
        desc_label.pack(anchor="w", pady=self._px((6, 16)))

        pending = getattr(self, "_pending_ui_scale_choice", None)
        if pending is not None:
            current_percent = pending
        else:
            try:
                current_percent = int(self.config.get("ui_scale", 100))
            except Exception:
                current_percent = 100
        current_percent = max(50, min(200, current_percent))
        scale_var = tk.IntVar(value=current_percent)
        value_label = tk.Label(content, text=f"{current_percent}%", font=fonts["body"], fg=theme["text"], bg=theme["surface"])
        value_label.pack(anchor="w", pady=self._px((0, 6)))

        base_scale = getattr(self, "_ui_scale_factor", 1.0) or 1.0
        try:
            self.root.update_idletasks()
            base_width = self.root.winfo_width()
            base_height = self.root.winfo_height()
        except Exception:
            base_width, base_height = 0, 0
        if base_width <= 1 or base_height <= 1:
            base_width, base_height = 640, 420
        base_size = (base_width / base_scale, base_height / base_scale)
        try:
            min_w, min_h = self.root.minsize()
        except Exception:
            min_w, min_h = (base_width, base_height)
        base_minsize = (min_w / base_scale, min_h / base_scale)

        def rebuild_footer_bar():
            self._create_footer(
                target_frame,
                rebuild_fn=lambda: self.show_ui_scale_prompt(
                    on_complete,
                    preserve_size=(self.root.winfo_width(), self.root.winfo_height())
                )
            )

        def apply_prompt_scale():
            try:
                title_label.config(font=self.fonts["subtitle"])
                desc_label.config(font=self.fonts["body"], wraplength=self._px(560))
                value_label.config(font=self.fonts["body"])
                rec_label.config(font=self.fonts["caption"])
                proceed_btn.config(
                    font=self.fonts["label"],
                    padx=self._px(18),
                    pady=self._px(4),
                )
                scale.config(
                    length=self._px(360),
                    sliderlength=self._px(48),
                    width=self._px(24),
                )
                content.pack_configure(padx=self._px(28), pady=self._px(24))
                footer.pack_configure(padx=self._px(28), pady=self._px(16))
                card.pack_configure(padx=self._px(32), pady=self._px(32))
            except Exception:
                pass

        def on_scale_change(raw):
            try:
                percent = int(round(float(raw)))
            except Exception:
                return
            percent = max(50, min(200, percent))
            value_label.config(text=f"{percent}%")
            scale_var.set(percent)
            self._pending_ui_scale_choice = percent

        def commit_scale(_event=None):
            try:
                percent = int(scale_var.get())
            except Exception:
                percent = 100
            percent = max(50, min(200, percent))
            value_label.config(text=f"{percent}%")
            old_scale = getattr(self, "_ui_scale_factor", 1.0) or 1.0
            self._apply_ui_scale(percent, rebuild=False)
            apply_prompt_scale()
            rebuild_footer_bar()
            try:
                new_scale = (getattr(self, "_ui_scale_factor", 1.0) or 1.0)
                ratio = new_scale / old_scale if old_scale > 0 else 1.0
                new_w = max(1, int(base_size[0] * new_scale))
                new_h = max(1, int(base_size[1] * new_scale))
                new_min_w = max(1, int(base_minsize[0] * new_scale))
                new_min_h = max(1, int(base_minsize[1] * new_scale))
                self.root.minsize(new_min_w, new_min_h)
                self._set_geometry_safe(new_w, new_h, manage_ignore=False)
            except Exception:
                pass

        scale = tk.Scale(
            content,
            from_=50,
            to=200,
            orient="horizontal",
            showvalue=False,
            variable=scale_var,
            command=on_scale_change,
            length=self._px(360),
            sliderlength=self._px(48),
            width=self._px(24),
            resolution=5,
            troughcolor=theme["surface_alt"],
            highlightthickness=0,
            bg=theme["surface"],
            fg=theme["text"]
        )
        scale.pack(anchor="w")
        scale.bind("<ButtonRelease-1>", commit_scale)
        scale.bind("<KeyRelease>", commit_scale)

        rec_label = tk.Label(content, text="Recommended: 100%", font=fonts["caption"], fg=theme["muted"], bg=theme["surface"])
        rec_label.pack(anchor="w", pady=self._px((8, 0)))

        def proceed():
            try:
                percent = int(scale_var.get())
            except Exception:
                percent = 100
            percent = max(50, min(200, percent))
            self.config["ui_scale"] = percent
            self.config["ui_scale_confirmed"] = True
            self.save_config()
            self._ui_scale_prompt_active = False
            self._pending_ui_scale_choice = None
            try:
                target_frame.destroy()
            except Exception:
                pass
            self.set_icon(prompt_if_missing=True)
            if on_complete:
                on_complete()

        proceed_btn = tk.Button(
            footer, text="Continue", font=fonts["label"],
            bg=theme["accent"], fg=theme["bg"],
            activebackground=theme["accent_hover"], activeforeground=theme["bg"],
            relief="flat", bd=0, padx=self._px(18), pady=self._px(4), command=proceed, cursor="hand2"
        )
        proceed_btn.pack(side="right")
        self.add_hover_effect(proceed_btn, bg_normal=theme["accent"], fg_normal=theme["bg"], bg_hover=theme["accent_hover"], fg_hover=theme["bg"])

        apply_prompt_scale()
        rebuild_footer_bar()
        if preserve_size:
            try:
                width, height = preserve_size
                if width and height:
                    self._set_geometry_safe(width, height, manage_ignore=False)
            except Exception:
                pass

    def show_first_launch_wizard(self, on_complete=None, start_index=0, wizard_state=None):
        theme = self.theme
        fonts = self.fonts
        for widget in self.root.winfo_children():
            widget.destroy()

        defaults = {
            "download_location": self._default_download_dir(),
            "enable_window_resizing": False,
            "default_format_selection": "",
            "disable_warnings": False,
            "disable_already_downloaded_prompts": False,
        }
        if wizard_state is None:
            wizard_state = {
                "download_location": self.config.get("download_location", defaults["download_location"]),
                "enable_window_resizing": bool(self.config.get("enable_window_resizing", defaults["enable_window_resizing"])),
                "default_format_selection": str(self.config.get("default_format_selection", defaults["default_format_selection"]) or "").strip().lower(),
                "disable_warnings": bool(self.config.get("disable_warnings", defaults["disable_warnings"])),
                "disable_already_downloaded_prompts": bool(self.config.get("disable_already_downloaded_prompts", defaults["disable_already_downloaded_prompts"])),
            }
        else:
            wizard_state["download_location"] = wizard_state.get(
                "download_location",
                self.config.get("download_location", defaults["download_location"])
            )
            wizard_state["enable_window_resizing"] = bool(wizard_state.get(
                "enable_window_resizing",
                self.config.get("enable_window_resizing", defaults["enable_window_resizing"])
            ))
            wizard_state["default_format_selection"] = str(
                wizard_state.get(
                    "default_format_selection",
                    self.config.get("default_format_selection", defaults["default_format_selection"])
                ) or ""
            ).strip().lower()
            wizard_state["disable_warnings"] = bool(wizard_state.get(
                "disable_warnings",
                self.config.get("disable_warnings", defaults["disable_warnings"])
            ))
            wizard_state["disable_already_downloaded_prompts"] = bool(wizard_state.get(
                "disable_already_downloaded_prompts",
                self.config.get("disable_already_downloaded_prompts", defaults["disable_already_downloaded_prompts"])
            ))

        def format_label_from_value(value):
            val = str(value or "").strip().lower()
            return {
                "video": "VIDEO",
                "audio": "AUDIO",
                "mp4": "MP4",
                "mp3": "MP3",
            }.get(val, "")

        steps = [
            {
                "type": "welcome",
                "title": "Let's get you set up",
                "description": "It looks like this is your first time launching MediaCrate. We'll guide you through the most important settings now.",
            },
            {
                "type": "path",
                "key": "download_location",
                "title": "Download location",
                "description": "Choose where downloaded files will be saved.",
                "recommended": defaults["download_location"],
            },
            {
                "type": "bool",
                "key": "disable_warnings",
                "title": "Disable quality/format warnings",
                "description": "Skip warnings when changing format or quality.",
                "recommended": defaults["disable_warnings"],
            },
            {
                "type": "bool",
                "key": "disable_already_downloaded_prompts",
                "title": "Disable prompts for already downloaded files",
                "description": "Don't ask before re-downloading a file that already exists.",
                "recommended": defaults["disable_already_downloaded_prompts"],
            },
            {
                "type": "bool",
                "key": "enable_window_resizing",
                "title": "Resizable window",
                "description": "Allow resizing the main window.",
                "recommended": defaults["enable_window_resizing"],
            },
            {
                "type": "format",
                "key": "default_format_selection",
                "title": "Default format",
                "description": "Choose a default format to preselect when the app launches.",
                "choices": ["None (select manually)", "VIDEO", "AUDIO", "MP4", "MP3"],
                "recommended": "None (select manually)",
            },
        ]

        root_frame = tk.Frame(self.root, bg=theme["bg"])
        root_frame.pack(fill="both", expand=True)
        card = tk.Frame(root_frame, bg=theme["surface"], highlightthickness=1, highlightbackground=theme["border"])
        card.pack(fill="both", expand=True, padx=self._px(32), pady=self._px(32))
        content = tk.Frame(card, bg=theme["surface"])
        content.pack(fill="both", expand=True, padx=self._px(28), pady=self._px(24))
        footer = tk.Frame(card, bg=theme["surface"])
        footer.pack(fill="x", padx=self._px(28), pady=self._px(16))

        state = {"index": 0, "step": None, "vars": None}

        def set_nav_buttons(show_back, next_label, show_skip):
            for widget in footer.winfo_children():
                widget.destroy()
            if show_back:
                back_btn = tk.Button(
                    footer, text="Back", font=fonts["label"],
                    bg=theme["surface_alt"], fg=theme["text"],
                    activebackground=theme["surface_alt_hover"], activeforeground=theme["text"],
                    relief="flat", bd=0, padx=self._px(14), pady=self._px(4), command=go_back, cursor="hand2"
                )
                back_btn.pack(side="left")
                self.add_hover_effect(back_btn, bg_normal=theme["surface_alt"], fg_normal=theme["text"], bg_hover=theme["surface_alt_hover"], fg_hover=theme["accent"])
            if show_skip:
                skip_btn = tk.Button(
                    footer, text="Skip", font=fonts["label"],
                    bg=theme["bg"], fg=theme["muted"],
                    activebackground=theme["bg"], activeforeground=theme["text"],
                    relief="flat", bd=0, padx=self._px(12), pady=self._px(4), command=skip_wizard, cursor="hand2"
                )
                skip_btn.pack(side="right")
                self.add_hover_effect(skip_btn, bg_normal=theme["bg"], fg_normal=theme["muted"], bg_hover=theme["bg"], fg_hover=theme["accent"])
            next_btn = tk.Button(
                footer, text=next_label, font=fonts["label"],
                bg=theme["accent"], fg=theme["bg"],
                activebackground=theme["accent_hover"], activeforeground=theme["bg"],
                relief="flat", bd=0, padx=self._px(18), pady=self._px(4), command=go_next, cursor="hand2"
            )
            next_btn.pack(side="right", padx=self._px((8, 0)))
            self.add_hover_effect(next_btn, bg_normal=theme["accent"], fg_normal=theme["bg"], bg_hover=theme["accent_hover"], fg_hover=theme["bg"])

        def render_step(index):
            state["index"] = index
            state["step"] = steps[index]
            state["vars"] = None
            for widget in content.winfo_children():
                widget.destroy()
            step = steps[index]

            tk.Label(content, text=step["title"], font=fonts["subtitle"], fg=theme["text"], bg=theme["surface"]).pack(anchor="w")
            tk.Label(
                content,
                text=step["description"],
                font=fonts["body"],
                fg=theme["muted"],
                bg=theme["surface"],
                wraplength=self._px(560),
                justify="left"
            ).pack(anchor="w", pady=self._px((6, 16)))

            if step["type"] == "welcome":
                hint = "You can always change these later in Settings."
                tk.Label(content, text=hint, font=fonts["caption"], fg=theme["muted"], bg=theme["surface"]).pack(anchor="w", pady=self._px((0, 8)))
                set_nav_buttons(show_back=False, next_label="Proceed", show_skip=True)
                return

            step_vars = {}

            if step["type"] == "bool":
                var = tk.BooleanVar(value=bool(wizard_state.get(step["key"], step["recommended"])))
                cb = tk.Checkbutton(
                    content,
                    text="Enable",
                    variable=var,
                    font=fonts["body"],
                    bg=theme["surface"],
                    fg=theme["text"],
                    selectcolor=theme["surface_alt"],
                    activebackground=theme["surface_alt"],
                    activeforeground=theme["text"],
                    highlightthickness=0
                )
                cb.pack(anchor="w")
                step_vars["var"] = var
                rec = "Enabled" if step["recommended"] else "Disabled"
                tk.Label(content, text=f"Recommended: {rec}", font=fonts["caption"], fg=theme["muted"], bg=theme["surface"]).pack(anchor="w", pady=self._px((8, 0)))

            elif step["type"] == "path":
                from tkinter import filedialog
                var = tk.StringVar(value=str(wizard_state.get(step["key"], step["recommended"])))
                row = tk.Frame(content, bg=theme["surface"])
                row.pack(fill="x")
                entry = tk.Entry(
                    row,
                    textvariable=var,
                    font=fonts["body"],
                    bg=theme["surface_alt"],
                    fg=theme["text"],
                    relief="flat",
                    bd=0
                )
                entry.pack(side="left", fill="x", expand=True, ipady=self._px(7))
                def browse():
                    new_dir = filedialog.askdirectory(title="Browse", initialdir=var.get() or step["recommended"])
                    if new_dir:
                        var.set(new_dir)
                browse_btn = tk.Button(
                    row,
                    text="Browse...",
                    font=fonts["button"],
                    bg=theme["surface_alt"],
                    fg=theme["text"],
                    activebackground=theme["surface_alt_hover"],
                    activeforeground=theme["text"],
                    relief="flat",
                    bd=0,
                    padx=self._px(8),
                    pady=self._px(2),
                    command=browse
                )
                browse_btn.pack(side="left", padx=self._px((8, 0)))
                self.add_hover_effect(browse_btn, bg_normal=theme["surface_alt"], fg_normal=theme["text"], bg_hover=theme["surface_alt_hover"], fg_hover=theme["accent"])
                step_vars["var"] = var
                tk.Label(content, text=f"Recommended: {step['recommended']}", font=fonts["caption"], fg=theme["muted"], bg=theme["surface"], wraplength=self._px(560), justify="left").pack(anchor="w", pady=self._px((8, 0)))

            elif step["type"] == "int":
                val = wizard_state.get(step["key"], step["recommended"])
                var = tk.StringVar(value=str(val))
                row = tk.Frame(content, bg=theme["surface"])
                row.pack(anchor="w")
                spin = tk.Spinbox(
                    row,
                    from_=step["min"],
                    to=step["max"],
                    textvariable=var,
                    font=fonts["body"],
                    bg=theme["surface_alt"],
                    fg=theme["text"],
                    relief="flat",
                    bd=0,
                    width=6,
                    highlightthickness=1,
                    highlightbackground=theme["border"],
                    highlightcolor=theme["border"]
                )
                spin.pack(side="left")
                step_vars["var"] = var
                tk.Label(content, text=f"Recommended: {step['recommended']}", font=fonts["caption"], fg=theme["muted"], bg=theme["surface"]).pack(anchor="w", pady=self._px((8, 0)))

            elif step["type"] == "choice":
                val = wizard_state.get(step["key"], step["recommended"])
                var = tk.StringVar(value=str(val))
                combo = ttk.Combobox(
                    content,
                    textvariable=var,
                    values=[str(v) for v in step["choices"]],
                    state="readonly",
                    style="WhiteOnBlack.TCombobox"
                )
                combo.pack(anchor="w")
                self._disable_combo_scroll(combo)
                step_vars["var"] = var
                tk.Label(content, text=f"Recommended: {step['recommended']}", font=fonts["caption"], fg=theme["muted"], bg=theme["surface"]).pack(anchor="w", pady=self._px((8, 0)))

            elif step["type"] == "format":
                current_label = format_label_from_value(wizard_state.get("default_format_selection"))
                if not current_label:
                    current_label = "None (select manually)"
                var = tk.StringVar(value=current_label)
                combo = ttk.Combobox(
                    content,
                    textvariable=var,
                    values=step["choices"],
                    state="readonly",
                    style="WhiteOnBlack.TCombobox"
                )
                combo.pack(anchor="w")
                self._disable_combo_scroll(combo)
                step_vars["var"] = var
                tk.Label(content, text="Recommended: None (select manually)", font=fonts["caption"], fg=theme["muted"], bg=theme["surface"]).pack(anchor="w", pady=self._px((8, 0)))

            state["vars"] = step_vars
            is_last = index == len(steps) - 1
            set_nav_buttons(show_back=index > 0, next_label="Finish" if is_last else "Next", show_skip=False)

        def update_state_from_step():
            step = state.get("step")
            vars_map = state.get("vars") or {}
            if not step or step.get("type") == "welcome":
                return
            key = step.get("key")
            if step["type"] == "bool":
                wizard_state[key] = bool(vars_map["var"].get())
            elif step["type"] == "path":
                value = vars_map["var"].get().strip()
                wizard_state[key] = value or step["recommended"]
            elif step["type"] == "int":
                raw = vars_map["var"].get()
                normalize = step.get("normalize")
                wizard_state[key] = normalize(raw) if normalize else raw
            elif step["type"] == "choice":
                try:
                    wizard_state[key] = int(vars_map["var"].get())
                except Exception:
                    wizard_state[key] = step["recommended"]
            elif step["type"] == "format":
                label = vars_map["var"].get()
                if label.startswith("None"):
                    wizard_state[key] = ""
                else:
                    wizard_state[key] = str(label).strip().lower()

        def finish_wizard():
            self.config["download_location"] = wizard_state["download_location"]
            self.config["disable_warnings"] = wizard_state["disable_warnings"]
            self.config["disable_already_downloaded_prompts"] = wizard_state["disable_already_downloaded_prompts"]
            self.config["enable_window_resizing"] = wizard_state["enable_window_resizing"]
            self.config["default_format_selection"] = wizard_state["default_format_selection"]
            self.config["first_launch_complete"] = True
            self.save_config()
            self._window_resizing_enabled = bool(self.config.get("enable_window_resizing", True))
            self.root.resizable(self._window_resizing_enabled, self._window_resizing_enabled)
            if self._window_resizing_enabled:
                self.root.bind("<Configure>", self._on_root_configure)
            try:
                root_frame.destroy()
            except Exception:
                pass
            if on_complete:
                on_complete()

        def go_next():
            update_state_from_step()
            if state["index"] >= len(steps) - 1:
                finish_wizard()
                return
            render_step(state["index"] + 1)

        def go_back():
            update_state_from_step()
            if state["index"] > 0:
                render_step(state["index"] - 1)

        def skip_wizard():
            self.config["first_launch_complete"] = True
            self.save_config()
            try:
                root_frame.destroy()
            except Exception:
                pass
            if on_complete:
                on_complete()

        start_index = max(0, min(int(start_index or 0), len(steps) - 1))
        render_step(start_index)
        def rebuild_current_step():
            update_state_from_step()
            self.show_first_launch_wizard(on_complete, start_index=state["index"], wizard_state=wizard_state)
        self._create_footer(root_frame, rebuild_fn=rebuild_current_step)

    def set_icon(self, prompt_if_missing=True):
        if not self._is_windows():
            return
        script_dir = self._app_dir()
        appdata_dir = self._appdata_dir()
        target_dir = script_dir if self._is_dir_writable(script_dir) else appdata_dir
        icon_path = os.path.join(script_dir, "icon.ico")
        appdata_icon_path = os.path.join(appdata_dir, "icon.ico")
        if not os.path.exists(icon_path) and os.path.exists(appdata_icon_path):
            icon_path = appdata_icon_path
        if os.path.exists(icon_path):
            try:
                self.root.iconbitmap(icon_path)
                self._icon_prompt_pending = False
                return
            except Exception as e:
                logging.error(f"Failed to set application icon: {e}")
        if not os.path.exists(icon_path):
            icon_path = os.path.join(target_dir, "icon.ico")
        if not prompt_if_missing:
            self._icon_prompt_pending = True
            return
        self._icon_prompt_pending = False
        def apply_icon():
            try:
                self.root.iconbitmap(icon_path)
            except Exception as e:
                logging.error(f"Failed to set application icon: {e}")
                messagebox.showerror("Error", "Failed to set the application's icon.")
        if getattr(self, "_icon_prompted", False):
            return
        self._icon_prompted = True
        if messagebox.askyesno("Download Icon", "The application's icon is missing. Would you like to download and install it?"):
            def download_icon():
                try:
                    icon_url = "https://sourceforge.net/p/mediacrate/code/ci/main/tree/MediaCrate/icon.ico?format=raw"
                    logging.info(f"Downloading icon from {icon_url} to {icon_path}")
                    response = requests.get(icon_url, stream=True, timeout=10)
                    response.raise_for_status()
                    os.makedirs(os.path.dirname(icon_path), exist_ok=True)
                    with open(icon_path, "wb") as file:
                        for chunk in response.iter_content(chunk_size=1024):
                            if chunk: file.write(chunk)
                    self.run_on_ui_thread(apply_icon)
                except Exception as e:
                    logging.error(f"Failed to download or set application icon: {e}")
                    self.run_on_ui_thread(messagebox.showerror, "Error", "Failed to download or set the application's icon.")
            threading.Thread(target=download_icon, daemon=True).start()

    def check_ffmpeg(self):
        ffmpeg_name = "ffmpeg.exe" if self._is_windows() else "ffmpeg"
        ffmpeg_in_path = self.is_ffmpeg_installed()
        if not ffmpeg_in_path:
            self._after(0, lambda: self.prompt_ffmpeg_download(callback=getattr(self, '_ffmpeg_callback', None)))
        else:
            if hasattr(self, '_ffmpeg_callback') and self._ffmpeg_callback:
                self._after(0, self._ffmpeg_callback)

    def check_nodejs(self):
        node_name = "node.exe" if self._is_windows() else "node"
        node_in_script_dir = os.path.exists(os.path.join(self._app_dir(), node_name))
        node_in_appdata = os.path.exists(os.path.join(self._appdata_dir(), node_name))
        node_in_path = shutil.which("node") is not None
        if not node_in_script_dir and not node_in_appdata and not node_in_path:
            self._after(0, lambda: self.prompt_nodejs_download(callback=getattr(self, '_nodejs_callback', None)))
        else:
            if hasattr(self, '_nodejs_callback') and self._nodejs_callback:
                self._after(0, self._nodejs_callback)

    def is_ffmpeg_installed(self):
        ffmpeg_name = "ffmpeg.exe" if self._is_windows() else "ffmpeg"
        for base_dir in (self._app_dir(), self._appdata_dir()):
            ffmpeg_path = os.path.join(base_dir, ffmpeg_name)
            if os.path.isfile(ffmpeg_path):
                return True
        return shutil.which("ffmpeg") is not None

    def prompt_ffmpeg_download(self, callback=None):
        def _theme_snapshot():
            theme = self.theme
            fonts = self.fonts
            bg_main = theme["bg"]
            fg_label = theme["text"]
            bg_button = theme["surface_alt"]
            fg_button = theme["text"]
            active_bg_button = theme["surface_alt_hover"]
            active_fg_button = theme["text"]
            return theme, fonts, bg_main, fg_label, bg_button, fg_button, active_bg_button, active_fg_button

        status_var = self._ffmpeg_status_var
        if not isinstance(status_var, tk.StringVar):
            status_var = tk.StringVar(value="")
        elif not self._ffmpeg_download_active:
            status_var.set("")
        self._ffmpeg_status_var = status_var
        script_dir = self._app_dir()
        appdata_dir = self._appdata_dir()
        target_dir = script_dir if self._is_dir_writable(script_dir) else appdata_dir
        install_path = target_dir


        if not self._is_windows():
            theme, fonts, bg_main, fg_label, bg_button, fg_button, active_bg_button, active_fg_button = _theme_snapshot()
            for widget in self.root.winfo_children():
                widget.destroy()
            message = (
                "FFmpeg is required for this application to function.\n\n"
                "Please install FFmpeg using your package manager:\n"
                "macOS: brew install ffmpeg\n"
                "Linux: sudo apt install ffmpeg\n\n"
                "You can also download it from the official site."
            )
            tk.Label(self.root, text=message, bg=bg_main, fg=fg_label, wraplength=420, justify="left", font=fonts["body"]).pack(pady=10)
            link = tk.Label(
                self.root,
                text="https://ffmpeg.org/download.html",
                bg=bg_main,
                fg=theme["accent"],
                cursor="hand2",
                wraplength=420,
                justify="center",
                anchor="center",
                font=(fonts["caption"][0], fonts["caption"][1], "underline")
            )
            link.pack(pady=5)
            link.bind("<Button-1>", lambda e: self.open_url("https://ffmpeg.org/download.html"))
            button_frame = tk.Frame(self.root, bg=bg_main)
            button_frame.pack(pady=10)
            continue_button = tk.Button(
                button_frame, text="Continue", command=lambda: self.clear_ffmpeg_prompt(callback),
                font=fonts["button"], bg=bg_button, fg=fg_button,
                activebackground=active_bg_button, activeforeground=active_fg_button,
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            continue_button.pack(side=tk.LEFT, padx=5)
            self.add_hover_effect(continue_button, bg_normal=bg_button, fg_normal=fg_button, bg_hover=active_bg_button, fg_hover=active_fg_button)
            exit_button = tk.Button(
                button_frame, text="Exit", command=self.abort,
                font=fonts["button"], bg=theme["danger"], fg=theme["bg"],
                activebackground=theme["danger_hover"], activeforeground=theme["bg"],
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            exit_button.pack(side=tk.LEFT, padx=5)
            self.add_hover_effect(exit_button, bg_normal=theme["danger"], fg_normal=theme["bg"], bg_hover=theme["danger_hover"], fg_hover=theme["bg"])
            self._create_footer(self.root, rebuild_fn=lambda: self.prompt_ffmpeg_download(callback))
            return

        def on_confirm():
            if messagebox.askyesno(
                "FFmpeg Not Installed",
                "If you don't install FFmpeg, there's a high chance the application won't work.\n\nAre you sure you want to continue without installing FFmpeg?"
            ):
                self.clear_ffmpeg_prompt(callback)
            else:
                self.prompt_ffmpeg_download(callback)

        def set_buttons_state(state):
            buttons = getattr(self, "_ffmpeg_prompt_buttons", None) or ()
            for btn in buttons:
                if btn and btn.winfo_exists():
                    btn.config(state=state)

        def on_download_choice():
            theme, fonts, bg_main, fg_label, bg_button, fg_button, active_bg_button, active_fg_button = _theme_snapshot()
            for widget in self.root.winfo_children():
                widget.destroy()

            tk.Label(
                self.root,
                text="Choose how to download FFmpeg:",
                bg=bg_main,
                fg=fg_label,
                wraplength=420,
                font=fonts["subtitle"],
                justify="center"
            ).pack(pady=10)

            tk.Label(
                self.root,
                text="Automatic (Recommended): The application will download and install FFmpeg after you are introduced to the legal disclaimer.\n\n"
                     "Manual: Follow the steps to download and install FFmpeg yourself.",
                bg=bg_main,
                fg=fg_label,
                wraplength=420,
                justify="left",
                font=fonts["body"]
            ).pack(pady=10)

            button_frame = tk.Frame(self.root, bg=bg_main)
            button_frame.pack(pady=10)

            auto_button = tk.Button(
                button_frame, text="Automatic", command=show_legal_disclaimer,
                font=fonts["button"],
                bg=bg_button, fg=fg_button,
                activebackground=active_bg_button, activeforeground=active_fg_button,
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            auto_button.pack(side=tk.LEFT, padx=5)
            self.add_hover_effect(auto_button, bg_normal=bg_button, fg_normal=fg_button, bg_hover=active_bg_button, fg_hover=active_fg_button)
            manual_button = tk.Button(
                button_frame, text="Manual", command=show_manual_steps,
                font=fonts["button"],
                bg=bg_button, fg=fg_button,
                activebackground=active_bg_button, activeforeground=active_fg_button,
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            manual_button.pack(side=tk.LEFT, padx=5)
            self.add_hover_effect(manual_button, bg_normal=bg_button, fg_normal=fg_button, bg_hover=active_bg_button, fg_hover=active_fg_button)
            self._create_footer(self.root, rebuild_fn=on_download_choice)

        def show_legal_disclaimer():
            theme, fonts, bg_main, fg_label, bg_button, fg_button, active_bg_button, active_fg_button = _theme_snapshot()
            for widget in self.root.winfo_children():
                widget.destroy()

            tk.Label(
                self.root,
                text="Legal Disclaimer:",
                bg=bg_main,
                fg=fg_label,
                font=fonts["subtitle"],
                justify="center"
            ).pack(pady=10)

            tk.Label(
                self.root,
                text="By proceeding, you acknowledge that FFmpeg is a third-party software.\n\n"
                     "The application will download FFmpeg from an official Windows build.\n\n"
                     "FFmpeg is licensed under the GNU Lesser General Public License (LGPL) version 2.1 or later.\n"
                     "For more details, visit:",
                bg=bg_main,
                fg=fg_label,
                wraplength=420,
                justify="left",
                font=fonts["body"]
            ).pack(pady=0)
            link = tk.Label(
                self.root,
                text="https://ffmpeg.org/legal.html",
                bg=bg_main,
                fg=theme["accent"],
                cursor="hand2",
                wraplength=360,
                justify="center",
                anchor="center",
                font=(fonts["caption"][0], fonts["caption"][1], "underline")
            )
            link.pack(pady=5)
            link.bind("<Button-1>", lambda e: self.open_url("https://ffmpeg.org/legal.html"))

            button_frame = tk.Frame(self.root, bg=bg_main)
            button_frame.pack(pady=10)

            self.proceed_button = tk.Button(
                button_frame, text="Proceed", command=lambda: [self.proceed_button.config(state=tk.DISABLED), on_download()],
                font=fonts["button"],
                bg=bg_button, fg=fg_button,
                activebackground=active_bg_button, activeforeground=active_fg_button,
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            self.proceed_button.pack(side=tk.LEFT, padx=5)
            self.add_hover_effect(self.proceed_button, bg_normal=bg_button, fg_normal=fg_button, bg_hover=active_bg_button, fg_hover=active_fg_button)
            cancel_button = tk.Button(
                button_frame, text="Cancel", command=on_confirm,
                font=fonts["button"],
                bg=theme["danger"], fg=theme["bg"],
                activebackground=theme["danger_hover"], activeforeground=theme["bg"],
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            cancel_button.pack(side=tk.LEFT, padx=5)
            self.add_hover_effect(cancel_button, bg_normal=theme["danger"], fg_normal=theme["bg"], bg_hover=theme["danger_hover"], fg_hover=theme["bg"])
            status_label = tk.Label(self.root, textvariable=status_var, bg=bg_main, fg=theme["muted"], wraplength=420, justify="left", font=fonts["caption"])
            status_label.pack(pady=(4, 0))
            self._ffmpeg_prompt_buttons = (self.proceed_button, cancel_button)
            if self._ffmpeg_download_active:
                set_buttons_state(tk.DISABLED)
            self._create_footer(self.root, rebuild_fn=show_legal_disclaimer)

        def show_manual_steps():
            theme, fonts, bg_main, fg_label, bg_button, fg_button, active_bg_button, active_fg_button = _theme_snapshot()
            for widget in self.root.winfo_children():
                widget.destroy()

            tk.Label(
                self.root,
                text="Manual Download Steps:",
                bg=bg_main,
                fg=fg_label,
                font=fonts["subtitle"],
                justify="center"
            ).pack(pady=10)

            tk.Label(
                self.root,
                text="1. Visit the official FFmpeg build page:",
                bg=bg_main,
                fg=fg_label,
                wraplength=420,
                justify="center",
                font=fonts["body"]
            ).pack(pady=0)

            link = tk.Label(
                self.root,
                text="https://github.com/GyanD/codexffmpeg/releases/latest",
                bg=bg_main,
                fg=theme["accent"],
                cursor="hand2",
                wraplength=420,
                justify="center",
                anchor="center",
                font=(fonts["caption"][0], fonts["caption"][1], "underline")
            )
            link.pack(pady=0)
            link.bind("<Button-1>", lambda e: self.open_url("https://github.com/GyanD/codexffmpeg/releases/latest"))

            tk.Label(
                self.root,
                text="2. Download the file named 'ffmpeg-x.x.x-essentials_build.zip'.\n"
                     "3. Extract the downloaded ZIP file.\n"
                     "4. Locate the 'ffmpeg.exe' file within the extracted folder and its subfolders.\n"
                     f"5. Move the 'ffmpeg.exe' file to:\n{install_path}",
                bg=bg_main,
                fg=fg_label,
                wraplength=420,
                justify="left",
                font=fonts["body"]
            ).pack(pady=5)

            tk.Label(
                self.root,
                text="Once you have completed these steps, restart the application.",
                bg=bg_main,
                fg=fg_label,
                wraplength=420,
                justify="left",
                font=fonts["caption"]
            ).pack(pady=10)

            ok_button = tk.Button(
                self.root, text="OK", command=self.terminate_program,
                font=fonts["button"],
                bg=bg_button, fg=fg_button,
                activebackground=active_bg_button, activeforeground=active_fg_button,
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            ok_button.pack(pady=10)
            self.add_hover_effect(ok_button, bg_normal=bg_button, fg_normal=fg_button, bg_hover=active_bg_button, fg_hover=active_fg_button)
            self._create_footer(self.root, rebuild_fn=show_manual_steps)

        def on_download():
            def download_ffmpeg():
                try:
                    if self._ffmpeg_download_active:
                        return
                    self._ffmpeg_download_active = True
                    self.run_on_ui_thread(set_buttons_state, tk.DISABLED)
                    self.set_status("Downloading FFmpeg... (DO NOT CLOSE APPLICATION)")
                    download_url = "https://github.com/GyanD/codexffmpeg/releases/download/2026-01-14-git-6c878f8b82/ffmpeg-2026-01-14-git-6c878f8b82-essentials_build.zip"
                    download_path = os.path.join(target_dir, "ffmpeg-essentials.zip")
                    extract_path = os.path.join(target_dir, "ffmpeg_temp")

                    logging.info(f"Downloading FFmpeg from {download_url} to {download_path}")
                    response = requests.get(download_url, stream=True, timeout=180)
                    response.raise_for_status()
                    total = int(response.headers.get('content-length') or 0)
                    downloaded = 0
                    with open(download_path, "wb") as file:
                        for chunk in response.iter_content(chunk_size=1024):
                            if chunk:
                                file.write(chunk)
                                downloaded += len(chunk)
                                if total:
                                    percent = int(downloaded * 100 / total)
                                    mb_done = downloaded / (1024 * 1024)
                                    mb_total = total / (1024 * 1024)
                                    self._set_text_var(self._ffmpeg_status_var, f"Downloading FFmpeg... {percent}% ({mb_done:.1f}/{mb_total:.1f} MB)")
                                else:
                                    mb_done = downloaded / (1024 * 1024)
                                    self._set_text_var(self._ffmpeg_status_var, f"Downloading FFmpeg... {mb_done:.1f} MB")

                    self.set_status("Extracting FFmpeg...")
                    self._set_text_var(self._ffmpeg_status_var, "Extracting FFmpeg...")
                    logging.info(f"Extracting FFmpeg to {extract_path}")
                    os.makedirs(extract_path, exist_ok=True)
                    with zipfile.ZipFile(download_path, 'r') as zip_ref:
                        zip_ref.extractall(extract_path)

                    bin_folder = next(
                        (os.path.join(root, "ffmpeg.exe") for root, _, files in os.walk(extract_path) if "ffmpeg.exe" in files),
                        None
                    )
                    if bin_folder:
                        shutil.copy(bin_folder, target_dir)
                        logging.info(f"Copied ffmpeg.exe to {target_dir}")
                    else:
                        raise FileNotFoundError("ffmpeg.exe not found in the downloaded archive.")

                    os.remove(download_path)
                    shutil.rmtree(extract_path)

                    self.set_status("FFmpeg installed successfully!")
                    self._set_text_var(self._ffmpeg_status_var, "FFmpeg installed successfully.")
                    self._ffmpeg_download_active = False
                    def finish_install():
                        messagebox.showinfo("Success", "FFmpeg has been installed successfully. The app will now restart.")
                        self.restart_program()
                    self.run_on_ui_thread(finish_install)
                except requests.exceptions.Timeout:
                    self.set_status("FFmpeg download timed out.")
                    self._set_text_var(self._ffmpeg_status_var, "FFmpeg download timed out.")
                    self._ffmpeg_download_active = False
                    self.run_on_ui_thread(set_buttons_state, tk.NORMAL)
                    self.run_on_ui_thread(messagebox.showerror, "Error", "FFmpeg download timed out. Please check your connection or download it manually.")
                except requests.exceptions.RequestException as e:
                    self.set_status("FFmpeg download failed.")
                    self._set_text_var(self._ffmpeg_status_var, "FFmpeg download failed.")
                    self._ffmpeg_download_active = False
                    self.run_on_ui_thread(set_buttons_state, tk.NORMAL)
                    self.run_on_ui_thread(messagebox.showerror, "Error", f"FFmpeg download failed: {e}")
                except Exception as e:
                    self.set_status("FFmpeg installation failed.")
                    self._set_text_var(self._ffmpeg_status_var, "FFmpeg installation failed.")
                    self._ffmpeg_download_active = False
                    self.run_on_ui_thread(set_buttons_state, tk.NORMAL)
                    self.run_on_ui_thread(messagebox.showerror, "Error", f"Failed to download and install FFmpeg: {e}")
            threading.Thread(target=download_ffmpeg, daemon=True).start()

        for widget in self.root.winfo_children():
            widget.destroy()
        theme, fonts, bg_main, fg_label, bg_button, fg_button, active_bg_button, active_fg_button = _theme_snapshot()
        message = (
            "The FFmpeg framework, which is essential for this application to function, is missing from your system.\n\n"
            "Without this dependency, the application will not work.\n\n"
            f"FFmpeg will be installed to:\n{install_path}\n\n"
            "Would you like to download and install FFmpeg now?"
        )
        tk.Label(self.root, text=message, bg=bg_main, fg=fg_label, wraplength=420, justify="left", font=fonts["body"]).pack(pady=10)

        button_frame = tk.Frame(self.root, bg=bg_main)
        button_frame.pack(pady=10)

        proceed_button = tk.Button(button_frame, text="Yes", command=on_download_choice, font=fonts["button"], bg=bg_button, fg=fg_button, activebackground=active_bg_button, activeforeground=active_fg_button, relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2")
        proceed_button.pack(side=tk.LEFT, padx=5)
        self.add_hover_effect(proceed_button, bg_normal=bg_button, fg_normal=fg_button, bg_hover=active_bg_button, fg_hover=active_fg_button)
        confirm_button = tk.Button(button_frame, text="Cancel", command=on_confirm, font=fonts["button"], bg=theme["danger"], fg=theme["bg"], activebackground=theme["danger_hover"], activeforeground=theme["bg"], relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2")
        confirm_button.pack(side=tk.LEFT, padx=5)
        self.add_hover_effect(confirm_button, bg_normal=theme["danger"], fg_normal=theme["bg"], bg_hover=theme["danger_hover"], fg_hover=theme["bg"])
        self._ffmpeg_prompt_buttons = (proceed_button, confirm_button)
        if self._ffmpeg_download_active:
            set_buttons_state(tk.DISABLED)
        self._create_footer(self.root, rebuild_fn=lambda: self.prompt_ffmpeg_download(callback))

    def clear_ffmpeg_prompt(self, callback=None):
        for widget in self.root.winfo_children():
            widget.destroy()
        self._ffmpeg_download_active = False
        self._ffmpeg_prompt_buttons = None
        self._ffmpeg_status_var = None
        self.show_splash()
        if callback:
            callback()

    def prompt_nodejs_download(self, callback=None):
        theme = self.theme
        fonts = self.fonts
        bg_main = theme["bg"]
        fg_label = theme["text"]
        bg_button = theme["surface_alt"]
        fg_button = theme["text"]
        active_bg_button = theme["surface_alt_hover"]
        active_fg_button = theme["text"]
        status_var = self._nodejs_status_var
        if not isinstance(status_var, tk.StringVar):
            status_var = tk.StringVar(value="")
        elif not self._nodejs_download_active:
            status_var.set("")
        self._nodejs_status_var = status_var
        script_dir = self._app_dir()
        appdata_dir = self._appdata_dir()
        target_dir = script_dir if self._is_dir_writable(script_dir) else appdata_dir
        install_path = target_dir


        if not self._is_windows():
            for widget in self.root.winfo_children():
                widget.destroy()
            message = (
                "A JavaScript runtime (Node.js) is essential for reliable extraction and other features.\n"
                "Without it, some formats may be missing.\n\n"
                "Please install Node.js using your package manager:\n"
                "macOS: brew install node\n"
                "Linux: sudo apt install nodejs\n\n"
                "You can also download it from the official site."
            )
            tk.Label(self.root, text=message, bg=bg_main, fg=fg_label, wraplength=420, justify="left", font=fonts["body"]).pack(pady=10)
            link = tk.Label(
                self.root,
                text="https://nodejs.org/en/download",
                bg=bg_main,
                fg=theme["accent"],
                cursor="hand2",
                wraplength=420,
                justify="center",
                anchor="center",
                font=(fonts["caption"][0], fonts["caption"][1], "underline")
            )
            link.pack(pady=5)
            link.bind("<Button-1>", lambda e: self.open_url("https://nodejs.org/en/download"))
            button_frame = tk.Frame(self.root, bg=bg_main)
            button_frame.pack(pady=10)
            continue_button = tk.Button(
                button_frame, text="Continue", command=lambda: self.clear_nodejs_prompt(callback),
                font=fonts["button"], bg=bg_button, fg=fg_button,
                activebackground=active_bg_button, activeforeground=active_fg_button,
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            continue_button.pack(side=tk.LEFT, padx=5)
            self.add_hover_effect(continue_button, bg_normal=bg_button, fg_normal=fg_button, bg_hover=active_bg_button, fg_hover=active_fg_button)
            exit_button = tk.Button(
                button_frame, text="Exit", command=self.abort,
                font=fonts["button"], bg=theme["danger"], fg=theme["bg"],
                activebackground=theme["danger_hover"], activeforeground=theme["bg"],
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            exit_button.pack(side=tk.LEFT, padx=5)
            self.add_hover_effect(exit_button, bg_normal=theme["danger"], fg_normal=theme["bg"], bg_hover=theme["danger_hover"], fg_hover=theme["bg"])
            self._create_footer(self.root, rebuild_fn=lambda: self.prompt_nodejs_download(callback))
            return

        def on_confirm():
            if messagebox.askyesno(
                "Node.js Not Installed",
                "A JavaScript runtime (Node.js) is essential for reliable extraction and some formats may be missing without it.\n\nAre you sure you want to continue without installing Node.js?"
            ):
                self.clear_nodejs_prompt(callback)
            else:
                self.prompt_nodejs_download(callback)

        def set_buttons_state(state):
            buttons = getattr(self, "_nodejs_prompt_buttons", None) or ()
            for btn in buttons:
                if btn and btn.winfo_exists():
                    btn.config(state=state)

        def on_download():
            if self._nodejs_download_active:
                return
            self._nodejs_download_active = True
            set_buttons_state(tk.DISABLED)
            def download_nodejs():
                try:
                    self.set_status("Downloading Node.js... (DO NOT CLOSE APPLICATION)")
                    download_url = "https://nodejs.org/dist/v24.13.0/node-v24.13.0-win-x64.zip"
                    download_path = os.path.join(target_dir, "nodejs.zip")
                    extract_path = os.path.join(target_dir, "nodejs_temp")

                    logging.info(f"Downloading Node.js from {download_url} to {download_path}")
                    response = requests.get(download_url, stream=True, timeout=180)
                    response.raise_for_status()
                    total = int(response.headers.get('content-length') or 0)
                    downloaded = 0
                    with open(download_path, "wb") as file:
                        for chunk in response.iter_content(chunk_size=1024):
                            if chunk:
                                file.write(chunk)
                                downloaded += len(chunk)
                                if total:
                                    percent = int(downloaded * 100 / total)
                                    mb_done = downloaded / (1024 * 1024)
                                    mb_total = total / (1024 * 1024)
                                    self._set_text_var(self._nodejs_status_var, f"Downloading Node.js... {percent}% ({mb_done:.1f}/{mb_total:.1f} MB)")
                                else:
                                    mb_done = downloaded / (1024 * 1024)
                                    self._set_text_var(self._nodejs_status_var, f"Downloading Node.js... {mb_done:.1f} MB")

                    self.set_status("Extracting Node.js...")
                    self._set_text_var(self._nodejs_status_var, "Extracting Node.js...")
                    logging.info(f"Extracting Node.js to {extract_path}")
                    os.makedirs(extract_path, exist_ok=True)
                    with zipfile.ZipFile(download_path, 'r') as zip_ref:
                        zip_ref.extractall(extract_path)

                    node_binary = next(
                        (os.path.join(root, "node.exe") for root, _, files in os.walk(extract_path) if "node.exe" in files),
                        None
                    )
                    if node_binary:
                        shutil.copy(node_binary, target_dir)
                        logging.info(f"Copied node.exe to {target_dir}")
                    else:
                        raise FileNotFoundError("node.exe not found in the downloaded archive.")

                    os.remove(download_path)
                    shutil.rmtree(extract_path)

                    self.set_status("Node.js installed successfully!")
                    self._set_text_var(self._nodejs_status_var, "Node.js installed successfully.")
                    self._nodejs_download_active = False
                    def finish_install():
                        messagebox.showinfo("Success", "Node.js has been installed successfully.")
                        self.clear_nodejs_prompt(callback)
                    self.run_on_ui_thread(finish_install)
                except requests.exceptions.Timeout:
                    self.set_status("Node.js download timed out.")
                    self._set_text_var(self._nodejs_status_var, "Node.js download timed out.")
                    self._nodejs_download_active = False
                    self.run_on_ui_thread(set_buttons_state, tk.NORMAL)
                    self.run_on_ui_thread(messagebox.showerror, "Error", "Node.js download timed out. Please check your connection or download it manually.")
                except requests.exceptions.RequestException as e:
                    self.set_status("Node.js download failed.")
                    self._set_text_var(self._nodejs_status_var, "Node.js download failed.")
                    self._nodejs_download_active = False
                    self.run_on_ui_thread(set_buttons_state, tk.NORMAL)
                    self.run_on_ui_thread(messagebox.showerror, "Error", f"Node.js download failed: {e}")
                except Exception as e:
                    self.set_status("Node.js installation failed.")
                    self._set_text_var(self._nodejs_status_var, "Node.js installation failed.")
                    self._nodejs_download_active = False
                    self.run_on_ui_thread(set_buttons_state, tk.NORMAL)
                    self.run_on_ui_thread(messagebox.showerror, "Error", f"Failed to download and install Node.js: {e}")
            threading.Thread(target=download_nodejs, daemon=True).start()

        for widget in self.root.winfo_children():
            widget.destroy()
        message = (
            "A JavaScript runtime (Node.js) is essential for reliable extraction and other features.\n"
            "Without it, some formats may be missing.\n\n"
            f"Node.js will be installed to:\n{install_path}\n\n"
            "Would you like to download and install Node.js now?"
        )
        tk.Label(self.root, text=message, bg=bg_main, fg=fg_label, wraplength=420, justify="left", font=fonts["body"]).pack(pady=10)

        button_frame = tk.Frame(self.root, bg=bg_main)
        button_frame.pack(pady=10)

        proceed_button = tk.Button(button_frame, text="Yes", command=on_download, font=fonts["button"], bg=bg_button, fg=fg_button, activebackground=active_bg_button, activeforeground=active_fg_button, relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2")
        proceed_button.pack(side=tk.LEFT, padx=5)
        self.add_hover_effect(proceed_button, bg_normal=bg_button, fg_normal=fg_button, bg_hover=active_bg_button, fg_hover=active_fg_button)
        confirm_button = tk.Button(button_frame, text="Cancel", command=on_confirm, font=fonts["button"], bg=theme["danger"], fg=theme["bg"], activebackground=theme["danger_hover"], activeforeground=theme["bg"], relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2")
        confirm_button.pack(side=tk.LEFT, padx=5)
        self.add_hover_effect(confirm_button, bg_normal=theme["danger"], fg_normal=theme["bg"], bg_hover=theme["danger_hover"], fg_hover=theme["bg"])
        self._nodejs_prompt_buttons = (proceed_button, confirm_button)
        if self._nodejs_download_active:
            set_buttons_state(tk.DISABLED)
        status_label = tk.Label(self.root, textvariable=status_var, bg=bg_main, fg=theme["muted"], wraplength=420, justify="left", font=fonts["caption"])
        status_label.pack(pady=(4, 0))
        self._create_footer(self.root, rebuild_fn=lambda: self.prompt_nodejs_download(callback))

    def clear_nodejs_prompt(self, callback=None):
        for widget in self.root.winfo_children():
            widget.destroy()
        self._nodejs_download_active = False
        self._nodejs_prompt_buttons = None
        self._nodejs_status_var = None
        self.show_splash()
        if callback:
            callback()

    def create_widgets(self, force_rebuild=True, switch_view=True):
        self._clear_footer()
        if switch_view:
            self._begin_transition()
        self._ensure_view_container()
        if not force_rebuild and getattr(self, "_main_built", False):
            is_batch = self.config.get('allow_batch_downloads', False)
            self._apply_window_constraints(min_extra=self._batch_min_extra if is_batch else 0)
            if switch_view:
                self._show_view("main")
                self._after(0, self._fade_in)
            return

        saved_url_entry = None
        saved_url_text = None
        if getattr(self, "url_entry", None) and self.url_entry.winfo_exists():
            saved_url_entry = self.url_entry.get()
        if getattr(self, "url_text", None) and self.url_text.winfo_exists():
            saved_url_text = self.url_text.get("1.0", tk.END).rstrip("\n")
        prev_format = self.selected_format.get() if getattr(self, "selected_format", None) else None
        prev_quality = self.selected_quality.get() if getattr(self, "selected_quality", None) else None

        for widget in self.main_view.winfo_children():
            widget.destroy()

        theme = self.theme
        fonts = self.fonts
        is_batch = self.config.get('allow_batch_downloads', False)
        self.configure_styles()
        self.configure_geometry(prefer_tall=is_batch)
        if not is_batch and self._batch_wheel_bound:
            self.root.unbind_all("<MouseWheel>")
            self.root.unbind_all("<Button-4>")
            self.root.unbind_all("<Button-5>")
            self._batch_wheel_bound = False

        outer = tk.Frame(self.main_view, bg=theme["bg"])
        outer.pack(fill="both", expand=True)
        outer.grid_columnconfigure(0, weight=1)
        outer.grid_rowconfigure(2, weight=1)

        header = tk.Frame(outer, bg=theme["bg"], padx=self._px(24), pady=self._px(10))
        header.grid(row=0, column=0, sticky="ew", pady=self._px((18, 0)))
        title = tk.Label(header, text="MediaCrate", font=fonts["title"], fg=theme["text"], bg=theme["bg"])
        subtitle_text = "Download video or audio from any media URL."
        if is_batch:
            subtitle_text = "Download multiple media URLs in one batch."
        subtitle = tk.Label(header, text=subtitle_text, font=fonts["subtitle"], fg=theme["muted"], bg=theme["bg"])
        title.pack(anchor="w")
        subtitle.pack(anchor="w", pady=self._px((4, 0)))

        separator = ttk.Separator(outer, orient="horizontal")
        separator.grid(row=1, column=0, sticky="ew", padx=self._px(24))

        self.main_frame = tk.Frame(outer, bg=theme["bg"], padx=self._px(24), pady=self._px(12))
        self.main_frame.grid(row=2, column=0, sticky="nsew")
        self.main_frame.grid_columnconfigure(0, weight=1, uniform="content")
        self.main_frame.grid_columnconfigure(1, weight=1, uniform="content")
        if is_batch:
            self.main_frame.grid_rowconfigure(0, weight=1, minsize=self._px(360))
            self.main_frame.grid_rowconfigure(4, weight=0, minsize=self._px(120))
        else:
            self.main_frame.grid_rowconfigure(4, weight=1, minsize=self._px(120))

        url_card = tk.Frame(
            self.main_frame,
            bg=theme["surface"],
            highlightthickness=1,
            highlightbackground=theme["border"],
            highlightcolor=theme["border"],
        )
        url_card_sticky = "nsew" if is_batch else "ew"
        url_card.grid(row=0, column=0, columnspan=2, sticky=url_card_sticky, pady=self._px((0, 12)))
        url_card.grid_columnconfigure(0, weight=1)
        url_card.grid_rowconfigure(0, weight=1)
        self.url_card = url_card

        url_left = tk.Frame(url_card, bg=theme["surface"])
        url_left.grid(row=0, column=0, sticky="nsew", padx=self._px(16), pady=self._px(14))
        url_title = "Media URLs" if is_batch else "Media URL"
        tk.Label(url_left, text=url_title, font=fonts["label"], fg=theme["muted"], bg=theme["surface"]).pack(anchor="w")

        if is_batch:
            url_text_frame = tk.Frame(
                url_left,
                bg=theme["surface_alt"],
                highlightthickness=self._px(1),
                highlightbackground=theme["border"],
                highlightcolor=theme["border"],
            )
            url_text_frame.pack(fill=tk.BOTH, expand=True, pady=self._px((6, 0)))
            url_text_frame.configure(height=self._px(360))
            url_text_frame.pack_propagate(False)
            url_text_frame.grid_columnconfigure(0, weight=1)
            url_text_frame.grid_rowconfigure(0, weight=1)
            text_row = tk.Frame(url_text_frame, bg=theme["surface_alt"])
            text_row.grid(row=0, column=0, sticky="nsew", padx=self._px(3), pady=self._px((6, 0)))
            self.url_text_frame = url_text_frame
            self.batch_line_numbers = tk.Text(
                text_row,
                font=fonts["body"],
                bg=theme["surface_alt"],
                fg=theme["muted"],
                relief="flat",
                bd=0,
                width=3,
                wrap="none",
                highlightthickness=0,
                state="disabled",
                takefocus=0
            )
            self.batch_line_numbers.pack(side=tk.LEFT, fill=tk.Y)
            self.batch_line_numbers.bind("<Button-1>", lambda e: "break")
            self.batch_line_numbers.bind("<Key>", lambda e: "break")
            self.url_text = tk.Text(
                text_row,
                font=fonts["body"],
                bg=theme["surface_alt"],
                fg=theme["text"],
                insertbackground=theme["text"],
                selectbackground=theme["accent"],
                selectforeground=theme["bg"],
                relief="flat",
                bd=0,
                height=4,
                wrap="none",
                highlightthickness=0,
                undo=True,
                autoseparators=True,
                maxundo=50,
            )
            self.url_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            text_seed = saved_url_text
            if not text_seed:
                text_seed = self._batch_saved_links or ""
            if text_seed:
                self.url_text.insert("1.0", text_seed)
            self._apply_batch_text_limits()
            def update_line_numbers():
                if not self.url_text.winfo_exists():
                    return
                line_count = int(self.url_text.index("end-1c").split(".")[0])
                lines = "\n".join(f"{i}." for i in range(1, line_count + 1))
                self.batch_line_numbers.config(state="normal")
                self.batch_line_numbers.delete("1.0", tk.END)
                self.batch_line_numbers.insert("1.0", lines)
                self.batch_line_numbers.config(state="disabled")
                first, _ = self.url_text.yview()
                self.batch_line_numbers.yview_moveto(first)
            def sync_line_numbers(first, last):
                try:
                    self.batch_line_numbers.yview_moveto(first)
                except Exception:
                    pass
            self.url_text.config(yscrollcommand=sync_line_numbers)
            def on_shift_mousewheel(event):
                if event.delta:
                    self.url_text.xview_scroll(int(-1*(event.delta/120)), "units")
                elif event.num == 5:
                    self.url_text.xview_scroll(1, "units")
                elif event.num == 4:
                    self.url_text.xview_scroll(-1, "units")
                return "break"
            def on_mousewheel(event):
                if event.state & 0x1:
                    return "break"
                if event.delta:
                    self.url_text.yview_scroll(int(-1*(event.delta/120)), "units")
                elif event.num == 5:
                    self.url_text.yview_scroll(1, "units")
                elif event.num == 4:
                    self.url_text.yview_scroll(-1, "units")
                return "break"
            self.url_text.bind("<MouseWheel>", on_mousewheel)
            self.url_text.bind("<Button-4>", on_mousewheel)
            self.url_text.bind("<Button-5>", on_mousewheel)
            self.batch_line_numbers.bind("<MouseWheel>", on_mousewheel)
            self.batch_line_numbers.bind("<Button-4>", on_mousewheel)
            self.batch_line_numbers.bind("<Button-5>", on_mousewheel)
            self.url_text.bind("<Shift-MouseWheel>", on_shift_mousewheel)
            self.url_text.bind("<Shift-Button-4>", on_shift_mousewheel)
            self.url_text.bind("<Shift-Button-5>", on_shift_mousewheel)
            self.batch_line_numbers.bind("<Shift-MouseWheel>", on_shift_mousewheel)
            self.batch_line_numbers.bind("<Shift-Button-4>", on_shift_mousewheel)
            self.batch_line_numbers.bind("<Shift-Button-5>", on_shift_mousewheel)
            def on_text_modified(event):
                self.url_text.edit_modified(False)
                self._apply_batch_text_limits()
                self.url_text.edit_modified(False)
                update_line_numbers()
            self.url_text.bind("<<Modified>>", on_text_modified)
            self._after(0, update_line_numbers)
            self.paste_button = None
            self.batch_progress_frame = None

            def batch_paste_handler(event):
                try:
                    clipboard = self.root.clipboard_get()
                except tk.TclError:
                    return "break"

                try:
                    yview = self.url_text.yview()
                    xview = self.url_text.xview()
                    insert_pos = self.url_text.index("insert")
                except Exception:
                    yview = None
                    xview = None
                    insert_pos = None

                try:
                    self.url_text.edit_separator()
                except Exception:
                    pass

                max_lines = self._normalize_batch_line_limit(self.config.get('max_batch_lines'))
                disable_limits = self.config.get('disable_char_limits', False)

                existing = [line for line in self.url_text.get("1.0", "end-1c").splitlines() if line.strip()]
                for line in clipboard.splitlines():
                    line = line.strip()
                    if not line:
                        continue
                    if not disable_limits:
                        line = line[:256]
                    if len(existing) >= max_lines:
                        break
                    existing.append(line)

                self.url_text.delete("1.0", tk.END)
                if existing:
                    self.url_text.insert("1.0", "\n".join(existing))

                try:
                    if yview is not None:
                        self.url_text.yview_moveto(yview[0])
                    if xview is not None:
                        self.url_text.xview_moveto(xview[0])
                    if insert_pos is not None:
                        self.url_text.mark_set("insert", insert_pos)
                except Exception:
                    pass

                try:
                    self.url_text.edit_separator()
                except Exception:
                    pass

                self._apply_batch_text_limits()
                update_line_numbers()
                return "break"

            self.url_text.bind("<Control-v>", batch_paste_handler)
            self.url_text.bind("<Control-V>", batch_paste_handler)
        else:
            url_input_row = tk.Frame(url_left, bg=theme["surface"])
            url_input_row.pack(fill="x", pady=self._px((6, 0)))
            url_entry_frame = tk.Frame(
                url_input_row,
                bg=theme["surface_alt"],
                highlightthickness=1,
                highlightbackground=theme["border"],
                highlightcolor=theme["border"],
            )
            url_entry_frame.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.url_entry = tk.Entry(
                url_entry_frame,
                font=fonts["body"],
                bg=theme["surface_alt"],
                fg=theme["text"],
                insertbackground=theme["text"],
                selectbackground=theme["accent"],
                selectforeground=theme["bg"],
                relief="flat",
                bd=0,
                highlightthickness=0,
            )
            self.url_entry.pack(fill=tk.X, expand=True, ipady=self._px(6), padx=self._px(6), pady=self._px(4))
            first_line = ""
            if saved_url_entry:
                self.url_entry.insert(0, saved_url_entry)
            elif saved_url_text:
                first_line = next((line.strip() for line in saved_url_text.splitlines() if line.strip()), "")
            if first_line:
                self.url_entry.insert(0, first_line)
            self.url_entry.bind("<KeyRelease>", lambda e: self._apply_single_url_limit())
            self.url_entry.bind("<<Paste>>", lambda e: self._after(0, self._apply_single_url_limit))
            self.url_entry.bind("<FocusOut>", lambda _e: self._on_url_commit())
            self.url_entry.bind("<Return>", lambda _e: self._on_url_commit())
            self._apply_single_url_limit()
            self.paste_button = tk.Button(
                url_input_row,
                text="Paste",
                command=self.paste_url,
                font=fonts["button"],
                bg=theme["surface_alt"],
                fg=theme["text"],
                activebackground=theme["surface_alt_hover"],
                activeforeground=theme["text"],
                relief="flat",
                bd=0,
                padx=self._px(38),
                pady=self._px(7),
                cursor="hand2",
            )
            self.paste_button.pack(side=tk.LEFT, padx=self._px((8, 0)))
            self.add_hover_effect(
                self.paste_button,
                bg_normal=theme["surface_alt"],
                fg_normal=theme["text"],
                bg_hover=theme["surface_alt_hover"],
                fg_hover=theme["accent"],
                is_hover_enabled_func=lambda: not self.downloading
            )

        current_format = prev_format or "video"
        self.selected_format = tk.StringVar(value=current_format)
        format_card = tk.Frame(
            self.main_frame,
            bg=theme["surface"],
            highlightthickness=1,
            highlightbackground=theme["border"],
            highlightcolor=theme["border"],
        )
        format_card.grid(row=1, column=0, sticky="ew", pady=self._px((0, 12)), padx=self._px((0, 6)))
        format_card.grid_columnconfigure(0, weight=1)
        format_body = tk.Frame(format_card, bg=theme["surface"])
        format_body.grid(row=0, column=0, sticky="ew", padx=self._px(16), pady=self._px(12))
        tk.Label(format_body, text="Format", font=fonts["label"], fg=theme["muted"], bg=theme["surface"]).pack(anchor="w")
        format_row = tk.Frame(format_body, bg=theme["surface"])
        format_row.pack(fill="x", pady=self._px((6, 0)))
        format_row.grid_columnconfigure(0, weight=1)

        self._format_static_options = ["VIDEO", "AUDIO", "MP4", "MP3", "Load others"]
        self.selected_other_format = tk.StringVar(value="Choose format")
        self.format_combo = ttk.Combobox(
            format_row,
            textvariable=self.selected_other_format,
            values=[],
            style="WhiteOnBlack.TCombobox",
            height=7,
            font=fonts["button"],
            state="readonly",
        )
        self.format_combo.configure(takefocus=0)
        self.format_combo.pack(fill="x", expand=True)
        self.format_combo.bind("<<ComboboxSelected>>", self.on_format_combo_selected)
        self.format_combo.bind("<Button-1>", self._on_format_combo_open)
        self.format_combo.bind("<FocusOut>", self._on_format_combo_focus_out)
        self._disable_combo_scroll(self.format_combo)
        if not hasattr(self, "_format_options_default"):
            self._format_options_default = list(self._format_static_options)
        self._set_format_options(self._format_options_default)
        preferred_label = ""
        if prev_format:
            preferred_label = {
                "video": "VIDEO",
                "audio": "AUDIO",
                "mp4": "MP4",
                "mp3": "MP3",
            }.get(str(prev_format).strip().lower(), "")
        if not preferred_label:
            preferred_label = {
                "video": "VIDEO",
                "audio": "AUDIO",
                "mp4": "MP4",
                "mp3": "MP3",
            }.get(str(self.config.get("default_format_selection", "") or "").strip().lower(), "")
        if preferred_label:
            self.selected_other_format.set(preferred_label)
        self.selected_format.set(self._normalize_format_choice(self.selected_other_format.get()))
        self.update_format_buttons()

        self.quality_options = [
            ("BEST QUALITY", "BEST"),
            ("2160p", "2160p"),
            ("1440p", "1440p"),
            ("1080p", "1080p"),
            ("720p", "720p"),
            ("480p", "480p"),
            ("360p", "360p"),
            ("240p", "240p"),
            ("144p", "144p")
        ]
        self._quality_options_default = list(self.quality_options)
        current_quality = prev_quality or "BEST QUALITY"
        self.selected_quality = tk.StringVar(value=current_quality)
        self._prev_quality = current_quality
        quality_card = tk.Frame(
            self.main_frame,
            bg=theme["surface"],
            highlightthickness=1,
            highlightbackground=theme["border"],
            highlightcolor=theme["border"],
        )
        quality_card.grid(row=1, column=1, sticky="ew", pady=self._px((0, 12)), padx=self._px((6, 0)))
        quality_card.grid_columnconfigure(0, weight=1)
        quality_body = tk.Frame(quality_card, bg=theme["surface"])
        quality_body.grid(row=0, column=0, sticky="ew", padx=self._px(16), pady=self._px(12))
        tk.Label(quality_body, text="Quality", font=fonts["label"], fg=theme["muted"], bg=theme["surface"]).pack(anchor="w")
        quality_row = tk.Frame(quality_body, bg=theme["surface"])
        quality_row.pack(fill="x", expand=True, pady=self._px((6, 0)))
        self.quality_combo = ttk.Combobox(
            quality_row,
            textvariable=self.selected_quality,
            values=[q[0] for q in self.quality_options],
            style="WhiteOnBlack.TCombobox",
            height=7,
            font=fonts["button"],
            state="readonly",
        )
        self.quality_combo.configure(takefocus=0)
        self.quality_combo.pack(fill="x", expand=True)
        self.quality_combo.bind("<<ComboboxSelected>>", self.on_quality_selected)
        self.quality_combo.bind("<Button-1>", self._on_quality_combo_open)
        self.quality_combo.bind("<FocusIn>", self._clear_combo_selection)
        self.quality_combo.bind("<ButtonRelease-1>", self._clear_combo_selection)
        self.quality_combo.bind("<B1-Motion>", self._clear_combo_selection)
        self.quality_combo.bind("<FocusOut>", self._clear_combo_selection)
        self._disable_combo_scroll(self.quality_combo)
        self.update_quality_buttons()
        self._after(0, lambda: self._sync_card_heights(format_card, quality_card))
        btn_row = tk.Frame(self.main_frame, bg=theme["bg"])
        btn_row.grid(row=2, column=0, columnspan=2, sticky="ew", pady=self._px((0, 12)))
        btn_row.grid_columnconfigure(0, weight=1, uniform="action")
        btn_row.grid_columnconfigure(1, weight=1, uniform="action")
        self.download_button = tk.Button(
            btn_row, text="Download", command=self.start_download, font=fonts["button"],
            bg=theme["success"], fg=theme["bg"],
            activebackground=theme["success_hover"], activeforeground=theme["bg"],
            relief="flat", bd=0, padx=self._px(16), pady=self._px(6), cursor="hand2"
        )
        self.download_button.grid(row=0, column=0, sticky="ew", padx=self._px((0, 6)))
        self.add_hover_effect(
            self.download_button,
            bg_normal=theme["success"], fg_normal=theme["bg"],
            bg_hover=theme["success_hover"], fg_hover=theme["bg"],
            is_enabled_func=lambda: not self.downloading,
            is_hover_enabled_func=lambda: not self.downloading
        )
        self.abort_button = tk.Button(
            btn_row, text="STOP", command=self.abort, font=fonts["button"],
            bg=theme["danger"], fg=theme["bg"],
            activebackground=theme["danger_hover"], activeforeground=theme["bg"],
            relief="flat", bd=0, padx=self._px(16), pady=self._px(6), cursor="hand2"
        )
        self.abort_button.grid(row=0, column=1, sticky="ew", padx=self._px((6, 0)))
        self.add_hover_effect(
            self.abort_button,
            bg_normal=theme["danger"], fg_normal=theme["bg"],
            bg_hover=theme["danger_hover"], fg_hover=theme["bg"],
            is_hover_enabled_func=None
        )
        for btn in (self.download_button, self.abort_button):
            try:
                btn.config(disabledforeground=theme["disabled_fg"])
            except tk.TclError:
                pass
            try:
                btn.config(disabledbackground=theme["disabled_bg"])
            except tk.TclError:
                pass
        if not self.downloading:
            self.abort_button.config(state=tk.DISABLED, cursor="", bg=theme["disabled_bg"], fg=theme["disabled_fg"])

        if not is_batch:
            self.progress = tk.Canvas(
                self.main_frame,
                height=self._px(36),
                bg=theme["surface_alt"],
                highlightthickness=self._px(1),
                highlightbackground=theme["border"],
                highlightcolor=theme["border"],
                bd=0,
                relief="flat"
            )
            self.progress.grid(row=3, column=0, columnspan=2, sticky="ew", pady=self._px((0, 12)), ipady=self._px(4))
            self._progress_value = 0.0
            self._progress_fill_color = theme["accent"]
            self.progress_fill_id = self.progress.create_rectangle(0, 0, 0, 0, fill=self._progress_fill_color, width=0)
            self.progress_text_id = self.progress.create_text(
                0,
                0,
                text="0%",
                font=(fonts["caption"][0], fonts["caption"][1], "bold"),
                fill=theme["text"]
            )
            self.progress.bind("<Configure>", lambda _e: self._update_progress_canvas())
            self._last_progress_text = "0%"
            self._update_progress_canvas()
        else:
            self.progress = None
            self._last_progress_text = None
            self.progress_fill_id = None
            self.progress_text_id = None

        console_frame = tk.Frame(
            self.main_frame,
            bg=theme["surface"],
            highlightthickness=1,
            highlightbackground=theme["border"],
            highlightcolor=theme["border"],
        )
        self.console_frame = console_frame
        console_frame.grid(row=4, column=0, columnspan=2, sticky="nsew")
        self.console = tk.Text(
            console_frame,
            height=5,
            bg=theme["surface"],
            fg=theme["text"],
            insertbackground=theme["text"],
            selectbackground=theme["accent"],
            selectforeground=theme["bg"],
            highlightthickness=0,
            bd=0,
            state="normal",
            wrap="word",
            font=fonts["mono"],
        )
        self.console.pack(side="left", fill="both", expand=True)
        def _on_console_mousewheel(event):
            if event.delta:
                self.console.yview_scroll(int(-1 * (event.delta / 120)), "units")
            elif event.num == 5:
                self.console.yview_scroll(1, "units")
            elif event.num == 4:
                self.console.yview_scroll(-1, "units")
            return "break"
        self.console.bind("<MouseWheel>", _on_console_mousewheel)
        self.console.bind("<Button-4>", _on_console_mousewheel)
        self.console.bind("<Button-5>", _on_console_mousewheel)
        def _block_console_edit(event):
            if event.keysym in ("BackSpace", "Delete", "Return", "KP_Enter", "Tab"):
                return "break"
            if event.state & 0x4:
                if event.keysym.lower() in ("c", "a"):
                    return None
                return "break"
            if event.char and event.char >= " ":
                return "break"
            return None
        self.console.bind("<KeyPress>", _block_console_edit)
        self.console.bind("<<Paste>>", lambda e: "break")
        self.console.bind("<<Cut>>", lambda e: "break")
        self.console.bind("<<Clear>>", lambda e: "break")

        bottom_bar = tk.Frame(outer, bg=theme["bg"], padx=self._px(24), pady=self._px(8))
        bottom_bar.grid(row=3, column=0, sticky="ew")
        bottom_left = tk.Frame(bottom_bar, bg=theme["bg"])
        bottom_right = tk.Frame(bottom_bar, bg=theme["bg"])
        theme_toggle_btn = tk.Button(
            bottom_left, text=self._theme_icon(), font=fonts["label"],
            bg=theme["bg"], fg=theme["muted"],
            activebackground=theme["bg"], activeforeground=theme["text"],
            relief="flat", bd=0, padx=self._px(6), pady=self._px(2), command=self.toggle_theme, cursor="hand2"
        )
        theme_toggle_btn.pack(side="left", anchor="w", padx=self._px((0, 8)))
        self._register_theme_toggle(theme_toggle_btn)
        self.add_hover_effect(
            theme_toggle_btn,
            bg_normal=theme["bg"], fg_normal=theme["muted"],
            bg_hover=theme["bg"], fg_hover=theme["accent"],
            is_hover_enabled_func=lambda: not self.downloading
        )
        self.gear_btn = tk.Button(
            bottom_left, text="Settings", font=fonts["label"],
            bg=theme["bg"], fg=theme["muted"],
            activebackground=theme["bg"], activeforeground=theme["text"],
            relief="flat", bd=0, padx=self._px(8), pady=self._px(2), command=self.show_settings, cursor="hand2"
        )
        self.gear_btn.pack(side="left", anchor="w")
        self.add_hover_effect(
            self.gear_btn,
            bg_normal=theme["bg"], fg_normal=theme["muted"],
            bg_hover=theme["bg"], fg_hover=theme["accent"],
            is_hover_enabled_func=lambda: not self.downloading
        )
        if self.downloading:
            self.gear_btn.config(state=tk.DISABLED, cursor="")
        else:
            self.gear_btn.config(state=tk.NORMAL)
        downloads_link = tk.Label(bottom_right, text="Open downloads folder", font=fonts["caption"], fg=theme["accent"], bg=theme["bg"], cursor="hand2")
        downloads_link.pack(side="right", anchor="e", padx=self._px((0, 8)))
        downloads_link.bind("<Button-1>", lambda e: self.open_downloads_folder())
        self.add_hover_effect(
            downloads_link,
            bg_normal=theme["bg"], fg_normal=theme["accent"],
            bg_hover=theme["bg"], fg_hover=theme["text"]
        )
        official_link = tk.Label(bottom_right, text="Official page", font=fonts["caption"], fg=theme["accent"], bg=theme["bg"], cursor="hand2")
        official_link.pack(side="right", anchor="e", padx=self._px((0, 8)))
        official_link.bind("<Button-1>", lambda e: self.open_url("https://justagwas.com/projects/mediacrate"))
        self.add_hover_effect(
            official_link,
            bg_normal=theme["bg"], fg_normal=theme["accent"],
            bg_hover=theme["bg"], fg_hover=theme["text"]
        )
        version_label = tk.Label(bottom_right, text="v1.1.0", font=fonts["caption"], fg=theme["muted"], bg=theme["bg"])
        version_label.pack(side="right", anchor="e", padx=self._px((0, 8)))
        self._configure_footer(bottom_bar, bottom_left, bottom_right, min_width=540)
        self.enforce_min_size()
        self._apply_window_constraints(min_extra=self._batch_min_extra if is_batch else 0)
        self.root.update_idletasks()
        if switch_view:
            self._show_view("main")
        self._main_built = True
        if switch_view:
            self._after(0, self._fade_in)

    def update_format_buttons(self):
        if getattr(self, "format_combo", None) and self.format_combo.winfo_exists():
            if not self.downloading:
                state = str(self.format_combo.cget("state"))
                if state != "disabled":
                    self.format_combo.config(state="readonly")
                    try:
                        self.format_combo.config(cursor="hand2")
                    except tk.TclError:
                        pass
            else:
                self.format_combo.config(state="disabled")
                try:
                    self.format_combo.config(cursor="")
                except tk.TclError:
                    pass

    def _restore_main_size_after_settings(self):
        restored = False
        if self._settings_enter_size and not self._settings_user_resized:
            target_w, target_h = self._settings_enter_size
            self._set_geometry_safe(target_w, target_h)
            self._last_user_size = (target_w, target_h)
            restored = True
        self._settings_enter_size = None
        self._settings_forced_size = None
        self._settings_user_resized = False
        return restored

    def show_main_view(self):
        self._record_current_view_size()
        force_rebuild = getattr(self, "_pending_batch_refresh", False) or getattr(self, "_pending_main_rebuild", False)
        self._pending_batch_refresh = False
        self._pending_main_rebuild = False
        if getattr(self, "settings_view", None) and self.settings_view.winfo_exists():
            for widget in self.settings_view.winfo_children():
                widget.destroy()
        is_batch = self.config.get('allow_batch_downloads', False)
        target_key = "main_batch" if is_batch else "main"
        if self.config.get('enable_window_resizing', True):
            current_w = self.root.winfo_width()
            current_h = self.root.winfo_height()
            if current_w > 1 and current_h > 1:
                self._last_user_size = (current_w, current_h)
                self._record_view_size(target_key, current_w, current_h)
        else:
            base_size = self._view_sizes.get(target_key)
            if base_size:
                scale = getattr(self, "_ui_scale_factor", 1.0) or 1.0
                target_size = (
                    max(1, int(round(base_size[0] * scale))),
                    max(1, int(round(base_size[1] * scale)))
                )
            else:
                target_size = self._base_minsize()
            self._last_user_size = target_size
        self.create_widgets(force_rebuild=force_rebuild, switch_view=True)
        self._batch_active = is_batch
        self._apply_window_constraints(min_extra=self._batch_min_extra if is_batch else 0)
        self._record_view_size(target_key)

    def update_quality_buttons(self):
        if not hasattr(self, "selected_quality"):
            return
        is_audio = self._is_audio_format(self.selected_format.get())
        if is_audio:
            self.selected_quality.set("BEST QUALITY")
        if self.selected_quality.get() not in [q[0] for q in self.quality_options]:
            self.selected_quality.set("BEST QUALITY")
        if hasattr(self, 'quality_combo') and self.quality_combo.winfo_exists():
            combo_state = "disabled" if is_audio or self.downloading else "readonly"
            self.quality_combo.config(state=combo_state)
            try:
                self.quality_combo.config(cursor="hand2" if combo_state != "disabled" else "")
            except tk.TclError:
                pass

    def _set_quality_options(self, options):
        if not options:
            options = [q[0] for q in getattr(self, "_quality_options_default", [])] or ["BEST QUALITY"]
        if "BEST QUALITY" not in options:
            options = ["BEST QUALITY"] + list(options)
        self.quality_options = [(opt, opt) for opt in options]
        if not hasattr(self, "selected_quality"):
            return
        if hasattr(self, 'quality_combo') and self.quality_combo.winfo_exists():
            self.quality_combo.config(values=[q[0] for q in self.quality_options])
        if self.selected_quality.get() not in [q[0] for q in self.quality_options]:
            self.selected_quality.set("BEST QUALITY")
        self.update_quality_buttons()

    def _reset_quality_options(self):
        defaults = [q[0] for q in getattr(self, "_quality_options_default", [])]
        self._set_quality_options(defaults)

    def _set_quality_placeholder(self, text):
        placeholder = text or "Waiting for URL"
        self.quality_options = [(placeholder, placeholder)]
        if not hasattr(self, "selected_quality"):
            return
        if hasattr(self, 'quality_combo') and self.quality_combo.winfo_exists():
            self.quality_combo.config(values=[placeholder], state="disabled")
        self.selected_quality.set(placeholder)

    def _set_format_options(self, options):
        if not options:
            options = list(getattr(self, "_format_options_default", [])) or ["Choose format"]
        if getattr(self, "format_combo", None) and self.format_combo.winfo_exists():
            self.format_combo.config(values=list(options))
        current_choice = self.selected_other_format.get()
        if current_choice not in options and current_choice != "Choose format":
            fallback_choice = options[0] if options else "Choose format"
            self.selected_other_format.set(fallback_choice)
            if hasattr(self, "selected_format"):
                self.selected_format.set(self._normalize_format_choice(fallback_choice))
        self._update_format_combo_style()
        if getattr(self, "format_combo", None) and self.format_combo.winfo_exists():
            if not self.downloading:
                self.format_combo.config(state="readonly")
                try:
                    self.format_combo.config(cursor="hand2")
                except tk.TclError:
                    pass

    def _set_format_placeholder(self, text):
        placeholder = text or "Choose format"
        self._set_format_options([placeholder])
        if getattr(self, "format_combo", None) and self.format_combo.winfo_exists():
            self.format_combo.config(state="disabled")
            try:
                self.format_combo.config(cursor="")
            except tk.TclError:
                pass

    def _normalize_format_choice(self, choice):
        label = str(choice or "").strip()
        upper = label.upper()
        if upper == "VIDEO":
            return "video"
        if upper == "AUDIO":
            return "audio"
        if upper == "MP4":
            return "mp4"
        if upper == "MP3":
            return "mp3"
        if upper in ("LOAD OTHERS", "LOADING FORMATS..."):
            return ""
        return label.lower()

    def _format_choice_output_ext(self, format_choice):
        if format_choice == "video":
            return "mp4"
        if format_choice == "audio":
            return None
        return format_choice or "mp4"

    def _resolve_output_ext_from_temp(self, temp_filename):
        base, ext = os.path.splitext(temp_filename)
        if ext.startswith("."):
            return ext[1:]
        return ext or ""

    def _find_existing_output_path(self, media_dir, safe_base, format_choice):
        output_ext = self._format_choice_output_ext(format_choice)
        if output_ext:
            candidate = os.path.join(media_dir, f"{safe_base}.{output_ext}")
            return candidate if os.path.exists(candidate) else None
        audio_exts = [
            "mp3", "wav", "m4a", "aac", "opus", "ogg", "flac", "alac", "wma", "aiff", "webm"
        ]
        for ext in audio_exts:
            candidate = os.path.join(media_dir, f"{safe_base}.{ext}")
            if os.path.exists(candidate):
                return candidate
        return None

    def _load_other_formats_for_current_url(self):
        entry = getattr(self, "url_entry", None)
        raw = entry.get().strip() if entry and entry.winfo_exists() else ""
        if not raw:
            messagebox.showinfo("URL required", "Paste a URL to load available formats.")
            return
        sanitized_raw = self.sanitize_url(raw)
        if not sanitized_raw or self._is_incomplete_youtube_url(sanitized_raw):
            messagebox.showwarning("Invalid URL", "The URL isn't valid, so formats can't be loaded.")
            return
        sanitized = self._on_url_commit()
        if not sanitized:
            messagebox.showwarning("Invalid URL", "The URL isn't valid, so formats can't be loaded.")
            return
        url_key = self._url_key(sanitized)
        cached = self._format_cache.get(url_key)
        if cached:
            self._set_format_options(self._format_static_options[:4] + cached)
            return
        self._format_probe_inflight = True
        self._format_probe_url = url_key
        self._set_format_placeholder("Loading formats...")
        self._after(10000, self._clear_format_probe_if_stale)
        self._schedule_format_probe(sanitized)

    def _update_format_combo_style(self):
        combo = getattr(self, "format_combo", None)
        if not combo or not combo.winfo_exists():
            return
        try:
            combo.config(style="WhiteOnBlack.TCombobox")
        except tk.TclError:
            pass

    def _available_formats_for_info(self, info_dict):
        if not info_dict:
            return []
        formats = info_dict.get("formats") or []
        exts = []
        for fmt in formats:
            if not isinstance(fmt, dict):
                continue
            ext = (fmt.get("ext") or "").strip().lower()
            if not ext:
                continue
            if ext in ("mp4", "mp3"):
                continue
            if ext not in exts:
                exts.append(ext)
        return sorted(exts)

    def _schedule_format_probe(self, url):
        if self.config.get('allow_batch_downloads', False):
            return
        if self.downloading:
            return
        if getattr(self, "_url_dirty", False):
            return
        if not url or not self.sanitize_url(url):
            return
        if self._is_incomplete_youtube_url(url):
            return
        if self._format_probe_job:
            try:
                self.root.after_cancel(self._format_probe_job)
            except Exception:
                pass
        self._format_probe_token += 1
        token = self._format_probe_token
        self._format_probe_job = self._after(250, lambda: self._probe_format_for_url(url, token))

    def _probe_format_for_url(self, url, token):
        self._format_probe_job = None
        if token != self._format_probe_token:
            return
        if self.config.get('allow_batch_downloads', False):
            return
        sanitized = self.sanitize_url(url)
        if not sanitized or self._is_incomplete_youtube_url(sanitized):
            self._set_format_placeholder("Choose format")
            return
        url_key = self._url_key(sanitized)
        cached = self._format_cache.get(url_key)
        if cached:
            self.run_on_ui_thread(self._finish_format_probe, url_key, cached, True)
            return
        def worker():
            probe_ok = False
            try:
                ydl_opts = {
                    'quiet': True,
                    'skip_download': True,
                    'no_warnings': True,
                    'simulate': True,
                }
                with YoutubeDL(ydl_opts) as ydl:
                    info_dict = ydl.extract_info(sanitized, download=False, process=False)
                formats = self._available_formats_for_info(info_dict)
                probe_ok = True
            except Exception:
                formats = []
            self.run_on_ui_thread(self._finish_format_probe, url_key, formats, probe_ok)
        threading.Thread(target=worker, daemon=True).start()

    def _finish_format_probe(self, url_key, formats, probe_ok):
        if url_key != self._format_probe_url:
            self._format_probe_inflight = False
            return
        self._format_probe_inflight = False
        if formats:
            self._format_cache[url_key] = formats
        if not formats:
            formats = []
        options = list(self._format_static_options[:4])
        options.extend(formats)
        self._set_format_options(options)

    def _clear_format_probe_if_stale(self):
        if not getattr(self, "_format_probe_inflight", False):
            return
        self._format_probe_inflight = False

    def _on_format_combo_open(self, _event=None):
        if self.config.get('allow_batch_downloads', False):
            return
        entry = getattr(self, "url_entry", None)
        raw = entry.get().strip() if entry and entry.winfo_exists() else ""
        if not raw:
            messagebox.showinfo("URL required", "Paste a URL to select a format.")
            return "break"
        sanitized_raw = self.sanitize_url(raw)
        if not sanitized_raw or self._is_incomplete_youtube_url(sanitized_raw):
            messagebox.showwarning("Invalid URL", "The URL isn't valid, so formats can't be loaded.")
            return "break"
        sanitized = self._on_url_commit()
        if not sanitized:
            messagebox.showwarning("Invalid URL", "The URL isn't valid, so formats can't be loaded.")
            return "break"
        self._format_combo_prev_value = self.selected_other_format.get().strip()
        self._format_combo_selection_made = False

    def _available_qualities_for_info(self, info_dict, format_choice):
        if not info_dict or format_choice in ("mp3", "wav", "audio"):
            return ["BEST QUALITY"]
        formats = info_dict.get("formats") or []
        heights = set()
        for fmt in formats:
            if not isinstance(fmt, dict):
                continue
            if fmt.get("vcodec") == "none":
                continue
            height = fmt.get("height")
            if not height:
                continue
            heights.add(int(height))
        if not heights:
            return ["BEST QUALITY"]
        ordered = [2160, 1440, 1080, 720, 480, 360, 240, 144]
        available = ["BEST QUALITY"]
        for h in ordered:
            if h in heights:
                available.append(f"{h}p")
        return available

    def _schedule_quality_probe(self, url, show_placeholder=False):
        if self.config.get('allow_batch_downloads', False):
            return
        if self.downloading:
            return
        if getattr(self, "_url_dirty", False):
            return
        if not url or not self.sanitize_url(url):
            return
        if self._is_incomplete_youtube_url(url):
            return
        if self._quality_probe_job:
            try:
                self.root.after_cancel(self._quality_probe_job)
            except Exception:
                pass
        self._quality_probe_token += 1
        token = self._quality_probe_token
        self._quality_probe_job = self._after(250, lambda: self._probe_quality_for_url(url, token))

    def _probe_quality_for_url(self, url, token):
        self._quality_probe_job = None
        if token != self._quality_probe_token:
            return
        if self.config.get('allow_batch_downloads', False):
            return
        sanitized = self.sanitize_url(url)
        if not sanitized or self._is_incomplete_youtube_url(sanitized):
            self._set_quality_placeholder("Waiting for URL")
            return
        format_choice = self.selected_format.get()
        probe_format = format_choice
        def worker():
            probe_ok = False
            try:
                ydl_opts = {
                    'quiet': True,
                    'skip_download': True,
                    'no_warnings': True,
                    'simulate': True,
                }
                with YoutubeDL(ydl_opts) as ydl:
                    info_dict = ydl.extract_info(sanitized, download=False, process=False)
                qualities = self._available_qualities_for_info(info_dict, format_choice)
                probe_ok = True
            except Exception:
                qualities = [q[0] for q in getattr(self, "_quality_options_default", [])]
            self.run_on_ui_thread(self._finish_quality_probe, sanitized, probe_format, qualities, probe_ok)
        threading.Thread(target=worker, daemon=True).start()

    def _finish_quality_probe(self, url, probe_format, qualities, probe_ok):
        if url != self._quality_probe_url or probe_format != self._quality_probe_format:
            self._quality_probe_inflight = False
            return
        self._quality_probe_inflight = False
        self._set_quality_options(qualities)
        if probe_ok:
            self._last_ready_url = url
            self._last_ready_format = probe_format
        if self._quality_autopen and self._quality_probe_url == url and self._quality_probe_format == probe_format:
            self._quality_autopen = False
            if not self._window_has_focus():
                return
            combo = getattr(self, "quality_combo", None)
            if combo and combo.winfo_exists():
                self._quality_open_allow = True
                try:
                    combo.focus_set()
                    combo.event_generate("<Button-1>")
                except Exception:
                    pass

    def _clear_quality_probe_if_stale(self):
        if not getattr(self, "_quality_probe_inflight", False):
            return
        self._quality_probe_inflight = False

    def _on_quality_combo_open(self, _event=None):
        if self.config.get('allow_batch_downloads', False):
            return
        if self.downloading:
            return "break"
        if self._is_audio_format(self.selected_format.get()):
            return "break"
        if getattr(self, "_quality_open_allow", False):
            self._quality_open_allow = False
            return
        if getattr(self, "_quality_probe_inflight", False):
            return "break"
        entry = getattr(self, "url_entry", None)
        raw = entry.get().strip() if entry and entry.winfo_exists() else ""
        if not raw:
            messagebox.showinfo("URL required", "Paste a URL to load available formats.")
            return "break"
        sanitized_raw = self.sanitize_url(raw)
        if not sanitized_raw or self._is_incomplete_youtube_url(sanitized_raw):
            messagebox.showwarning("Invalid URL", "The URL isn't valid, so formats can't be loaded.")
            return "break"
        sanitized = self._on_url_commit()
        if not sanitized:
            messagebox.showwarning("Invalid URL", "The URL isn't valid, so formats can't be loaded.")
            return "break"
        if self._last_ready_url == sanitized and self._last_ready_format == self.selected_format.get() and self.quality_options:
            return
        self._quality_probe_inflight = True
        self._quality_autopen = True
        self._quality_probe_url = sanitized
        self._quality_probe_format = self.selected_format.get()
        self._set_quality_placeholder("Loading formats...")
        self._after(10000, self._clear_quality_probe_if_stale)
        self._schedule_quality_probe(sanitized, show_placeholder=False)

    def on_format_combo_selected(self, _event=None):
        self._format_combo_selection_made = True
        choice = self.selected_other_format.get().strip()
        if choice.lower() == "load others":
            prev_value = getattr(self, "_format_combo_prev_value", "") or "Choose format"
            if getattr(self, "selected_other_format", None):
                self.selected_other_format.set(prev_value)
            self._update_format_combo_style()
            self._load_other_formats_for_current_url()
            return
        if choice and choice not in ("Choose format", "Loading formats..."):
            self.selected_format.set(self._normalize_format_choice(choice))
            if self._is_audio_format(self.selected_format.get()):
                self.selected_quality.set("BEST QUALITY")
        self.update_format_buttons()
        self._update_format_combo_style()
        self.update_quality_buttons()

    def _on_format_combo_focus_out(self, _event=None):
        if self.downloading:
            return
        choice = self.selected_other_format.get().strip()
        choice_upper = choice.upper()
        if choice_upper in ("VIDEO", "AUDIO", "MP4", "MP3"):
            if hasattr(self, "selected_format"):
                self.selected_format.set(self._normalize_format_choice(choice))
            self.update_format_buttons()
            self._update_format_combo_style()
            self._format_combo_selection_made = False
            return
        if not getattr(self, "_format_combo_selection_made", False):
            prev_value = getattr(self, "_format_combo_prev_value", "") or "Choose format"
            if getattr(self, "selected_other_format", None):
                self.selected_other_format.set(prev_value)
            self.update_format_buttons()
            self._update_format_combo_style()
            return
        values = []
        try:
            values = list(self.format_combo.cget("values"))
        except Exception:
            pass
        if not choice or choice in ("Choose format", "Loading formats...") or (values and choice not in values):
            if getattr(self, "selected_other_format", None):
                self.selected_other_format.set("Choose format")
            self.update_format_buttons()
        self._update_format_combo_style()
        self._format_combo_selection_made = False

    def try_quality_change(self, qual):
        prev_qual = self._prev_quality
        if qual != prev_qual:
            if not self.prompt_quality_change(qual):
                self.selected_quality.set(prev_qual)
                self.update_quality_buttons()
                return
        self.selected_quality.set(qual)
        self._prev_quality = qual
        self.update_quality_buttons()

    def on_quality_selected(self, _event=None):
        self.try_quality_change(self.selected_quality.get())

    def _clear_combo_selection(self, event=None):
        try:
            widget = event.widget if event else self.quality_combo
            widget.selection_clear()
        except Exception:
            pass

    def paste_url(self):
        try:
            self.url_entry.delete(0, tk.END)
            self.url_entry.insert(0, self.root.clipboard_get())
            self._apply_single_url_limit()
            theme = self.theme
            self._fade_entry_fg(self.url_entry, start_color=theme["accent"], end_color=theme["text"], steps=10, delay=40)
        except tk.TclError:
            messagebox.showerror("Error", "No URL found in clipboard")

    def _fade_entry_fg(self, entry, start_color, end_color, steps=10, delay=40):
        def hex_to_rgb(hex_color):
            hex_color = hex_color.lstrip('#')
            return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        def rgb_to_hex(rgb):
            return '#{:02x}{:02x}{:02x}'.format(*rgb)
        start_rgb = hex_to_rgb(start_color)
        end_rgb = hex_to_rgb(end_color)
        def step(i):
            ratio = i / steps
            curr_rgb = tuple(
                int(start_rgb[j] + (end_rgb[j] - start_rgb[j]) * ratio)
                for j in range(3)
            )
            entry.config(fg=rgb_to_hex(curr_rgb))
            if i < steps:
                self._after(delay, lambda: step(i+1), widget=entry)
        step(0)

    def sanitize_filename(self, name):
        return sanitize_filename(name).strip()

    def _is_valid_netloc(self, netloc):
        if not netloc:
            return False
        host_port = netloc.rsplit("@", 1)[-1]
        host = host_port.split(":", 1)[0]
        if not host or " " in host:
            return False
        if host == "localhost":
            return True
        if re.fullmatch(r"\d{1,3}(\.\d{1,3}){3}", host):
            return True
        return "." in host

    def sanitize_url(self, url):
        if not url:
            return None
        url = url.strip()
        parsed = urlparse(url)
        if parsed.scheme and parsed.netloc:
            if not self._is_valid_netloc(parsed.netloc):
                return None
            return url
        if not parsed.scheme and parsed.path:
            candidate = f"https://{url}"
            parsed_candidate = urlparse(candidate)
            if parsed_candidate.netloc and self._is_valid_netloc(parsed_candidate.netloc):
                return candidate
        return None

    def _is_incomplete_youtube_url(self, url):
        try:
            parsed = urlparse(url or "")
            host = (parsed.netloc or "").lower()
        except Exception:
            return False
        if not (host.endswith("youtube.com") or host.endswith("youtu.be") or host.endswith("youtube-nocookie.com")):
            return False
        if host.endswith("youtu.be"):
            vid = parsed.path.lstrip("/").split("/", 1)[0]
            return 0 < len(vid) < 11
        query = parse_qs(parsed.query or "")
        vid = query.get("v", [""])[0]
        return 0 < len(vid) < 11

    def validate_url(self, url, *, show_error=False):
        sanitized = self.sanitize_url(url)
        if not sanitized and show_error:
            messagebox.showerror("Invalid URL", "The link is invalid.")
        return sanitized

    def _apply_single_url_limit(self):
        entry = getattr(self, "url_entry", None)
        if not entry or not entry.winfo_exists():
            return
        value = entry.get()
        if not self.config.get('disable_char_limits', False) and len(value) > 512:
            entry.delete(0, tk.END)
            entry.insert(0, value[:512])
            value = entry.get()
        if not self.config.get('allow_batch_downloads', False):
            if value != getattr(self, "_last_url_value", None):
                self._on_url_changed()
                self._last_url_value = value

    def _apply_batch_text_limits(self):
        if getattr(self, "_batch_enforcing", False):
            return
        text = getattr(self, "url_text", None)
        if not text or not text.winfo_exists():
            return
        self._batch_enforcing = True
        try:
            content = text.get("1.0", "end-1c")
            lines = content.splitlines()
            max_lines = self._normalize_batch_line_limit(self.config.get('max_batch_lines'))
            if len(lines) > max_lines:
                lines = lines[:max_lines]
            if not self.config.get('disable_char_limits', False):
                lines = [line[:256] for line in lines]
            new_content = "\n".join(lines)
            if new_content != content:
                insert_index = text.index(tk.INSERT)
                text.delete("1.0", tk.END)
                text.insert("1.0", new_content)
                try:
                    text.mark_set(tk.INSERT, insert_index)
                except Exception:
                    pass
        finally:
            self._batch_enforcing = False

    def _on_url_changed(self):
        self._url_dirty = True
        self._last_ready_url = None
        self._last_ready_format = None
        self._quality_probe_inflight = False
        self._quality_autopen = False
        self._quality_probe_url = None
        self._quality_probe_format = None
        self._format_probe_inflight = False
        self._format_probe_url = None
        self._format_cache = {}
        if getattr(self, "selected_other_format", None):
            current_label = self.selected_other_format.get().strip()
            if current_label and current_label not in ("Choose format", "Loading formats..."):
                if current_label.upper() not in ("VIDEO", "AUDIO", "MP4", "MP3", "LOAD OTHERS"):
                    self.selected_other_format.set("Choose format")
                    if hasattr(self, "selected_format"):
                        self.selected_format.set("")
                    self._update_format_combo_style()
        if getattr(self, "_quality_probe_job", None):
            try:
                self.root.after_cancel(self._quality_probe_job)
            except Exception:
                pass
            self._quality_probe_job = None

    def _on_url_commit(self):
        if self.config.get('allow_batch_downloads', False):
            return
        entry = getattr(self, "url_entry", None)
        if not entry or not entry.winfo_exists():
            return
        raw = entry.get().strip()
        sanitized = self.sanitize_url(raw)
        if not sanitized or self._is_incomplete_youtube_url(sanitized):
            self._last_valid_url = None
            self._last_ready_url = None
            self._last_ready_format = None
            self._quality_probe_inflight = False
            self._quality_autopen = False
            self._quality_probe_url = None
            self._quality_probe_format = None
            self._url_dirty = True
            return None
        self._last_valid_url = sanitized
        self._url_dirty = False
        return sanitized

    def _url_key(self, url):
        try:
            parsed = urlparse(url)
        except Exception:
            return url
        if not parsed.scheme or not parsed.netloc:
            return url
        return parsed._replace(scheme=parsed.scheme.lower(), netloc=parsed.netloc.lower(), fragment="").geturl()

    def _is_youtube_url(self, url):
        try:
            parsed = urlparse(url or "")
            host = (parsed.netloc or "").lower()
        except Exception:
            return False
        return host.endswith("youtube.com") or host.endswith("youtu.be") or host.endswith("youtube-nocookie.com")

    def _validate_proxy(self, proxy_value):
        proxy_value = (proxy_value or "").strip()
        if not proxy_value:
            return True
        parsed = urlparse(proxy_value)
        if parsed.scheme and parsed.netloc:
            return True
        return False

    def _get_proxy(self):
        proxy = self.config.get("proxy", "")
        if not proxy:
            return None
        proxy = proxy.strip()
        if not proxy:
            return None
        return proxy

    def _apply_proxy_opts(self, opts):
        proxy = self._get_proxy()
        if proxy:
            opts["proxy"] = proxy

    def _normalize_cookies_from_browser(self, value):
        if not value:
            return None
        value = str(value).strip()
        if not value:
            return None
        parts = value.split(":")
        if len(parts) == 1:
            return (parts[0],)
        return tuple(parts[:4])

    def _cookies_spec_to_cli(self, spec):
        if not spec:
            return None
        if isinstance(spec, (tuple, list)):
            return ":".join([str(p) for p in spec if p])
        return str(spec)

    def _extractor_args_to_dict(self, extractor_args):
        if not extractor_args:
            return None
        raw = str(extractor_args).strip()
        if not raw:
            return None
        result = {}
        for section in raw.split(";"):
            section = section.strip()
            if not section or ":" not in section:
                continue
            extractor, args_blob = section.split(":", 1)
            extractor = extractor.strip()
            if not extractor or not args_blob:
                continue
            for pair in args_blob.split(","):
                pair = pair.strip()
                if not pair or "=" not in pair:
                    continue
                key, value = pair.split("=", 1)
                key = key.strip()
                value = value.strip()
                if not key or not value:
                    continue
                result.setdefault(extractor, {}).setdefault(key, []).append(value)
        return result or None

    def _external_downloader_opts(self, url=None):
        opts = {
            "retries": 3,
            "fragment_retries": 3,
            "skip_unavailable_fragments": True,
        }
        self._apply_proxy_opts(opts)
        return opts

    def _js_runtime_to_dict(self, js_runtime):
        if not js_runtime:
            return None
        raw = str(js_runtime).strip()
        if not raw:
            return None
        runtime, sep, path = raw.partition(":")
        runtime = runtime.strip()
        path = path.strip()
        if not runtime:
            return None
        if not path:
            return {runtime: {}}
        return {runtime: {"path": path}}

    def prompt_quality_change(self, selected_quality):
        if self.config.get('disable_warnings', False):
            return True
        if selected_quality != "BEST QUALITY":
            result = messagebox.askyesno(
                "Quality Format Change",
                "The provided media URL might not support other formats. Do you want to proceed?")
            if not result:
                self.selected_quality.set(self._prev_quality)
                self.update_quality_buttons()
                return False
        return True


    def _strip_ansi(self, text):
        if not text:
            return ""
        return re.sub(r"\x1b\[[0-9;]*m", "", str(text))

    def _is_audio_format(self, fmt):
        audio_exts = {
            "mp3", "wav", "m4a", "aac", "opus", "ogg", "flac", "alac", "wma", "aiff"
        }
        return str(fmt or "").strip().lower() in audio_exts or str(fmt or "").strip().lower() == "audio"

    def _clean_error_message(self, text):
        text = self._strip_ansi(text)
        text = text.replace("ERROR: ", "")
        text = re.sub(r"Use --list-formats.*", "", text, flags=re.IGNORECASE).strip()
        return text or "Unknown error"

    def _summarize_error_for_console(self, text):
        cleaned = self._clean_error_message(text)
        for noise in [
            "please report this issue",
            "Confirm you are on the latest version",
            "Use --list-formats",
            "See  https://github.com/yt-dlp/yt-dlp/issues",
        ]:
            cleaned = cleaned.replace(noise, "").strip()
        return cleaned or "Download failed."

    def _run_yt_dlp_subprocess(self, args, progress_cb=None):
        last_error = None
        proc = None
        try:
            try:
                args = [str(a) for a in args]
            except Exception:
                args = [str(a) for a in list(args)]
            creationflags = subprocess.CREATE_NO_WINDOW if self._is_windows() else 0
            startupinfo = None
            if self._is_windows():
                startupinfo = subprocess.STARTUPINFO()
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            proc = subprocess.Popen(
                args,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True,
                creationflags=creationflags,
                startupinfo=startupinfo
            )
            self._register_active_proc(proc)
            for line in iter(proc.stdout.readline, ""):
                if self.abort_event.is_set():
                    break
                if line:
                    if "ERROR:" in line:
                        last_error = line.strip()
                    if progress_cb:
                        progress_cb(line)
            try:
                if proc.stdout:
                    proc.stdout.close()
            except Exception:
                pass
            if self.abort_event.is_set():
                try:
                    if proc.poll() is None:
                        if self._is_windows():
                            subprocess.run(
                                ["taskkill", "/F", "/T", "/PID", str(proc.pid)],
                                stdout=subprocess.DEVNULL,
                                stderr=subprocess.DEVNULL,
                                creationflags=creationflags,
                                startupinfo=startupinfo
                            )
                        else:
                            proc.kill()
                except Exception:
                    pass
                return False, last_error or "Aborted"
            code = proc.wait()
            return code == 0, last_error
        finally:
            try:
                self._unregister_active_proc(proc)
            except Exception:
                pass

    def _run_yt_dlp_inprocess(self, ydl_opts, url, progress_cb=None):
        last_error = None

        class _Logger:
            def debug(self, _msg):
                pass

            def warning(self, _msg):
                pass

            def error(self, msg):
                nonlocal last_error
                if msg:
                    last_error = str(msg)

        def hook(d):
            if self.abort_event.is_set():
                raise DownloadCancelled()
            if not progress_cb:
                return
            if d.get("status") == "downloading":
                percent = None
                percent_str = str(d.get("_percent_str", "")).strip()
                if percent_str:
                    match = re.search(r"(\\d+(?:\\.\\d+)?)%", percent_str)
                    if match:
                        try:
                            percent = float(match.group(1))
                        except Exception:
                            percent = None
                if percent is None:
                    total = d.get("total_bytes") or d.get("total_bytes_estimate")
                    done = d.get("downloaded_bytes")
                    if total and done:
                        try:
                            percent = float(done) * 100.0 / float(total)
                        except Exception:
                            percent = None
                if percent is not None:
                    try:
                        progress_cb(f"{percent:.1f}%")
                    except Exception:
                        pass

        try:
            opts = dict(ydl_opts or {})
            opts["logger"] = _Logger()
            hooks = list(opts.get("progress_hooks") or [])
            hooks.append(hook)
            opts["progress_hooks"] = hooks
            with YoutubeDL(opts) as ydl:
                result = ydl.download([url])
            if result:
                return False, last_error or "Download failed"
            return True, last_error
        except DownloadCancelled:
            return False, last_error or "Aborted"
        except Exception as e:
            if not last_error:
                last_error = str(e)
            return False, last_error

    def _run_yt_dlp(self, cmd, ydl_opts, url, progress_cb=None):
        if getattr(sys, 'frozen', False):
            return self._run_yt_dlp_inprocess(ydl_opts, url, progress_cb=progress_cb)
        return self._run_yt_dlp_subprocess(cmd, progress_cb=progress_cb)

    def start_download(self):
        theme = self.theme
        fonts = self.fonts
        if self.progress and isinstance(self.progress, tk.Canvas):
            self._set_progress_style("normal")
            self._set_progress_value(0)
            self._set_progress_text("0%")
        if self.console:
            self.console.delete(1.0, tk.END)
        self._drain_queue(self.progress_queue)
        self.abort_event.clear()
        self._abort_notified = False
        self._percent_started = False

        if self.config.get('allow_batch_downloads', False):
            self.downloading = True
            self.set_controls_state(False)
            urls = []
            if hasattr(self, 'url_text') and self.url_text.winfo_exists():
                urls = [u.strip() for u in self.url_text.get("1.0", tk.END).splitlines() if u.strip()]
            max_lines = self._normalize_batch_line_limit(self.config.get('max_batch_lines'))
            if len(urls) > max_lines:
                urls = urls[:max_lines]
            if not urls:
                messagebox.showerror("Error", "Please enter one or more media URLs")
                self.downloading = False
                self.set_controls_state(True)
                return

            format_choice = self.selected_format.get()
            choice_label = self.selected_other_format.get().strip() if hasattr(self, "selected_other_format") else ""
            if not format_choice or choice_label in ("Choose format", "Loading formats...", "Load others"):
                messagebox.showerror("Error", "Please select a format")
                self.downloading = False
                self.set_controls_state(True)
                if hasattr(self, "download_button"):
                    self.run_on_ui_thread(self.download_button.config, state=tk.NORMAL)
                return
            quality_choice = self.selected_quality.get()
            if self._is_audio_format(format_choice):
                quality_choice = "BEST QUALITY"

            if self.config.get('preserve_batch_links', False):
                if hasattr(self, 'url_text') and self.url_text.winfo_exists():
                    self._batch_saved_links = self.url_text.get("1.0", tk.END).rstrip("\n")
            else:
                self._batch_saved_links = None

            if hasattr(self, "url_text_frame") and self.url_text_frame.winfo_exists():
                self.root.update_idletasks()
                self._batch_url_box_height = max(1, self.url_text_frame.winfo_height())
            else:
                self._batch_url_box_height = 360

            if hasattr(self, 'url_text') and self.url_text.winfo_exists():
                self.url_text.destroy()
            if hasattr(self, 'url_card') and self.url_card.winfo_exists():
                self.url_card.destroy()
            self.batch_progress_frame = tk.Frame(self.main_frame, bg=theme["surface"], highlightthickness=1, highlightbackground=theme["border"])
            self.batch_progress_frame.grid(row=0, column=0, columnspan=2, sticky="nsew", pady=(0, 12))
            header = tk.Frame(self.batch_progress_frame, bg=theme["surface"], padx=12, pady=8)
            header.pack(fill="x")
            header_left = tk.Label(header, text="Batch queue", font=fonts["label"], bg=theme["surface"], fg=theme["text"])
            header_left.pack(side="left")
            self.batch_summary_label = tk.Label(header, text="Preparing...", font=fonts["caption"], bg=theme["surface"], fg=theme["muted"])
            self.batch_summary_label.pack(side="right")
            target_height = max(200, getattr(self, "_batch_url_box_height", 360))
            canvas = tk.Canvas(self.batch_progress_frame, bg=theme["surface"], highlightthickness=0, height=target_height)
            scrollable_frame = tk.Frame(canvas, bg=theme["surface"])
            window_id = canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.pack(side="left", fill="both", expand=True)

            def _resize_canvas_window():
                canvas.itemconfigure(window_id, width=canvas.winfo_width())
            def _apply_scrollregion():
                bbox = canvas.bbox("all")
                if not bbox:
                    return
                x1, y1, x2, y2 = bbox
                canvas_h = max(1, canvas.winfo_height())
                height = max(y2 - y1, canvas_h)
                canvas.configure(scrollregion=(0, 0, x2 - x1, height))
                if (y2 - y1) <= canvas_h:
                    canvas.yview_moveto(0)
            def _schedule_scrollregion(_event=None):
                if getattr(canvas, "_scrollregion_job", None):
                    canvas.after_cancel(canvas._scrollregion_job)
                canvas._scrollregion_job = self._after(120, _apply_scrollregion, widget=canvas)
            def _schedule_canvas_resize(_event=None):
                if getattr(canvas, "_resize_job", None):
                    canvas.after_cancel(canvas._resize_job)
                canvas._resize_job = self._after(80, lambda: (_resize_canvas_window(), _schedule_scrollregion()), widget=canvas)
            scrollable_frame.bind("<Configure>", _schedule_scrollregion)
            canvas.bind("<Configure>", _schedule_canvas_resize)
            _resize_canvas_window()
            def _on_mousewheel(event):
                if event.delta:
                    canvas.yview_scroll(int(-1*(event.delta/120)), "units")
                elif event.num == 5:
                    canvas.yview_scroll(1, "units")
                elif event.num == 4:
                    canvas.yview_scroll(-1, "units")
                return "break"
            canvas.bind("<MouseWheel>", _on_mousewheel)
            canvas.bind("<Button-4>", _on_mousewheel)
            canvas.bind("<Button-5>", _on_mousewheel)
            scrollable_frame.bind("<MouseWheel>", _on_mousewheel)
            scrollable_frame.bind("<Button-4>", _on_mousewheel)
            scrollable_frame.bind("<Button-5>", _on_mousewheel)
            def _on_batch_wheel(event):
                if not self.batch_progress_frame or not self.batch_progress_frame.winfo_exists():
                    return
                if not self._is_descendant(event.widget, self.batch_progress_frame):
                    return
                return _on_mousewheel(event)
            self.root.bind_all("<MouseWheel>", _on_batch_wheel)
            self.root.bind_all("<Button-4>", _on_batch_wheel)
            self.root.bind_all("<Button-5>", _on_batch_wheel)
            self._batch_wheel_bound = True
            self.batch_link_widgets = []
            self.batch_progress_vars = []
            self.batch_status_labels = []
            self.batch_already_downloaded = []
            self.batch_progress_bars = []

            for idx, url in enumerate(urls):
                row = tk.Frame(scrollable_frame, bg=theme["surface"])
                row.pack(fill=tk.X, pady=1)
                row.grid_columnconfigure(1, weight=1)
                row.grid_columnconfigure(2, minsize=120)
                row.grid_columnconfigure(3, minsize=110)
                idx_label = tk.Label(
                    row,
                    text=f"{idx + 1}.",
                    font=fonts["caption"],
                    bg=theme["surface"],
                    fg=theme["muted"],
                    width=3,
                    anchor="e"
                )
                idx_label.grid(row=0, column=0, padx=(2, 4), sticky="e")
                display_url = url
                display_url = re.sub(r'^https?://(www\.)?', '', display_url, flags=re.IGNORECASE)
                link_label = tk.Label(row, text=display_url, font=fonts["mono"], bg=theme["surface_alt"], fg=theme["text"], anchor="w")
                link_label.grid(row=0, column=1, padx=(2, 2), sticky="ew")
                progress_var = tk.DoubleVar(value=0)
                progress_bar = ttk.Progressbar(row, variable=progress_var, maximum=100, length=110, style="Modern.Small.Disabled.Horizontal.TProgressbar")
                progress_bar.grid(row=0, column=2, padx=(0, 2), sticky="w")
                status_label = tk.Label(row, text="Checking...", font=fonts["caption"], bg=theme["surface"], fg=theme["muted"], width=12)
                status_label.grid(row=0, column=3, padx=(0, 2), sticky="w")
                self.batch_link_widgets.append((link_label, progress_bar))
                self.batch_progress_vars.append(progress_var)
                self.batch_status_labels.append(status_label)
                self.batch_already_downloaded.append(False)
                self.batch_progress_bars.append(progress_bar)

            self.root.update_idletasks()
            if len(urls) > 10:
                canvas.config(height=target_height)
            else:
                canvas.config(height=min(32 * len(urls) + 10, target_height))

            def check_links():
                def fast_check():
                    downloads_dir = self.config.get('download_location', self._default_download_dir())
                    media_dl_dir = downloads_dir
                    os.makedirs(media_dl_dir, exist_ok=True)
                    valid_links = [None] * len(urls)
                    safe_bases = [None] * len(urls)
                    redownload_indices = []
                    seen_links = set()

                    ydl_opts = {
                        'quiet': True,
                        'skip_download': True,
                        'no_warnings': True,
                        'simulate': True,
                    }
                    status_flags = [None] * len(urls)

                    def update_status(idx, text, fg):
                        self.run_on_ui_thread(self.batch_status_labels[idx].config, text=text, fg=fg)

                    def set_progress_active(idx):
                        bar = self.batch_progress_bars[idx]
                        if bar:
                            bar.config(style="Modern.Small.Horizontal.TProgressbar")
                        self.batch_progress_vars[idx].set(0)

                    def set_progress_inactive(idx):
                        bar = self.batch_progress_bars[idx]
                        if bar:
                            bar.config(style="Modern.Small.Disabled.Horizontal.TProgressbar")
                        self.batch_progress_vars[idx].set(100)

                    def set_progress_done(idx):
                        bar = self.batch_progress_bars[idx]
                        if bar:
                            bar.config(style="Modern.Small.Complete.Horizontal.TProgressbar")
                        self.batch_progress_vars[idx].set(100)

                    def check_one(idx, url):
                        if self.abort_event.is_set():
                            return
                        sanitized_url = self.validate_url(url)
                        if not sanitized_url:
                            update_status(idx, "Invalid", theme["danger"])
                            self.run_on_ui_thread(set_progress_inactive, idx)
                            status_flags[idx] = "invalid"
                            return
                        url_key = self._url_key(sanitized_url)
                        if url_key in seen_links:
                            update_status(idx, "Duplicate", theme["muted"])
                            self.run_on_ui_thread(set_progress_inactive, idx)
                            status_flags[idx] = "duplicate"
                            return
                        seen_links.add(url_key)
                        try:
                            with YoutubeDL(ydl_opts) as ydl:
                                info_dict = ydl.extract_info(sanitized_url, download=False, process=False)
                            if self.abort_event.is_set():
                                return
                            title = info_dict.get('title', '')
                            media_id = info_dict.get('id')
                            safe_base = self._build_base_filename(title, media_id)
                            safe_bases[idx] = safe_base
                            output_path_final = self._find_existing_output_path(media_dl_dir, safe_base, format_choice)
                            if output_path_final:
                                update_status(idx, "File Exists", theme["success"])
                                self.run_on_ui_thread(set_progress_inactive, idx)
                                self.batch_already_downloaded[idx] = True
                                status_flags[idx] = "exists"
                                valid_links[idx] = None
                                if not self.config.get('disable_already_downloaded_prompts', False):
                                    redownload_indices.append(idx)
                            else:
                                update_status(idx, "Starting...", theme["success"])
                                self.run_on_ui_thread(set_progress_active, idx)
                                status_flags[idx] = "valid"
                                valid_links[idx] = sanitized_url
                        except Exception:
                            update_status(idx, "Invalid", theme["danger"])
                            self.run_on_ui_thread(set_progress_inactive, idx)
                            status_flags[idx] = "invalid"

                    threads = []
                    max_threads = min(len(urls), self._normalize_batch_concurrency(self.config.get('batch_concurrency')))
                    from queue import Queue
                    q = Queue()
                    for idx, url in enumerate(urls):
                        q.put((idx, url))
                    def worker():
                        while not q.empty():
                            try:
                                idx, url = q.get_nowait()
                            except Exception:
                                break
                            check_one(idx, url)
                            q.task_done()
                    for _ in range(max_threads):
                        t = threading.Thread(target=worker)
                        t.start()
                        threads.append(t)
                    q.join()
                    for t in threads:
                        t.join()

                    if getattr(self, "batch_summary_label", None):
                        counts = {
                            "valid": sum(1 for v in status_flags if v == "valid"),
                            "invalid": sum(1 for v in status_flags if v == "invalid"),
                            "duplicate": sum(1 for v in status_flags if v == "duplicate"),
                            "exists": sum(1 for v in status_flags if v == "exists"),
                        }
                        total = len(urls)
                        summary = (
                            f"Total: {total}  "
                            f"Valid: {counts['valid']}  "
                            f"Invalid: {counts['invalid']}  "
                            f"Duplicate: {counts['duplicate']}  "
                            f"Exists: {counts['exists']}"
                        )
                        self.run_on_ui_thread(self.batch_summary_label.config, text=summary)

                    def prompt_redownloads(redownload_indices, callback):
                        if self.abort_event.is_set():
                            callback([])
                            return
                        if not redownload_indices:
                            callback([])
                            return
                        redownload_links = []
                        def ask_next(i):
                            if self.abort_event.is_set():
                                callback([])
                                return
                            if i >= len(redownload_indices):
                                callback(redownload_links)
                                return
                            idx = redownload_indices[i]
                            link = urls[idx]
                            display_url = re.sub(r'^https?://(www\.)?', '', link, flags=re.IGNORECASE)
                            output_path_final = self._find_existing_output_path(media_dl_dir, safe_bases[idx], format_choice) if safe_bases[idx] else None
                            msg = f"File already exists:\n{self._display_path(output_path_final)}\n({display_url})\nDo you want to re-download it?"
                            res = messagebox.askyesno("Already Downloaded", msg)
                            if res:
                                if self.abort_event.is_set():
                                    callback([])
                                    return
                                self.batch_status_labels[idx].config(text="Downloading", fg=theme["accent"])
                                bar = self.batch_progress_bars[idx]
                                if bar:
                                    bar.config(style="Modern.Small.Horizontal.TProgressbar")
                                self.batch_progress_vars[idx].set(0)
                                redownload_links.append(idx)
                            else:
                                self.batch_status_labels[idx].config(text="Skipped", fg=theme["muted"])
                                bar = self.batch_progress_bars[idx]
                                if bar:
                                    bar.config(style="Modern.Small.Disabled.Horizontal.TProgressbar")
                                self.batch_progress_vars[idx].set(100)
                            ask_next(i+1)
                        ask_next(0)

                    def start_batch_downloads(redownload_links):
                        if self.abort_event.is_set():
                            self.downloading = False
                            self.set_controls_state(True)
                            return
                        self.downloading = True
                        self.set_controls_state(False)
                        self.append_console("Batch download started...\n")
                        self._batch_download_dir = media_dl_dir
                        self._batch_all_done = False
                        self._batch_done_set = set()
                        batch_jobs_lock = threading.Lock()
                        batch_jobs_remaining = 0

                        def finalize_batch():
                            if self._batch_all_done:
                                return
                            self.downloading = False
                            self.set_controls_state(True)
                            self._show_reset_button()
                            self._batch_all_done = True
                            self.append_console("Batch download finished.\n")

                        def mark_batch_done():
                            nonlocal batch_jobs_remaining
                            with batch_jobs_lock:
                                if batch_jobs_remaining <= 0:
                                    return
                                batch_jobs_remaining -= 1
                                if batch_jobs_remaining == 0:
                                    self.run_on_ui_thread(finalize_batch)

                        def batch_download_worker(idx, url, format_choice, quality_choice, safe_base):
                            if not url or not safe_base:
                                mark_batch_done()
                                return
                            max_attempts = self._normalize_batch_retries(self.config.get('batch_retry_attempts'))
                            def progress_hook(d):
                                if self.abort_event.is_set():
                                    raise DownloadCancelled()
                                if d['status'] == 'downloading':
                                    percent_str = d.get('_percent_str', '').strip()
                                    try:
                                        percent = float(percent_str.split('%')[0].strip()[-4:])
                                    except Exception:
                                        percent = 0
                                    self.run_on_ui_thread(self.batch_progress_vars[idx].set, percent)
                                    self.run_on_ui_thread(self.batch_status_labels[idx].config, text=f"{int(percent)}%", fg=theme["accent"])
                                elif d['status'] == 'finished':
                                    self.run_on_ui_thread(self.batch_progress_vars[idx].set, 100)
                                    self.run_on_ui_thread(set_progress_done, idx)
                                    self.run_on_ui_thread(self.batch_status_labels[idx].config, text="Done", fg=theme["success"])
                                    output_ext = self._format_choice_output_ext(format_choice)
                                    final_filename = f"{safe_base}.{output_ext}" if output_ext else f"{safe_base}.audio"
                                    final_path = os.path.join(media_dl_dir, final_filename)
                                    if final_path not in self._batch_done_set:
                                        self._batch_done_set.add(final_path)
                            output_ext = self._format_choice_output_ext(format_choice)
                            temp_base = f"{safe_base}__{(output_ext or 'audio')}_TEMP"
                            output_template = os.path.join(media_dl_dir, f'{temp_base}.%(ext)s')
                            self._register_active_temp(media_dl_dir, temp_base)

                            quality_format = {
                                "BEST QUALITY": "bestvideo+bestaudio/best",
                                "144p": "worstvideo[height<=144]+bestaudio/best[height<=144]",
                                "240p": "worstvideo[height<=240]+bestaudio/best[height<=240]",
                                "360p": "worstvideo[height<=360]+bestaudio/best[height<=360]",
                                "480p": "worstvideo[height<=480]+bestaudio/best[height<=480]",
                                "720p": "bestvideo[height<=720]+bestaudio/best[height<=720]",
                                "1080p": "bestvideo[height<=1080]+bestaudio/best[height<=1080]",
                                "1440p": "bestvideo[height<=1440]+bestaudio/best[height<=1440]",
                                "2160p": "bestvideo[height<=2160]+bestaudio/best[height<=2160]",
                                "2160p (4k)": "bestvideo[height<=2160]+bestaudio/best[height<=2160]",
                            }
                            if format_choice == "mp4":
                                quality_format = {
                                    "BEST QUALITY": "bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]",
                                    "144p": "bestvideo[ext=mp4][height<=144]+bestaudio[ext=m4a]/best[ext=mp4][height<=144]/best[ext=mp4]",
                                    "240p": "bestvideo[ext=mp4][height<=240]+bestaudio[ext=m4a]/best[ext=mp4][height<=240]/best[ext=mp4]",
                                    "360p": "bestvideo[ext=mp4][height<=360]+bestaudio[ext=m4a]/best[ext=mp4][height<=360]/best[ext=mp4]",
                                    "480p": "bestvideo[ext=mp4][height<=480]+bestaudio[ext=m4a]/best[ext=mp4][height<=480]/best[ext=mp4]",
                                    "720p": "bestvideo[ext=mp4][height<=720]+bestaudio[ext=m4a]/best[ext=mp4][height<=720]/best[ext=mp4]",
                                    "1080p": "bestvideo[ext=mp4][height<=1080]+bestaudio[ext=m4a]/best[ext=mp4][height<=1080]/best[ext=mp4]",
                                    "1440p": "bestvideo[ext=mp4][height<=1440]+bestaudio[ext=m4a]/best[ext=mp4][height<=1440]/best[ext=mp4]",
                                    "2160p": "bestvideo[ext=mp4][height<=2160]+bestaudio[ext=m4a]/best[ext=mp4][height<=2160]/best[ext=mp4]",
                                    "2160p (4k)": "bestvideo[ext=mp4][height<=2160]+bestaudio[ext=m4a]/best[ext=mp4][height<=2160]/best[ext=mp4]",
                                }

                            windows_hide_flag = self._is_windows()
                            is_audio = self._is_audio_format(format_choice)
                            ffmpeg_location = self._resolve_ffmpeg_location()
                            js_runtime = self._resolve_js_runtime()
                            cookies_browser = str(self.config.get("cookies_browser", "") or "").strip()
                            cookies_spec = self._normalize_cookies_from_browser(cookies_browser) if self.config.get("cookies_use", False) else None
                            enable_fallbacks = bool(self.config.get('enable_batch_fallbacks', False))

                            format_attempts = [(quality_format.get(quality_choice, 'best'), False)]
                            video_ext = self._format_choice_output_ext(format_choice)
                            is_video_container = format_choice in ("mp4", "mov", "video")
                            if not is_audio and enable_fallbacks:
                                compat_fmt = "bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]" if format_choice == "mp4" else "bestvideo+bestaudio/best"
                                best_fmt = "bestvideo+bestaudio/best"
                                if compat_fmt not in [fmt for fmt, _ in format_attempts]:
                                    format_attempts.append((compat_fmt, False))
                                if best_fmt not in [fmt for fmt, _ in format_attempts]:
                                    format_attempts.append((best_fmt, False))
                                if ffmpeg_location and is_video_container:
                                    format_attempts.append((best_fmt, True))

                            def progress_cb(line):
                                if self.abort_event.is_set():
                                    return
                                match = re.search(r"(\\d+(?:\\.\\d+)?)%", line)
                                if match:
                                    try:
                                        val = float(match.group(1))
                                    except Exception:
                                        val = 0.0
                                    self.run_on_ui_thread(self.batch_progress_vars[idx].set, val)
                                    self.run_on_ui_thread(self.batch_status_labels[idx].config, text=f"{int(val)}%", fg=theme["accent"])

                            def build_cmd(format_selector, force_transcode=False):
                                cmd = [sys.executable, "-m", "yt_dlp", "--newline", "-N", "8", "-o", output_template]
                                ydl_opts = {
                                    "outtmpl": output_template,
                                    "concurrent_fragment_downloads": 8,
                                    "quiet": True,
                                    "no_warnings": True,
                                }
                                proxy = str(self.config.get("proxy", "") or "").strip()
                                if proxy:
                                    cmd += ["--proxy", proxy]
                                    ydl_opts["proxy"] = proxy
                                if ffmpeg_location:
                                    cmd += ["--ffmpeg-location", ffmpeg_location]
                                    ydl_opts["ffmpeg_location"] = ffmpeg_location
                                if js_runtime:
                                    cmd += ["--no-js-runtimes", "--js-runtimes", js_runtime]
                                    ydl_opts["no_js_runtimes"] = True
                                    js_runtime_dict = self._js_runtime_to_dict(js_runtime)
                                    if js_runtime_dict:
                                        ydl_opts["js_runtimes"] = js_runtime_dict
                                if cookies_spec:
                                    cookies_arg = self._cookies_spec_to_cli(cookies_spec)
                                    if cookies_arg:
                                        cmd += ["--cookies-from-browser", cookies_arg]
                                    ydl_opts["cookiesfrombrowser"] = cookies_spec
                                if is_audio:
                                    ydl_opts["format"] = "bestaudio/best"
                                    if format_choice == "audio":
                                        cmd += ["-f", "bestaudio/best"]
                                    else:
                                        audio_ext = self._format_choice_output_ext(format_choice) or "mp3"
                                        cmd += ["-f", "bestaudio/best", "-x", "--audio-format", audio_ext]
                                        ydl_opts["postprocessors"] = [{
                                            "key": "FFmpegExtractAudio",
                                            "preferredcodec": audio_ext,
                                        }]
                                else:
                                    cmd += ["-f", format_selector]
                                    ydl_opts["format"] = format_selector
                                    if is_video_container:
                                        cmd += ["--merge-output-format", video_ext]
                                        ydl_opts["merge_output_format"] = video_ext
                                    if force_transcode or format_choice == "mov":
                                        cmd += ["--recode-video", video_ext]
                                        ydl_opts["recodevideo"] = video_ext
                                cmd.append(url)
                                return cmd, ydl_opts

                            try:
                                for fmt_selector, force_transcode in format_attempts:
                                    for attempt in range(1, max_attempts + 1):
                                        if self.abort_event.is_set():
                                            raise DownloadCancelled()
                                        if attempt > 1:
                                            self.run_on_ui_thread(self.batch_progress_vars[idx].set, 0)
                                            self.run_on_ui_thread(
                                                self.batch_status_labels[idx].config,
                                                text=f"Retry {attempt}/{max_attempts}",
                                                fg=theme["muted"]
                                            )
                                        try:
                                            cmd, ydl_opts = build_cmd(fmt_selector, force_transcode=force_transcode)
                                            success, _err = self._run_yt_dlp(cmd, ydl_opts, url, progress_cb=progress_cb)
                                            if self.abort_event.is_set():
                                                raise DownloadCancelled()
                                            if not success:
                                                raise Exception("Download failed")
                                            temp_files = [f for f in os.listdir(media_dl_dir) if f.startswith(temp_base + ".") and '_TEMP.' in f]
                                            for temp_file in temp_files:
                                                temp_path = os.path.join(media_dl_dir, temp_file)
                                                if output_ext:
                                                    final_filename = f"{safe_base}.{output_ext}"
                                                else:
                                                    ext = self._resolve_output_ext_from_temp(temp_file)
                                                    final_filename = f"{safe_base}.{ext}" if ext else f"{safe_base}.audio"
                                                final_path = os.path.join(media_dl_dir, final_filename)
                                                if os.path.exists(final_path):
                                                    try:
                                                        os.remove(final_path)
                                                    except Exception:
                                                        pass
                                                os.rename(temp_path, final_path)
                                            self.run_on_ui_thread(set_progress_done, idx)
                                            self.run_on_ui_thread(self.batch_status_labels[idx].config, text="Done", fg=theme["success"])
                                            return
                                        except DownloadCancelled:
                                            raise
                                        except Exception:
                                            if attempt < max_attempts:
                                                self._cleanup_temp_files(media_dl_dir, temp_base, max_attempts=3, delay=0.1)
                                                continue
                                            break
                                self.run_on_ui_thread(self.batch_status_labels[idx].config, text="Error", fg=theme["danger"])
                                self.append_console(f"[ERROR] {url}\n")
                            except DownloadCancelled:
                                self.run_on_ui_thread(self.batch_status_labels[idx].config, text="Aborted", fg=theme["muted"])
                                self._cleanup_temp_files(media_dl_dir, temp_base, max_attempts=60, delay=0.25)
                            finally:
                                self._unregister_active_temp(media_dl_dir, temp_base)
                                mark_batch_done()

                        def enqueue_jobs():
                            for idx, url in enumerate(valid_links):
                                safe_base = safe_bases[idx]
                                if url and safe_base:
                                    jobs.put((idx, url, safe_base))
                            for idx in redownload_links:
                                safe_base = safe_bases[idx]
                                link = urls[idx]
                                if safe_base:
                                    jobs.put((idx, link, safe_base))

                        def worker():
                            while not self.abort_event.is_set():
                                try:
                                    idx, url, safe_base = jobs.get_nowait()
                                except Exception:
                                    break
                                batch_download_worker(idx, url, format_choice, quality_choice, safe_base)
                                jobs.task_done()

                        jobs = queue.Queue()
                        enqueue_jobs()
                        batch_jobs_remaining = jobs.qsize()
                        if batch_jobs_remaining == 0:
                            finalize_batch()
                            return
                        worker_count = min(self._normalize_batch_concurrency(self.config.get('batch_concurrency')), batch_jobs_remaining)
                        for _ in range(max(1, worker_count)):
                            t = threading.Thread(target=worker, daemon=True)
                            t.start()

                    self.run_on_ui_thread(prompt_redownloads, redownload_indices, start_batch_downloads)
                threading.Thread(target=fast_check, daemon=True).start()
            check_links()
        else:
            url = self.url_entry.get().strip()
            if not url:
                messagebox.showerror("Error", "Please enter a media URL")
                return

            sanitized_url = self.validate_url(url, show_error=True)
            if not sanitized_url:
                self.downloading = False
                self.set_controls_state(True)
                self.run_on_ui_thread(self.download_button.config, state=tk.NORMAL)
                return
            format_choice = self.selected_format.get()
            choice_label = self.selected_other_format.get().strip() if hasattr(self, "selected_other_format") else ""
            if not format_choice or choice_label in ("Choose format", "Loading formats...", "Load others"):
                messagebox.showerror("Error", "Please select a format")
                return
            quality_choice = self.selected_quality.get()
            if self._is_audio_format(format_choice):
                quality_choice = "BEST QUALITY"
            self._process_total = 2
            self._process_done = 0
            self._download_finished = False
            self.append_console("Stages: 2 (download + post-processing)\n")
            self.downloading = True
            self.set_controls_state(False)
            self._schedule_progress_poll()
            def check_and_download():
                if self.abort_event.is_set():
                    return
                self.append_console("Checking media info...\n")
                downloads_dir = self.config.get('download_location', self._default_download_dir())
                media_dl_dir = downloads_dir
                os.makedirs(media_dl_dir, exist_ok=True)
                try:
                    ydl_opts = {
                        'quiet': True,
                        'skip_download': True,
                        'no_warnings': True,
                        'simulate': True,
                    }
                    with YoutubeDL(ydl_opts) as ydl:
                        info_dict = ydl.extract_info(sanitized_url, download=False)
                    if self.abort_event.is_set():
                        return
                    title = info_dict.get('title', '')
                    media_id = info_dict.get('id')
                    safe_base = self._build_base_filename(title, media_id)
                    output_ext = self._format_choice_output_ext(format_choice)
                    final_filename = f"{safe_base}.{output_ext}" if output_ext else f"{safe_base}.audio"
                    output_path_final = self._find_existing_output_path(media_dl_dir, safe_base, format_choice)
                    if output_path_final:
                        if self.abort_event.is_set():
                            return
                        if not self.config.get('disable_already_downloaded_prompts', False):
                            self.append_console(f"File already exists: {self._display_path(output_path_final)}\n")
                            def ask_redownload():
                                if self.abort_event.is_set():
                                    return
                                if messagebox.askyesno("File Exists", f"File already exists:\n{self._display_path(output_path_final)}\nDo you want to download it again?"):
                                    if self.abort_event.is_set():
                                        return
                                    self.download_thread = threading.Thread(target=self.download_video, args=(sanitized_url, format_choice, quality_choice, safe_base))
                                    self.download_thread.start()
                                else:
                                    self._download_finished = True
                                    self._process_done = self._process_total
                                    self.append_console("Download finished (already exists).\n")
                                    self.mark_progress_complete()
                                    self.downloading = False
                                    self.set_controls_state(True)
                                    self.download_button.config(state=tk.NORMAL)
                            self.run_on_ui_thread(ask_redownload)
                            return
                        else:
                            self._download_finished = True
                            self._process_done = self._process_total
                            self.append_console("Download finished (already exists).\n")
                            self.mark_progress_complete()
                            self.downloading = False
                            self.set_controls_state(True)
                            self.run_on_ui_thread(self.download_button.config, state=tk.NORMAL)
                            return
                except Exception as e:
                    if self.abort_event.is_set():
                        return
                    self.append_console("Failed to retrieve media info!\n")
                    self.run_on_ui_thread(messagebox.showerror, "Error", f"Failed to retrieve media info: {e}")
                    self.downloading = False
                    self.set_controls_state(True)
                    self.run_on_ui_thread(self.download_button.config, state=tk.NORMAL)
                    return
                if self.abort_event.is_set():
                    return
                self.download_thread = threading.Thread(target=self.download_video, args=(sanitized_url, format_choice, quality_choice, safe_base))
                self.download_thread.start()

            threading.Thread(target=check_and_download, daemon=True).start()

    def abort(self):
        if not self.downloading:
            return
        self.abort_event.set()
        self._drain_queue(self.progress_queue)
        if self.console:
            self.run_on_ui_thread(self._clear_console_output)
        self.run_on_ui_thread(self._reset_progress_bar)
        if self.ydl:
            try:
                if hasattr(self.ydl, "abort"):
                    self.ydl.abort()
            except Exception:
                pass
        self._kill_active_procs()
        if not self._abort_notified:
            self._abort_notified = True
            self.append_console("Download aborted!\n")
        def finish_abort():
            thread = getattr(self, "download_thread", None)
            if thread and thread.is_alive():
                deadline = time.time() + 1.0
                while thread.is_alive() and time.time() < deadline:
                    thread.join(timeout=0.05)
            self._cleanup_partial_downloads(max_attempts=15, delay=0.05)
            self._cleanup_orphan_parts(self._active_download_dir, self._active_temp_base)
            self.downloading = False
            self.set_controls_state(True)
            self.run_on_ui_thread(self.update_format_buttons)
            self.run_on_ui_thread(self.update_quality_buttons)
            if self.config.get('allow_batch_downloads', False) and getattr(self, "batch_progress_frame", None):
                self.run_on_ui_thread(self._show_reset_button)
            def delayed_cleanup():
                time.sleep(1.0)
                self._cleanup_partial_downloads(max_attempts=60, delay=0.2)
                self._cleanup_orphan_parts(self._active_download_dir, self._active_temp_base)
            threading.Thread(target=delayed_cleanup, daemon=True).start()
        threading.Thread(target=finish_abort, daemon=True).start()

    def _on_window_close(self):
        self._closing = True
        if self.downloading:
            self.abort()
            self._after(50, lambda: self._check_close_after_abort(0))
        else:
            self.terminate_program()

    def _check_close_after_abort(self, attempts):
        if not self.downloading:
            self.terminate_program()
            return
        if attempts >= 200:
            self.terminate_program()
            return
        self._after(50, lambda: self._check_close_after_abort(attempts + 1))

    def terminate_program(self):
        self.status_polling = False
        try:
            self.root.destroy()
        except Exception:
            pass
        os._exit(0)

    def restart_program(self):
        try:
            if getattr(sys, 'frozen', False):
                args = [sys.executable] + sys.argv[1:]
                env = os.environ.copy()
                env.pop("_PYI_TEMP_PATH", None)
                env["PYINSTALLER_RESET_ENVIRONMENT"] = "1"
                subprocess.Popen(args, cwd=os.getcwd(), env=env)
            else:
                args = [sys.executable, os.path.abspath(sys.argv[0])] + sys.argv[1:]
                subprocess.Popen(args, cwd=os.getcwd())
        except Exception as e:
            logging.error(f"Failed to restart application: {e}")
        self.terminate_program()


    def download_video(self, url, format_choice, quality_choice, safe_base):
        self.append_console("Starting download...\n")
        downloads_dir = self.config.get('download_location', self._default_download_dir())
        media_dl_dir = downloads_dir
        os.makedirs(media_dl_dir, exist_ok=True)
        output_ext = self._format_choice_output_ext(format_choice)
        final_filename = f"{safe_base}.{output_ext}" if output_ext else f"{safe_base}.audio"
        output_path_final = os.path.join(media_dl_dir, final_filename)
        temp_base = f"{safe_base}__{(output_ext or 'audio')}_TEMP"
        output_template = os.path.join(media_dl_dir, f'{temp_base}.%(ext)s')
        self._register_active_temp(media_dl_dir, temp_base)
        self._active_download_dir = media_dl_dir
        self._active_temp_base = temp_base

        windows_hide_flag = self._is_windows()
        js_runtime = self._resolve_js_runtime()
        ffmpeg_location = self._resolve_ffmpeg_location()
        is_audio = self._is_audio_format(format_choice)
        is_youtube = self._is_youtube_url(url)

        quality_format = {
            "BEST QUALITY": "bestvideo+bestaudio/best",
            "144p": "bestvideo[height<=144]+bestaudio/best[height<=144]",
            "240p": "bestvideo[height<=240]+bestaudio/best[height<=240]",
            "360p": "bestvideo[height<=360]+bestaudio/best[height<=360]",
            "480p": "bestvideo[height<=480]+bestaudio/best[height<=480]",
            "720p": "bestvideo[height<=720]+bestaudio/best[height<=720]",
            "1080p": "bestvideo[height<=1080]+bestaudio/best[height<=1080]",
            "1440p": "bestvideo[height<=1440]+bestaudio/best[height<=1440]",
            "2160p": "bestvideo[height<=2160]+bestaudio/best[height<=2160]",
            "2160p (4k)": "bestvideo[height<=2160]+bestaudio/best[height<=2160]",
        }
        if format_choice == "mp4":
            quality_format = {
                "BEST QUALITY": "bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]",
                "144p": "bestvideo[ext=mp4][height<=144]+bestaudio[ext=m4a]/best[ext=mp4][height<=144]/best[ext=mp4]",
                "240p": "bestvideo[ext=mp4][height<=240]+bestaudio[ext=m4a]/best[ext=mp4][height<=240]/best[ext=mp4]",
                "360p": "bestvideo[ext=mp4][height<=360]+bestaudio[ext=m4a]/best[ext=mp4][height<=360]/best[ext=mp4]",
                "480p": "bestvideo[ext=mp4][height<=480]+bestaudio[ext=m4a]/best[ext=mp4][height<=480]/best[ext=mp4]",
                "720p": "bestvideo[ext=mp4][height<=720]+bestaudio[ext=m4a]/best[ext=mp4][height<=720]/best[ext=mp4]",
                "1080p": "bestvideo[ext=mp4][height<=1080]+bestaudio[ext=m4a]/best[ext=mp4][height<=1080]/best[ext=mp4]",
                "1440p": "bestvideo[ext=mp4][height<=1440]+bestaudio[ext=m4a]/best[ext=mp4][height<=1440]/best[ext=mp4]",
                "2160p": "bestvideo[ext=mp4][height<=2160]+bestaudio[ext=m4a]/best[ext=mp4][height<=2160]/best[ext=mp4]",
                "2160p (4k)": "bestvideo[ext=mp4][height<=2160]+bestaudio[ext=m4a]/best[ext=mp4][height<=2160]/best[ext=mp4]",
            }

        video_ext = self._format_choice_output_ext(format_choice)
        is_video_container = format_choice in ("mp4", "mov", "video")

        def build_cmd(format_selector, extractor_args=None, cookies_from_browser=None, force_transcode=False):
            cmd = [sys.executable, "-m", "yt_dlp", "--newline", "-N", "8", "-o", output_template]
            ydl_opts = {
                "outtmpl": output_template,
                "concurrent_fragment_downloads": 8,
                "quiet": True,
                "no_warnings": True,
            }
            proxy = str(self.config.get("proxy", "") or "").strip()
            if proxy:
                cmd += ["--proxy", proxy]
                ydl_opts["proxy"] = proxy
            if ffmpeg_location:
                cmd += ["--ffmpeg-location", ffmpeg_location]
                ydl_opts["ffmpeg_location"] = ffmpeg_location
            if js_runtime:
                cmd += ["--no-js-runtimes", "--js-runtimes", js_runtime]
                ydl_opts["no_js_runtimes"] = True
                js_runtime_dict = self._js_runtime_to_dict(js_runtime)
                if js_runtime_dict:
                    ydl_opts["js_runtimes"] = js_runtime_dict
            if extractor_args:
                cmd += ["--extractor-args", str(extractor_args)]
                extractor_dict = self._extractor_args_to_dict(extractor_args)
                if extractor_dict:
                    ydl_opts["extractor_args"] = extractor_dict
            if cookies_from_browser:
                cookies_arg = self._cookies_spec_to_cli(cookies_from_browser)
                if cookies_arg:
                    cmd += ["--cookies-from-browser", cookies_arg]
                ydl_opts["cookiesfrombrowser"] = cookies_from_browser
            if is_audio:
                ydl_opts["format"] = "bestaudio/best"
                if format_choice == "audio":
                    cmd += ["-f", "bestaudio/best"]
                else:
                    audio_ext = self._format_choice_output_ext(format_choice) or "mp3"
                    cmd += ["-f", "bestaudio/best", "-x", "--audio-format", audio_ext]
                    ydl_opts["postprocessors"] = [{
                        "key": "FFmpegExtractAudio",
                        "preferredcodec": audio_ext,
                    }]
            else:
                cmd += ["-f", format_selector]
                ydl_opts["format"] = format_selector
                if is_video_container:
                    cmd += ["--merge-output-format", video_ext]
                    ydl_opts["merge_output_format"] = video_ext
                if force_transcode or format_choice == "mov":
                    cmd += ["--recode-video", video_ext]
                    ydl_opts["recodevideo"] = video_ext
            cmd.append(url)
            return cmd, ydl_opts

        start_time = time.time()
        last_error = None
        first_error_logged = False
        user_declined_more = False

        if is_audio:
            attempts = [("audio", 'bestaudio/best', False)]
        else:
            primary_fmt = quality_format.get(quality_choice, 'best')
            compat_fmt = "bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]" if format_choice == "mp4" else "bestvideo+bestaudio/best"
            best_fmt = "bestvideo+bestaudio/best"
            attempts = [
                ("primary", primary_fmt, False),
                ("compat", compat_fmt, False),
                ("best", best_fmt, False),
            ]
            if ffmpeg_location and is_video_container:
                attempts.append(("transcode", best_fmt, True))
        primary_clients = [None]
        fallback_clients = ["web", "tv", "android", "ios"] if is_youtube else []
        attempt_plan_primary = []
        for group_index, (label, fmt, force_transcode) in enumerate(attempts):
            for client in primary_clients:
                attempt_plan_primary.append((group_index, label, fmt, force_transcode, client))
        attempt_plan_fallback = []
        if fallback_clients:
            for group_index, (label, fmt, force_transcode) in enumerate(attempts):
                for client in fallback_clients:
                    attempt_plan_fallback.append((group_index, label, fmt, force_transcode, client))

        def finalize_success(group_index, total_groups):
            output_path_final_local = output_path_final
            temp_files = [
                f for f in os.listdir(media_dl_dir)
                if f.startswith(temp_base + ".") and '_TEMP.' in f
            ]
            for temp_file in temp_files:
                temp_path = os.path.join(media_dl_dir, temp_file)
                if output_ext:
                    final_filename = f"{safe_base}.{output_ext}"
                else:
                    ext = self._resolve_output_ext_from_temp(temp_file)
                    final_filename = f"{safe_base}.{ext}" if ext else f"{safe_base}.audio"
                final_path = os.path.join(media_dl_dir, final_filename)
                if os.path.exists(final_path):
                    try:
                        os.remove(final_path)
                    except Exception:
                        pass
                os.rename(temp_path, final_path)
                output_path_final_local = final_path
            if self.progress:
                self.run_on_ui_thread(self._mark_progress_complete)
            elapsed = time.time() - start_time
            file_size = os.path.getsize(output_path_final_local) if output_path_final_local and os.path.exists(output_path_final_local) else 0
            size_mb = file_size / (1024 * 1024)
            output_lines = []
            if getattr(self, "_process_total", 1) > 1:
                self._process_done = self._process_total
                output_lines.append(f"All processes complete ({self._process_done}/{self._process_total}).")
            if group_index > 0:
                output_lines.append(f"Fallbacks used: {group_index}/{total_groups}")
            output_lines.append(f"Saved as: {self._display_path(output_path_final_local)}")
            output_lines.append(f"File size: {size_mb:.2f} MB")
            output_lines.append(f"Time taken: {elapsed:.2f} seconds")
            output_lines.append("Download completed successfully!")
            self.append_console("\n".join(output_lines) + "\n")

        def progress_cb(line):
            if self.abort_event.is_set():
                return
            match = re.search(r"(\d+(?:\.\d+)?)%", line)
            if match:
                try:
                    val = float(match.group(1))
                except Exception:
                    val = 0.0
                self.progress_queue.put(val)
                self.run_on_ui_thread(self._schedule_progress_poll)

        def run_attempts(plan, cookies_from_browser=None, allow_prompt=False):
            nonlocal last_error, first_error_logged, user_declined_more
            total = len(plan)
            for attempt_index, (_group_index, label, fmt, force_transcode, client) in enumerate(plan):
                if self.abort_event.is_set():
                    return False
                if attempt_index == 1 and allow_prompt:
                    err_text = self._clean_error_message(str(last_error)) if last_error else "Unknown error"
                    keep_trying = self._ask_yesno_blocking(
                        "Download failed",
                        f"Download failed because: {err_text}\n\nTry again with fallback methods?"
                    )
                    if not keep_trying:
                        user_declined_more = True
                        return False
                if attempt_index > 0:
                    self.append_console(f"Trying fallback {attempt_index}/{total - 1}...\n")
                extractor_args = None
                if is_youtube and client:
                    extractor_args = f"youtube:player_client={client}"
                cmd, ydl_opts = build_cmd(fmt, extractor_args=extractor_args, cookies_from_browser=cookies_from_browser, force_transcode=force_transcode)
                success, err_line = self._run_yt_dlp(cmd, ydl_opts, url, progress_cb=progress_cb)
                if success:
                    finalize_success(attempt_index, total)
                    return True
                if self.abort_event.is_set():
                    if not getattr(self, "_abort_notified", False):
                        self._abort_notified = True
                        self.append_console("Download aborted!\n")
                    self._cleanup_temp_files(media_dl_dir, temp_base, max_attempts=60, delay=0.25)
                    return False
                last_error = err_line or last_error
                if not first_error_logged and last_error:
                    self.append_console(self._summarize_error_for_console(str(last_error)) + "\n")
                    first_error_logged = True
            return False

        cookies_browser = str(self.config.get("cookies_browser", "") or "").strip()
        cookies_spec = self._normalize_cookies_from_browser(cookies_browser)
        if self.config.get("cookies_use", False) and cookies_spec:
            self.append_console("Trying with browser cookies...\n")
            success = run_attempts(attempt_plan_primary, cookies_from_browser=cookies_spec, allow_prompt=True)
            if not success and not self.abort_event.is_set() and not user_declined_more:
                success = run_attempts(attempt_plan_primary, allow_prompt=True)
            if attempt_plan_fallback and not success and not self.abort_event.is_set() and not user_declined_more:
                success = run_attempts(attempt_plan_fallback, cookies_from_browser=cookies_spec, allow_prompt=False)
        else:
            success = run_attempts(attempt_plan_primary, allow_prompt=True)
            if attempt_plan_fallback and not success and not self.abort_event.is_set() and not user_declined_more:
                success = run_attempts(attempt_plan_fallback, allow_prompt=False)

        if not success and not self.abort_event.is_set():
            self.append_console("Download failed!\n")
            err_text = self._clean_error_message(str(last_error)) if last_error else "Unknown error"
            self.run_on_ui_thread(messagebox.showerror, "Error", err_text)

        self.downloading = False
        self.set_controls_state(True)
        self.ydl = None
        self._unregister_active_temp(media_dl_dir, temp_base)
        self._active_download_dir = None
        self._active_temp_base = None

    def ydl_hook(self, d):
        if self.abort_event.is_set():
            raise DownloadCancelled()
        if d['status'] == 'downloading':
            try:
                percent_str = d.get('_percent_str', '').strip()
                percent = percent_str.split('%')[0].strip()[-4:]
                try:
                    val = float(percent)
                except Exception:
                    val = 0
                self.progress_queue.put(val)
                self.run_on_ui_thread(self._schedule_progress_poll)
            except Exception:
                self.progress_queue.put(0)
                self.run_on_ui_thread(self._schedule_progress_poll)
        elif d['status'] == 'finished':
            self.progress_queue.put(100)
            self.run_on_ui_thread(self._schedule_progress_poll)


    def check_for_updates(self, manual=False, on_complete=None):  # UPDATE CHECK
        def finish():
            if on_complete:
                self.run_on_ui_thread(on_complete)

        def normalize_version(v: str) -> str:
            if not v:
                return ""
            v = str(v).strip()
            return v[1:] if v.lower().startswith("v") else v

        def parse_version_from_text(text: str) -> str:
            if not text:
                return ""
            m = re.search(r"(\d+\.\d+\.\d+)", text)
            return m.group(1) if m else ""

        def fetch_from_website_manifest():
            manifest_url = "https://www.justagwas.com/projects/mediacrate/latest.json"
            try:
                r = requests.get(manifest_url, timeout=10)
                r.raise_for_status()
                data = r.json()

                raw_version = str(data.get("version", "")).strip()
                download_url = str(data.get("url", "")).strip()

                v_norm = normalize_version(raw_version)
                if not v_norm or not download_url:
                    logging.error("Manifest missing/invalid 'version' or 'url'.")
                    return None, None

                return f"v{v_norm}", download_url
            except Exception as e:
                logging.error(f"Website manifest check failed: {e}")
                return None, None

        def fetch_from_github_latest():
            download_url = "https://github.com/Justagwas/mediacrate/releases/latest/download/MediaCrateSetup.exe"
            latest_page = "https://github.com/Justagwas/mediacrate/releases/latest"

            try:
                r = requests.get(latest_page, timeout=10, allow_redirects=True)
                r.raise_for_status()

                final_url = r.url or ""
                v_norm = parse_version_from_text(final_url)
                if not v_norm:
                    v_norm = parse_version_from_text(r.text)

                if not v_norm:
                    logging.error("GitHub latest release reachable but version not detected.")
                    return None, None

                return f"v{v_norm}", download_url
            except Exception as e:
                logging.error(f"GitHub latest release check failed: {e}")
                return None, None

        def fetch_from_sourceforge_rss(current_version_display: str):
            rss_url = "https://sourceforge.net/projects/mediacrate/rss?path=/"
            had_any_version_candidates = False

            try:
                response = requests.get(rss_url, timeout=10)
                if response.status_code != 200:
                    logging.error(f"Failed to fetch SourceForge RSS feed: HTTP {response.status_code}")
                    return None, None, had_any_version_candidates

                root = ET.fromstring(response.text)
                current_norm = normalize_version(current_version_display)

                best_version = None
                best_link = None

                for item in root.findall(".//item"):
                    title_el = item.find("title")
                    link_el = item.find("link")
                    if title_el is None or link_el is None:
                        continue

                    title = title_el.text or ""
                    link = link_el.text or ""

                    match = re.search(r"_v(\d+\.\d+\.\d+)", title)
                    if not match:
                        continue

                    had_any_version_candidates = True
                    candidate_norm = match.group(1)

                    try:
                        if Version(candidate_norm) > Version(current_norm):
                            best_version = f"v{candidate_norm}"
                            best_link = link
                            break
                    except InvalidVersion:
                        logging.error(f"Invalid version format in RSS: {candidate_norm}")
                        continue

                return best_version, best_link, had_any_version_candidates

            except Exception as e:
                logging.error(f"Error during SourceForge update check: {e}")
                return None, None, had_any_version_candidates

        def show_failed_ui():
            messagebox.showerror(
                "Update Check Failed",
                "Unable to check for updates. Please try again later."
            )
            finish()

        def update_check():
            try:
                current_version = "v1.1.0"

                latest_version, download_url = fetch_from_website_manifest()
                if latest_version and download_url:
                    try:
                        if Version(normalize_version(latest_version)) > Version(normalize_version(current_version)):
                            prompt_message = (
                                f"A newer version - {latest_version} is available!\n"
                                f"Would you like to download it now?"
                            )
                            self.run_on_ui_thread(self._prompt_update, prompt_message, download_url, finish)
                            return
                    except InvalidVersion as e:
                        logging.error(f"Invalid version comparison (manifest): {e}")

                    if manual:
                        def show_up_to_date():
                            messagebox.showinfo("Up to Date", "You are already on the latest version.")
                            finish()
                        self.run_on_ui_thread(show_up_to_date)
                        return
                    finish()
                    return

                latest_version, download_url = fetch_from_github_latest()
                if latest_version and download_url:
                    try:
                        if Version(normalize_version(latest_version)) > Version(normalize_version(current_version)):
                            prompt_message = (
                                f"A newer version - {latest_version} is available!\n"
                                f"Would you like to download it now?"
                            )
                            self.run_on_ui_thread(self._prompt_update, prompt_message, download_url, finish)
                            return
                    except InvalidVersion as e:
                        logging.error(f"Invalid version comparison (github): {e}")

                    if manual:
                        def show_up_to_date():
                            messagebox.showinfo("Up to Date", "You are already on the latest version.")
                            finish()
                        self.run_on_ui_thread(show_up_to_date)
                        return
                    finish()
                    return

                latest_version, download_url, had_candidates = fetch_from_sourceforge_rss(current_version)
                if latest_version and download_url:
                    prompt_message = (
                        f"A newer version - {latest_version} is available!\n"
                        f"Would you like to download it now?"
                    )
                    self.run_on_ui_thread(self._prompt_update, prompt_message, download_url, finish)
                    return

                if not had_candidates:
                    logging.error("SourceForge RSS did not contain any parsable version entries.")
                    if manual:
                        self.run_on_ui_thread(show_failed_ui)
                        return
                    finish()
                    return

                if manual:
                    def show_up_to_date():
                        messagebox.showinfo("Up to Date", "You are already on the latest version.")
                        finish()
                    self.run_on_ui_thread(show_up_to_date)
                    return

                finish()

            except Exception as e:
                logging.error(f"Error during update check: {e}")
                if manual:
                    self.run_on_ui_thread(show_failed_ui)
                    return
                finish()

        threading.Thread(target=update_check, daemon=True).start()

    def _prompt_update(self, prompt_message, download_url, on_complete=None):
        theme = self.theme
        fonts = self.fonts
        bg_main = theme["bg"]
        fg_label = theme["text"]
        bg_button = theme["surface_alt"]
        fg_button = theme["text"]
        active_bg_button = theme["surface_alt_hover"]
        active_fg_button = theme["text"]
        if hasattr(self, 'update_overlay') and self.update_overlay.winfo_exists():
            self.update_overlay.destroy()
        self.update_overlay = tk.Frame(self.root, bg=bg_main)
        self.update_overlay.place(relx=0, rely=0, relwidth=1, relheight=1)
        dialog = tk.Frame(self.update_overlay, bg=theme["surface"], bd=0, highlightthickness=1, highlightbackground=theme["border"])
        dialog.place(relx=0.5, rely=0.5, anchor="center")
        tk.Label(
            dialog,
            text=prompt_message,
            bg=theme["surface"],
            fg=fg_label,
            wraplength=420,
            font=fonts["subtitle"],
            justify="center"
        ).pack(pady=(20, 10), padx=20)
        button_frame = tk.Frame(dialog, bg=theme["surface"])
        button_frame.pack(pady=15)
        def yes_action():
            self.open_url(download_url)
            self.update_overlay.destroy()
            self.terminate_program()
        def no_action():
            self.update_overlay.destroy()
            if on_complete:
                on_complete()
        yes_button = tk.Button(
            button_frame,
            text="Yes",
            command=yes_action,
            font=fonts["button"],
            bg=bg_button,
            fg=fg_button,
            activebackground=active_bg_button,
            activeforeground=active_fg_button,
            relief="flat",
            bd=0,
            padx=20,
            pady=5,
            width=10,
            cursor="hand2"
        )
        yes_button.pack(side="left", padx=10)
        self.add_hover_effect(
            yes_button,
            bg_normal=bg_button,
            fg_normal=fg_button,
            bg_hover=active_bg_button,
            fg_hover=active_fg_button
        )
        no_button = tk.Button(
            button_frame,
            text="No",
            command=no_action,
            font=fonts["button"],
            bg=theme["danger"],
            fg=theme["bg"],
            activebackground=theme["danger_hover"],
            activeforeground=theme["bg"],
            relief="flat",
            bd=0,
            padx=20,
            pady=5,
            width=10,
            cursor="hand2"
        )
        no_button.pack(side="right", padx=10)
        self.add_hover_effect(
            no_button,
            bg_normal=theme["danger"],
            fg_normal=theme["bg"],
            bg_hover=theme["danger_hover"],
            fg_hover=theme["bg"]
        )

    def poll_status_queue(self):
        if not self.status_polling:
            self._status_poll_scheduled = False
            return
        try:
            processed = 0
            max_tasks = self._max_status_tasks_per_tick
            while processed < max_tasks:
                msg = self.status_queue.get_nowait()
                self._append_console(msg + "\n")
                processed += 1
        except queue.Empty:
            pass
        if not self.status_queue.empty():
            self._after(16, self.poll_status_queue)
        else:
            self._status_poll_scheduled = False

    def _schedule_status_poll(self):
        if not self.status_polling:
            return
        if self._status_poll_scheduled:
            return
        self._status_poll_scheduled = True
        self._after(16, self.poll_status_queue)

    def poll_progress_queue(self):
        if not self.downloading:
            self._progress_poll_scheduled = False
            return
        if self.abort_event.is_set():
            self._drain_queue(self.progress_queue)
            self._progress_poll_scheduled = False
            return
        last_val = None
        try:
            while True:
                last_val = self.progress_queue.get_nowait()
        except queue.Empty:
            pass
        if last_val is not None:
            self.display_percent_in_console(last_val)
        if self.downloading and not self.progress_queue.empty():
            self._after(32, self.poll_progress_queue)
        else:
            self._progress_poll_scheduled = False

    def _schedule_progress_poll(self):
        if not self.downloading:
            return
        if self._progress_poll_scheduled:
            return
        self._progress_poll_scheduled = True
        self._after(16, self.poll_progress_queue)

    def set_status(self, msg):
        self.status_queue.put(msg)
        self._schedule_status_poll()

    def append_console(self, msg):
        self.run_on_ui_thread(self._append_console, msg)

    def _clear_console_output(self):
        console = getattr(self, "console", None)
        if console:
            console.delete("1.0", tk.END)

    def _drain_queue(self, queue_obj):
        try:
            while True:
                queue_obj.get_nowait()
        except queue.Empty:
            pass

    def _append_console(self, msg):
        console = getattr(self, "console", None)
        if console:
            timestamp = time.strftime("%H:%M:%S")
            lines = msg.splitlines()
            if not lines:
                lines = [""]
            stamped_lines = []
            for line in lines:
                if line.strip():
                    stamped_lines.append(f"{timestamp}: {line}")
                else:
                    stamped_lines.append("")
            stamped_msg = "\n".join(stamped_lines)
            if msg.endswith("\n"):
                stamped_msg += "\n"
            console.insert(tk.END, stamped_msg)
            lines = int(console.index('end-1c').split('.')[0])
            if lines > 200:
                console.delete("1.0", f"{lines-199}.0")
            console.see(tk.END)

    def display_percent_in_console(self, percent):
        self.run_on_ui_thread(self._display_percent_in_console, percent)

    def _display_percent_in_console(self, percent):
        if self.config.get('allow_batch_downloads', False):
            return
        if getattr(self, "_download_finished", False) and percent < 100:
            return
        if percent <= 0:
            if not getattr(self, "_percent_started", False):
                if self.progress and isinstance(self.progress, tk.Canvas):
                    self._set_progress_value(0)
                    self._set_progress_text("0%")
            return
        if percent > 0:
            self._percent_started = True
        if percent == 100 and not getattr(self, "_download_finished", False):
            self._download_finished = True
            total = getattr(self, "_process_total", 1)
            done = min(getattr(self, "_process_done", 0) + 1, total)
            self._process_done = done
            if total > 1:
                self.append_console(f"Download finished ({done}/{total}). Post-processing...\n")
            else:
                self.append_console(f"Process finished ({done}/{total}).\n")
        if self.progress and isinstance(self.progress, tk.Canvas):
            self._set_progress_value(percent)
        if percent > 0:
            self._set_progress_text(f"{int(percent)}%")

    def show_settings(self):
        if self.downloading:
            return
        self._clear_footer()
        entry_size = None
        if getattr(self, "_current_view", None) != "settings":
            self._record_current_view_size()
            width = self.root.winfo_width()
            height = self.root.winfo_height()
            if width > 1 and height > 1:
                entry_size = (width, height)
        self._begin_transition()
        self._ensure_view_container()
        for widget in self.settings_view.winfo_children():
            widget.destroy()
        theme = self.theme
        fonts = self.fonts
        settings_root = self.settings_view
        settings_root.configure(bg=theme["bg"])
        content_container = tk.Frame(settings_root, bg=theme["bg"])
        content_container.pack(side="top", fill="both", expand=True)
        content_canvas = tk.Canvas(content_container, bg=theme["bg"], highlightthickness=0)
        content_scrollbar = ttk.Scrollbar(
            content_container,
            orient="vertical",
            style="Modern.Vertical.TScrollbar",
            command=content_canvas.yview
        )
        content_canvas.configure(yscrollcommand=content_scrollbar.set)
        content_scrollbar.pack(side="right", fill="y")
        content_canvas.pack(side="left", fill="both", expand=True)
        content_frame = tk.Frame(content_canvas, bg=theme["bg"])
        content_window = content_canvas.create_window((0, 0), window=content_frame, anchor="nw")
        def _update_scrollregion(_event=None):
            content_canvas.configure(scrollregion=content_canvas.bbox("all") or (0, 0, 0, 0))
        def _resize_canvas(_event=None):
            content_canvas.itemconfigure(content_window, width=content_canvas.winfo_width())
            _update_scrollregion()
        content_frame.bind("<Configure>", _update_scrollregion)
        content_canvas.bind("<Configure>", _resize_canvas)
        def _on_settings_wheel(event):
            if event.delta:
                content_canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
            elif event.num == 5:
                content_canvas.yview_scroll(1, "units")
            elif event.num == 4:
                content_canvas.yview_scroll(-1, "units")
            return "break"
        content_canvas.bind("<MouseWheel>", _on_settings_wheel)
        content_canvas.bind("<Button-4>", _on_settings_wheel)
        content_canvas.bind("<Button-5>", _on_settings_wheel)
        content_frame.bind("<MouseWheel>", _on_settings_wheel)
        content_frame.bind("<Button-4>", _on_settings_wheel)
        content_frame.bind("<Button-5>", _on_settings_wheel)
        self.settings_frame = content_frame

        tk.Label(self.settings_frame, text="Settings", font=fonts["title"], fg=theme["text"], bg=theme["bg"]).pack(pady=self._px((18, 30)))

        def on_ui_scale_change(value):
            try:
                percent = int(round(float(value) / 5.0) * 5)
            except Exception:
                percent = int(self.config.get('ui_scale', 100))
            ui_scale_value.config(text=f"{percent}%")
            self._ui_scale_pending = percent
        def commit_ui_scale(_event=None):
            try:
                percent = int(round(float(ui_scale_var.get()) / 5.0) * 5)
            except Exception:
                return
            percent = max(50, min(200, percent))
            ui_scale_value.config(text=f"{percent}%")
            current = int(self.config.get('ui_scale', 100))
            if percent == current:
                return
            self.config['ui_scale'] = percent
            self.save_config()
            self._apply_ui_scale(percent)
        ui_scale_var = tk.IntVar(value=int(self.config.get('ui_scale', 100)))
        tk.Label(self.settings_frame, text="UI scale:", font=fonts["label"], bg=theme["bg"], fg=theme["text"]).pack(anchor="w", padx=self._px(32), pady=self._px((0, 4)))
        ui_scale_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        ui_scale_row.pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)), fill="x")
        ui_scale_value = tk.Label(ui_scale_row, text=f"{ui_scale_var.get()}%", font=fonts["body"], bg=theme["bg"], fg=theme["text"])
        ui_scale = tk.Scale(
            ui_scale_row,
            from_=50,
            to=200,
            orient="horizontal",
            showvalue=False,
            variable=ui_scale_var,
            command=on_ui_scale_change,
            length=self._px(360),
            sliderlength=self._px(48),
            width=self._px(24),
            resolution=5,
            troughcolor=theme["surface_alt"],
            highlightthickness=0,
            bg=theme["bg"],
            fg=theme["text"]
        )
        ui_scale.pack(side="left")
        self._ui_scale_slider = ui_scale
        ui_scale_value.pack(side="left", padx=self._px((16, 0)))
        ui_scale.bind("<ButtonRelease-1>", commit_ui_scale)
        ui_scale.bind("<KeyRelease>", commit_ui_scale)

        def on_toggle_disable_char_limits():
            self.config['disable_char_limits'] = not self.config.get('disable_char_limits', False)
            self.save_config()
            char_limit_var.set(self.config['disable_char_limits'])
            self._apply_single_url_limit()
            self._apply_batch_text_limits()
        char_limit_var = tk.BooleanVar(value=self.config.get('disable_char_limits', False))
        disable_char_limits_cb = tk.Checkbutton(
            self.settings_frame,
            text="Disable URL length limits",
            variable=char_limit_var,
            command=on_toggle_disable_char_limits,
            font=fonts["body"],
            bg=theme["bg"],
            fg=theme["text"],
            selectcolor=theme["surface_alt"],
            activebackground=theme["surface_alt"],
            activeforeground=theme["text"],
            highlightthickness=0
        )
        disable_char_limits_cb.pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)))

        def on_toggle_disable_warnings():
            self.config['disable_warnings'] = not self.config.get('disable_warnings', False)
            self.save_config()
            var.set(self.config['disable_warnings'])
        var = tk.BooleanVar(value=self.config.get('disable_warnings', False))
        disable_warnings_cb = tk.Checkbutton(
            self.settings_frame,
            text="Disable quality/format warnings",
            variable=var,
            command=on_toggle_disable_warnings,
            font=fonts["body"],
            bg=theme["bg"],
            fg=theme["text"],
            selectcolor=theme["surface_alt"],
            activebackground=theme["surface_alt"],
            activeforeground=theme["text"],
            highlightthickness=0
        )
        disable_warnings_cb.pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)))

        def on_toggle_disable_already_downloaded_prompts():
            self.config['disable_already_downloaded_prompts'] = not self.config.get('disable_already_downloaded_prompts', False)
            self.save_config()
            already_var.set(self.config['disable_already_downloaded_prompts'])
        already_var = tk.BooleanVar(value=self.config.get('disable_already_downloaded_prompts', False))
        disable_already_downloaded_cb = tk.Checkbutton(
            self.settings_frame,
            text="Disable prompting for already downloaded files",
            variable=already_var,
            command=on_toggle_disable_already_downloaded_prompts,
            font=fonts["body"],
            bg=theme["bg"],
            fg=theme["text"],
            selectcolor=theme["surface_alt"],
            activebackground=theme["surface_alt"],
            activeforeground=theme["text"],
            highlightthickness=0
        )
        disable_already_downloaded_cb.pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)))

        def on_toggle_window_resizing():
            new_value = bool(window_resize_var.get())
            current_value = bool(self.config.get('enable_window_resizing', True))
            if new_value == current_value:
                return
            if messagebox.askyesno("Restart Required", "Changing window resizing requires restarting the app. Restart now?"):
                self.config['enable_window_resizing'] = new_value
                self.save_config()
                messagebox.showinfo("Restarting", "The app will now restart to apply the change.")
                self.restart_program()
            else:
                window_resize_var.set(current_value)
        window_resize_var = tk.BooleanVar(value=self.config.get('enable_window_resizing', True))
        window_resize_cb = tk.Checkbutton(
            self.settings_frame,
            text="Enable window resizing",
            variable=window_resize_var,
            command=on_toggle_window_resizing,
            font=fonts["body"],
            bg=theme["bg"],
            fg=theme["text"],
            selectcolor=theme["surface_alt"],
            activebackground=theme["surface_alt"],
            activeforeground=theme["text"],
            highlightthickness=0
        )
        window_resize_cb.pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)))

        def on_toggle_preserve_batch_links():
            self.config['preserve_batch_links'] = not self.config.get('preserve_batch_links', False)
            self.save_config()
            preserve_var.set(self.config['preserve_batch_links'])
            if not self.config['preserve_batch_links']:
                self._batch_saved_links = None
        preserve_var = tk.BooleanVar(value=self.config.get('preserve_batch_links', False))
        preserve_links_cb = tk.Checkbutton(
            self.settings_frame,
            text="Keep batch links after reset",
            variable=preserve_var,
            command=on_toggle_preserve_batch_links,
            font=fonts["body"],
            bg=theme["bg"],
            fg=theme["text"],
            selectcolor=theme["surface_alt"],
            activebackground=theme["surface_alt"],
            activeforeground=theme["text"],
            highlightthickness=0
        )
        preserve_links_cb.pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)))

        def on_toggle_batch_downloads():
            self.config['allow_batch_downloads'] = not self.config.get('allow_batch_downloads', False)
            self.save_config()
            batch_var.set(self.config['allow_batch_downloads'])
            self._pending_batch_refresh = True
        batch_var = tk.BooleanVar(value=self.config.get('allow_batch_downloads', False))
        batch_downloads_cb = tk.Checkbutton(
            self.settings_frame,
            text="Allow Batch Downloads (multi-link notepad input)",
            variable=batch_var,
            command=on_toggle_batch_downloads,
            font=fonts["body"],
            bg=theme["bg"],
            fg=theme["text"],
            selectcolor=theme["surface_alt"],
            activebackground=theme["surface_alt"],
            activeforeground=theme["text"],
            highlightthickness=0
        )
        def on_toggle_batch_fallbacks():
            self.config['enable_batch_fallbacks'] = not self.config.get('enable_batch_fallbacks', False)
            self.save_config()
            batch_fallback_var.set(self.config['enable_batch_fallbacks'])
        batch_fallback_var = tk.BooleanVar(value=self.config.get('enable_batch_fallbacks', False))
        batch_fallbacks_cb = tk.Checkbutton(
            self.settings_frame,
            text="Enable fallback attempts for batch downloads",
            variable=batch_fallback_var,
            command=on_toggle_batch_fallbacks,
            font=fonts["body"],
            bg=theme["bg"],
            fg=theme["text"],
            selectcolor=theme["surface_alt"],
            activebackground=theme["surface_alt"],
            activeforeground=theme["text"],
            highlightthickness=0
        )
        batch_fallbacks_cb.pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)))

        batch_downloads_cb.pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)))

        def on_toggle_auto_updates():
            self.config['auto_check_updates'] = bool(auto_update_var.get())
            self.save_config()
        auto_update_var = tk.BooleanVar(value=self.config.get('auto_check_updates', True))
        updates_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        updates_row.pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)), fill="x")
        auto_updates_cb = tk.Checkbutton(
            updates_row,
            text="Automatically check for updates",
            variable=auto_update_var,
            command=on_toggle_auto_updates,
            font=fonts["body"],
            bg=theme["bg"],
            fg=theme["text"],
            selectcolor=theme["surface_alt"],
            activebackground=theme["surface_alt"],
            activeforeground=theme["text"],
            highlightthickness=0
        )
        auto_updates_cb.pack(side="left")
        check_updates_btn = tk.Button(
            updates_row,
            text="Check now",
            font=fonts["label"],
            bg=theme["surface_alt"],
            fg=theme["text"],
            activebackground=theme["surface_alt_hover"],
            activeforeground=theme["text"],
            relief="flat",
            bd=0,
            padx=self._px(10),
            pady=self._px(2),
            command=lambda: self.check_for_updates(manual=True)
        )
        check_updates_btn.pack(side="left", padx=self._px((12, 0)))
        self.add_hover_effect(
            check_updates_btn,
            bg_normal=theme["surface_alt"],
            fg_normal=theme["text"],
            bg_hover=theme["surface_alt_hover"],
            fg_hover=theme["accent"]
        )

        def on_queue_cap_change():
            value = self._normalize_ui_queue_cap(queue_cap_var.get())
            self.config['ui_queue_cap'] = value
            self.save_config()
            queue_cap_var.set(str(value))
            self._max_gui_tasks_per_tick = value
            self._max_status_tasks_per_tick = value
            self._max_progress_updates_per_tick = value
        queue_cap_default = self._default_ui_queue_cap()
        queue_cap_var = tk.StringVar(value=str(self._normalize_ui_queue_cap(self.config.get('ui_queue_cap'))))
        tk.Label(self.settings_frame, text="UI queue cap (tasks per tick):", font=fonts["label"], bg=theme["bg"], fg=theme["text"]).pack(anchor="w", padx=self._px(32), pady=self._px((0, 4)))
        queue_cap_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        queue_cap_row.pack(anchor="w", padx=self._px(32), pady=self._px((0, 6)), fill="x")
        queue_cap_spin = tk.Spinbox(
            queue_cap_row,
            from_=1,
            to=500,
            textvariable=queue_cap_var,
            font=fonts["body"],
            bg=theme["surface_alt"],
            fg=theme["text"],
            relief="flat",
            bd=0,
            width=6,
            highlightthickness=1,
            highlightbackground=theme["border"],
            highlightcolor=theme["border"]
        )
        queue_cap_spin.pack(side="left")
        try:
            queue_cap_spin.config(
                buttonbackground="black",
                buttonforeground="white"
            )
        except tk.TclError:
            pass
        queue_cap_spin.config(command=on_queue_cap_change)
        queue_cap_spin.bind("<FocusOut>", lambda e: on_queue_cap_change())
        queue_cap_spin.bind("<Return>", lambda e: on_queue_cap_change())
        tk.Label(
            self.settings_frame,
            text=f"Drains UI/status queues per tick. Default: {queue_cap_default} (max 500).",
            font=fonts["caption"],
            bg=theme["bg"],
            fg=theme["muted"]
        ).pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)))

        def on_max_lines_change():
            value = self._normalize_batch_line_limit(max_lines_var.get())
            self.config['max_batch_lines'] = value
            self.save_config()
            max_lines_var.set(str(value))
            self._apply_batch_text_limits()
        max_lines_default = self._default_batch_line_limit()
        max_lines_var = tk.StringVar(value=str(self._normalize_batch_line_limit(self.config.get('max_batch_lines'))))
        tk.Label(self.settings_frame, text="Max batch links:", font=fonts["label"], bg=theme["bg"], fg=theme["text"]).pack(anchor="w", padx=self._px(32), pady=self._px((0, 4)))
        max_lines_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        max_lines_row.pack(anchor="w", padx=self._px(32), pady=self._px((0, 6)), fill="x")
        max_lines_spin = tk.Spinbox(
            max_lines_row,
            from_=1,
            to=1024,
            textvariable=max_lines_var,
            font=fonts["body"],
            bg=theme["surface_alt"],
            fg=theme["text"],
            relief="flat",
            bd=0,
            width=6,
            highlightthickness=1,
            highlightbackground=theme["border"],
            highlightcolor=theme["border"]
        )
        max_lines_spin.pack(side="left")
        try:
            max_lines_spin.config(
                buttonbackground="black",
                buttonforeground="white"
            )
        except tk.TclError:
            pass
        max_lines_spin.config(command=on_max_lines_change)
        max_lines_spin.bind("<FocusOut>", lambda e: on_max_lines_change())
        max_lines_spin.bind("<Return>", lambda e: on_max_lines_change())
        tk.Label(
            self.settings_frame,
            text=f"Limits batch input lines. Default: {max_lines_default} (max 1024).",
            font=fonts["caption"],
            bg=theme["bg"],
            fg=theme["muted"]
        ).pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)))

        def on_concurrency_change():
            value = self._normalize_batch_concurrency(concurrency_var.get())
            self.config['batch_concurrency'] = value
            self.save_config()
            concurrency_var.set(str(value))
        concurrency_default = self._default_batch_concurrency()
        concurrency_var = tk.StringVar(value=str(self._normalize_batch_concurrency(self.config.get('batch_concurrency'))))
        tk.Label(self.settings_frame, text="Batch download concurrency:", font=fonts["label"], bg=theme["bg"], fg=theme["text"]).pack(anchor="w", padx=self._px(32), pady=self._px((0, 4)))
        concurrency_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        concurrency_row.pack(anchor="w", padx=self._px(32), pady=self._px((0, 6)), fill="x")
        concurrency_spin = tk.Spinbox(
            concurrency_row,
            from_=1,
            to=64,
            textvariable=concurrency_var,
            font=fonts["body"],
            bg=theme["surface_alt"],
            fg=theme["text"],
            relief="flat",
            bd=0,
            width=6,
            highlightthickness=1,
            highlightbackground=theme["border"],
            highlightcolor=theme["border"]
        )
        concurrency_spin.pack(side="left")
        try:
            concurrency_spin.config(
                buttonbackground="black",
                buttonforeground="white"
            )
        except tk.TclError:
            pass
        concurrency_spin.config(command=on_concurrency_change)
        concurrency_spin.bind("<FocusOut>", lambda e: on_concurrency_change())
        concurrency_spin.bind("<Return>", lambda e: on_concurrency_change())
        tk.Label(
            self.settings_frame,
            text=f"Higher values use more CPU/bandwidth. Recommended default: {concurrency_default}.",
            font=fonts["caption"],
            bg=theme["bg"],
            fg=theme["muted"]
        ).pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)))

        def on_retry_change():
            value = self._normalize_batch_retries(retry_var.get())
            self.config['batch_retry_attempts'] = value
            self.save_config()
            retry_var.set(str(value))
        retry_var = tk.StringVar(value=str(self._normalize_batch_retries(self.config.get('batch_retry_attempts'))))
        tk.Label(self.settings_frame, text="Batch retry attempts per link:", font=fonts["label"], bg=theme["bg"], fg=theme["text"]).pack(anchor="w", padx=self._px(32), pady=self._px((0, 4)))
        retry_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        retry_row.pack(anchor="w", padx=self._px(32), pady=self._px((0, 6)), fill="x")
        retry_spin = tk.Spinbox(
            retry_row,
            from_=1,
            to=5,
            textvariable=retry_var,
            font=fonts["body"],
            bg=theme["surface_alt"],
            fg=theme["text"],
            relief="flat",
            bd=0,
            width=6,
            highlightthickness=1,
            highlightbackground=theme["border"],
            highlightcolor=theme["border"]
        )
        retry_spin.pack(side="left")
        try:
            retry_spin.config(
                buttonbackground="black",
                buttonforeground="white"
            )
        except tk.TclError:
            pass
        retry_spin.config(command=on_retry_change)
        retry_spin.bind("<FocusOut>", lambda e: on_retry_change())
        retry_spin.bind("<Return>", lambda e: on_retry_change())
        tk.Label(
            self.settings_frame,
            text="Retries happen when a link fails during download.",
            font=fonts["caption"],
            bg=theme["bg"],
            fg=theme["muted"]
        ).pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)))

        def on_default_format_change(_event=None):
            label = default_format_var.get().strip()
            if label.startswith("None"):
                self.config['default_format_selection'] = ""
            else:
                self.config['default_format_selection'] = label.lower()
            self.save_config()
            if not self.downloading and hasattr(self, "selected_other_format"):
                preferred = {
                    "video": "VIDEO",
                    "audio": "AUDIO",
                    "mp4": "MP4",
                    "mp3": "MP3",
                }.get(self.config['default_format_selection'], "")
                if preferred:
                    self.selected_other_format.set(preferred)
                    if hasattr(self, "selected_format"):
                        self.selected_format.set(self._normalize_format_choice(preferred))
                else:
                    self.selected_other_format.set("Choose format")
                    if hasattr(self, "selected_format"):
                        self.selected_format.set("")
                self.update_format_buttons()
                self._update_format_combo_style()

        default_format_label = tk.Label(self.settings_frame, text="Default format:", font=fonts["label"], bg=theme["bg"], fg=theme["text"])
        default_format_label.pack(anchor="w", padx=self._px(32), pady=self._px((0, 4)))
        default_format_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        default_format_row.pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)), fill="x")
        current_default = self.config.get('default_format_selection', "")
        current_label = {
            "video": "VIDEO",
            "audio": "AUDIO",
            "mp4": "MP4",
            "mp3": "MP3",
        }.get(str(current_default).strip().lower(), "None (select manually)")
        default_format_var = tk.StringVar(value=current_label)
        default_format_combo = ttk.Combobox(
            default_format_row,
            textvariable=default_format_var,
            values=["None (select manually)", "VIDEO", "AUDIO", "MP4", "MP3"],
            state="readonly",
            style="WhiteOnBlack.TCombobox"
        )
        default_format_combo.pack(side="left", fill="x", expand=True)
        self._disable_combo_scroll(default_format_combo)
        default_format_combo.bind("<<ComboboxSelected>>", on_default_format_change)
        tk.Label(
            self.settings_frame,
            text="Used to preselect a format when the app launches.",
            font=fonts["caption"],
            bg=theme["bg"],
            fg=theme["muted"]
        ).pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)))

        def on_toggle_cookies_use():
            enabled = bool(cookies_use_var.get())
            self.config['cookies_use'] = enabled
            self.save_config()
            state = "readonly" if enabled else "disabled"
            cookies_browser_combo.config(state=state)

        cookies_use_var = tk.BooleanVar(value=self.config.get('cookies_use', False))
        cookies_label = tk.Label(self.settings_frame, text="Use browser cookies (fallback):", font=fonts["label"], bg=theme["bg"], fg=theme["text"])
        cookies_label.pack(anchor="w", padx=self._px(32), pady=self._px((0, 4)))
        cookies_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        cookies_row.pack(anchor="w", padx=self._px(32), pady=self._px((0, 6)), fill="x")
        cookies_cb = tk.Checkbutton(
            cookies_row,
            text="Enable",
            variable=cookies_use_var,
            command=on_toggle_cookies_use,
            font=fonts["body"],
            bg=theme["bg"],
            fg=theme["text"],
            selectcolor=theme["surface_alt"],
            activebackground=theme["surface_alt"],
            activeforeground=theme["text"],
            highlightthickness=0
        )
        cookies_cb.pack(side="left")
        cookies_help = tk.Label(
            self.settings_frame,
            text="Cookies = proof you're logged in in your browser. Needed for restricted/private/age-gated content.",
            font=fonts["caption"],
            bg=theme["bg"],
            fg=theme["muted"],
            wraplength=self._px(520),
            justify="left"
        )
        cookies_help.pack(anchor="w", padx=self._px(32), pady=self._px((0, 10)))
        cookies_browser_var = tk.StringVar(value=self.config.get('cookies_browser', 'chrome'))
        tk.Label(self.settings_frame, text="Browser:", font=fonts["label"], bg=theme["bg"], fg=theme["text"]).pack(anchor="w", padx=self._px(32), pady=self._px((0, 4)))
        cookies_browser_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        cookies_browser_row.pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)), fill="x")
        cookie_browsers = ["chrome", "edge", "firefox", "brave", "opera", "vivaldi", "safari"]
        cookies_browser_combo = ttk.Combobox(
            cookies_browser_row,
            textvariable=cookies_browser_var,
            values=cookie_browsers,
            state="readonly" if self.config.get('cookies_use', False) else "disabled",
            style="WhiteOnBlack.TCombobox"
        )
        cookies_browser_combo.pack(side="left", fill="x", expand=True)
        self._disable_combo_scroll(cookies_browser_combo)
        def on_cookie_browser_change(_event=None):
            self.config['cookies_browser'] = cookies_browser_var.get().strip() or "chrome"
            self.save_config()
        cookies_browser_combo.bind("<<ComboboxSelected>>", on_cookie_browser_change)

        def on_proxy_change():
            value = proxy_var.get().strip()
            if value and not self._validate_proxy(value):
                messagebox.showerror("Invalid proxy", "Proxy must include a scheme, e.g. http://host:port or socks5://user:pass@host:port")
                proxy_var.set(self.config.get('proxy', ''))
                return
            self.config['proxy'] = value
            self.save_config()

        proxy_var = tk.StringVar(value=self.config.get('proxy', ''))
        tk.Label(self.settings_frame, text="Proxy (optional):", font=fonts["label"], bg=theme["bg"], fg=theme["text"]).pack(anchor="w", padx=self._px(32), pady=self._px((0, 4)))
        proxy_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        proxy_row.pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)), fill="x")
        proxy_entry = tk.Entry(
            proxy_row,
            textvariable=proxy_var,
            font=fonts["body"],
            bg=theme["surface_alt"],
            fg=theme["text"],
            selectbackground=theme["surface_alt"],
            selectforeground=theme["text"],
            relief="flat",
            bd=0,
            width=48
        )
        proxy_entry.pack(side="left", fill="x", expand=True, ipady=self._px(7))
        proxy_entry.bind("<FocusOut>", lambda _e: on_proxy_change())
        proxy_entry.bind("<Return>", lambda _e: on_proxy_change())

        def on_change_download_location():
            from tkinter import filedialog
            new_dir = filedialog.askdirectory(
                title="Browse",
                initialdir=self.config.get('download_location', self._default_download_dir())
            )
            if new_dir:
                self.config['download_location'] = new_dir
                self.save_config()
                download_location_var.set(self._display_path(new_dir))
        download_location_var = tk.StringVar(value=self._display_path(self.config.get('download_location', self._default_download_dir())))
        tk.Label(self.settings_frame, text="Download Location:", font=fonts["label"], bg=theme["bg"], fg=theme["text"]).pack(anchor="w", padx=self._px(32), pady=self._px((0, 4)))
        download_location_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        download_location_row.pack(anchor="w", padx=self._px(32), pady=self._px((0, 20)), fill="x")
        download_entry = tk.Entry(
            download_location_row,
            textvariable=download_location_var,
            font=fonts["body"],
            bg=theme["surface_alt"],
            fg=theme["text"],
            selectbackground=theme["surface_alt"],
            selectforeground=theme["text"],
            relief="flat",
            bd=0,
            width=48,
            state="readonly",
            readonlybackground=theme["surface_alt"]
        )
        download_entry.pack(side="left", padx=self._px((0, 8)), fill="x", expand=True, ipady=self._px(7))
        browse_btn = tk.Button(
            download_location_row,
            text="Browse...",
            font=fonts["button"],
            bg=theme["surface_alt"],
            fg=theme["text"],
            activebackground=theme["surface_alt_hover"],
            activeforeground=theme["text"],
            relief="flat",
            bd=0,
            padx=self._px(8),
            pady=self._px(2),
            command=on_change_download_location
        )
        browse_btn.pack(side="left")
        self.add_hover_effect(
            browse_btn,
            bg_normal=theme["surface_alt"],
            fg_normal=theme["text"],
            bg_hover=theme["surface_alt_hover"],
            fg_hover=theme["accent"]
        )

        bottom_bar = tk.Frame(settings_root, bg=theme["bg"], padx=self._px(24), pady=self._px(8))
        bottom_bar.pack(side="bottom", fill="x")
        bottom_left = tk.Frame(bottom_bar, bg=theme["bg"])
        bottom_right = tk.Frame(bottom_bar, bg=theme["bg"])
        theme_toggle_btn = tk.Button(
            bottom_left, text=self._theme_icon(), font=fonts["label"],
            bg=theme["bg"], fg=theme["muted"],
            activebackground=theme["bg"], activeforeground=theme["text"],
            relief="flat", bd=0, padx=self._px(6), pady=self._px(2), command=self.toggle_theme, cursor="hand2"
        )
        theme_toggle_btn.pack(side="left", anchor="w", padx=self._px((0, 8)))
        self._register_theme_toggle(theme_toggle_btn)
        self.add_hover_effect(
            theme_toggle_btn,
            bg_normal=theme["bg"], fg_normal=theme["muted"],
            bg_hover=theme["bg"], fg_hover=theme["accent"]
        )
        back_btn = tk.Button(
            bottom_left, text="Back", font=fonts["label"],
            bg=theme["bg"], fg=theme["muted"],
            activebackground=theme["bg"], activeforeground=theme["text"],
            relief="flat", bd=0, padx=self._px(8), pady=self._px(2), command=self.show_main_view, cursor="hand2"
        )
        back_btn.pack(side="left", anchor="w", padx=self._px((0, 8)))
        self.add_hover_effect(back_btn, bg_normal=theme["bg"], fg_normal=theme["muted"], bg_hover=theme["bg"], fg_hover=theme["accent"])

        def on_reset_defaults():
            if messagebox.askyesno("Reset Settings", "Are you sure you want to reset all settings to their defaults? This cannot be undone."):
                default_config = {
                    'WARNING:': "This file is generated by MediaCrate. DO NOT CHANGE the contents of this file unless you know what you are doing.",
                    'first_launch_complete': True,
                    'ui_scale_confirmed': True,
                    'theme': "dark",
                    'disable_warnings': False,
                    'allow_batch_downloads': False,
                    'disable_already_downloaded_prompts': False,
                    'auto_check_updates': True,
                    'enable_window_resizing': False,
                    'ui_scale': 100,
                    'default_format_selection': "",
                    'ui_queue_cap': self._default_ui_queue_cap(),
                    'download_location': self._default_download_dir(),
                    'batch_concurrency': self._default_batch_concurrency(),
                    'batch_retry_attempts': 1,
                    'preserve_batch_links': False,
                    'max_batch_lines': self._default_batch_line_limit(),
                    'disable_char_limits': False,
                    'proxy': "",
                    'cookies_use': False,
                    'cookies_browser': "chrome",
                    'enable_batch_fallbacks': False
                }
                self.config = default_config
                self.save_config()
                messagebox.showinfo("Settings Reset", "Settings have been reset to defaults. The app will now restart.")
                self.restart_program()
        reset_btn = tk.Button(
            bottom_left, text="Reset to defaults", font=fonts["label"],
            bg=theme["bg"], fg=theme["muted"],
            activebackground=theme["bg"], activeforeground=theme["text"],
            relief="flat", bd=0, padx=self._px(8), pady=self._px(2), command=on_reset_defaults, cursor="hand2"
        )
        reset_btn.pack(side="left", anchor="w")
        self.add_hover_effect(reset_btn, bg_normal=theme["bg"], fg_normal=theme["muted"], bg_hover=theme["bg"], fg_hover=theme["accent"])
        downloads_link = tk.Label(bottom_right, text="Open downloads folder", font=fonts["caption"], fg=theme["accent"], bg=theme["bg"], cursor="hand2")
        downloads_link.pack(side="right", anchor="e", padx=self._px((0, 12)))
        downloads_link.bind("<Button-1>", lambda e: self.open_downloads_folder())
        self.add_hover_effect(
            downloads_link,
            bg_normal=theme["bg"], fg_normal=theme["accent"],
            bg_hover=theme["bg"], fg_hover=theme["text"]
        )
        official_link = tk.Label(bottom_right, text="Official page", font=fonts["caption"], fg=theme["accent"], bg=theme["bg"], cursor="hand2")
        official_link.pack(side="right", anchor="e", padx=self._px((0, 12)))
        official_link.bind("<Button-1>", lambda e: self.open_url("https://justagwas.com/projects/mediacrate"))
        self.add_hover_effect(
            official_link,
            bg_normal=theme["bg"], fg_normal=theme["accent"],
            bg_hover=theme["bg"], fg_hover=theme["text"]
        )
        version_label = tk.Label(bottom_right, text="v1.1.0 ", font=fonts["caption"], fg=theme["muted"], bg=theme["bg"])
        version_label.pack(side="right", anchor="e", padx=self._px((0, 2)))
        self._configure_footer(bottom_bar, bottom_left, bottom_right, min_width=540)
        self.enforce_min_size()
        if entry_size:
            self._last_user_size = entry_size
            self._set_geometry_safe(entry_size[0], entry_size[1], manage_ignore=False)
        self._apply_window_constraints(min_extra=0)
        self._record_view_size("settings")
        self._show_view("settings")
        self._after(0, self._fade_in)

if __name__ == "__main__":
    enable_high_dpi()
    root = tk.Tk()
    try:
        dpi = root.winfo_fpixels("1i")
        root.tk.call("tk", "scaling", dpi / 72.0)
    except Exception:
        pass
    app = MediaDownloader(root)
    root.mainloop()
