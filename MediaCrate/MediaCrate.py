#Checkout my other projects! https://www.justagwas.com
#You can find the OFFICIAL CODE of this program here - https://sourceforge.net/p/mediacrate/code/ci/master/tree/
#You can also find the REPO in GitHub - https://github.com/Justagwas/MediaCrate
import tkinter as tk
from tkinter import messagebox, ttk
from yt_dlp import YoutubeDL
from yt_dlp.utils import DownloadCancelled
import threading
import os
import sys
import time
import queue
import logging
import requests
import shutil
import zipfile
import platform
import subprocess
from urllib.parse import urlparse
import ctypes as ct
from packaging.version import Version, InvalidVersion
from pathvalidate import sanitize_filename
import re
import xml.etree.ElementTree as ET
import json
import webbrowser

logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

THEME = {
    "bg": "#0f1115",
    "surface": "#171a22",
    "surface_alt": "#202637",
    "surface_alt_hover": "#2a3246",
    "border": "#2c354a",
    "text": "#e8ecf1",
    "muted": "#9aa4b2",
    "accent": "#4ac3ff",
    "accent_hover": "#2f9bd4",
    "success": "#22c55e",
    "success_hover": "#16a34a",
    "danger": "#f87171",
    "danger_hover": "#ef4444",
    "disabled_bg": "#242a38",
    "disabled_fg": "#6b7280",
}

def enable_high_dpi():
    if not sys.platform.startswith("win"):
        return
    try:
        ct.windll.shcore.SetProcessDpiAwareness(2)
    except Exception:
        try:
            ct.windll.user32.SetProcessDPIAware()
        except Exception:
            pass

if platform.system() == "Windows":
    import win32event, win32api, winerror
    mutex = win32event.CreateMutex(None, False, "MediaCrateMutex")
    if win32api.GetLastError() == winerror.ERROR_ALREADY_EXISTS:
        sys.exit("Application is already running.")

class MediaDownloader:
    def load_config(self):
        script_dir = self._app_dir()
        self.config_path = os.path.join(script_dir, 'MediaCrate_config.json')
        default_config = {
            'WARNING:': "This file is generated by MediaCrate. DO NOT CHANGE the contents of this file unless you know what you are doing.",
            'disable_warnings': False,
            'allow_batch_downloads': False,
            'disable_already_downloaded_prompts': False,
            'auto_check_updates': True,
            'enable_window_resizing': False,
            'ui_queue_cap': self._default_ui_queue_cap(),
            'download_location': self._default_download_dir(),
            'batch_concurrency': self._default_batch_concurrency(),
            'batch_retry_attempts': 1,
            'preserve_batch_links': False,
            'max_batch_lines': self._default_batch_line_limit(),
            'disable_char_limits': False
        }
        if os.path.exists(self.config_path):
            try:
                with open(self.config_path, 'r') as f:
                    config = json.load(f)
                for k, v in default_config.items():
                    if k not in config:
                        config[k] = v
                config['batch_concurrency'] = self._normalize_batch_concurrency(config.get('batch_concurrency'))
                config['max_batch_lines'] = self._normalize_batch_line_limit(config.get('max_batch_lines'))
                config['ui_queue_cap'] = self._normalize_ui_queue_cap(config.get('ui_queue_cap'))
                self.config = config
            except Exception:
                self.config = default_config
        else:
            self.config = default_config
            with open(self.config_path, 'w') as f:
                json.dump(self.config, f, indent=2)

    def save_config(self):
        with open(self.config_path, 'w') as f:
            json.dump(self.config, f, indent=2)

    def _is_windows(self):
        return sys.platform.startswith("win")

    def _app_dir(self):
        base = sys.executable if getattr(sys, 'frozen', False) else __file__
        return os.path.dirname(os.path.abspath(base))

    def _default_batch_concurrency(self):
        cpu_count = os.cpu_count() or 2
        return max(2, min(8, cpu_count))

    def _default_batch_line_limit(self):
        return 64

    def _default_ui_queue_cap(self):
        return 50

    def _default_download_dir(self):
        return os.path.join(os.path.expanduser("~"), "Downloads", "MediaCrate")

    def _resolve_ffmpeg_location(self):
        ffmpeg_name = "ffmpeg.exe" if self._is_windows() else "ffmpeg"
        ffmpeg_path = os.path.join(self._app_dir(), ffmpeg_name)
        if os.path.isfile(ffmpeg_path):
            return self._app_dir()
        return None

    def _resolve_js_runtime(self):
        node_name = "node.exe" if self._is_windows() else "node"
        node_path = os.path.join(self._app_dir(), node_name)
        if os.path.isfile(node_path):
            return {"node": {"path": node_path}}
        path_node = shutil.which("node")
        if path_node:
            return {"node": {"path": path_node}}
        return None

    def _normalize_batch_concurrency(self, value):
        try:
            value = int(value)
        except (TypeError, ValueError):
            return self._default_batch_concurrency()
        return max(1, min(64, value))

    def _normalize_batch_line_limit(self, value):
        try:
            value = int(value)
        except (TypeError, ValueError):
            return self._default_batch_line_limit()
        return max(1, min(1024, value))

    def _normalize_batch_retries(self, value):
        try:
            value = int(value)
        except (TypeError, ValueError):
            return 1
        return max(1, min(5, value))

    def _normalize_ui_queue_cap(self, value):
        try:
            value = int(value)
        except (TypeError, ValueError):
            return self._default_ui_queue_cap()
        return max(1, min(500, value))

    def _display_path(self, path):
        try:
            return os.path.normpath(os.path.expanduser(path))
        except Exception:
            return path

    def _sanitize_title(self, title):
        sanitized = self.sanitize_filename(title or "")
        sanitized = ''.join(c for c in sanitized if c.isalnum() or c in (' ', '.', '_', '-')).strip()
        return sanitized or 'media_file'

    def _sanitize_id(self, media_id):
        sanitized = self.sanitize_filename(str(media_id or ""))
        sanitized = ''.join(c for c in sanitized if c.isalnum() or c in ('-', '_')).strip()
        return sanitized

    def _build_base_filename(self, title, media_id):
        safe_title = self._sanitize_title(title)
        safe_id = self._sanitize_id(media_id)
        if safe_id:
            return f"{safe_title} [{safe_id}]"
        return safe_title

    def _register_active_temp(self, download_dir, temp_base):
        if not download_dir or not temp_base:
            return
        with self._active_part_lock:
            self._active_part_targets.add((download_dir, temp_base))

    def _unregister_active_temp(self, download_dir, temp_base):
        if not download_dir or not temp_base:
            return
        with self._active_part_lock:
            self._active_part_targets.discard((download_dir, temp_base))

    def _cleanup_temp_files(self, download_dir, temp_base, max_attempts=25, delay=0.2):
        if not download_dir or not temp_base:
            return
        prefix = (temp_base + ".").lower()
        remaining = True
        attempts = 0
        while remaining and attempts < max_attempts:
            remaining = False
            try:
                for fname in os.listdir(download_dir):
                    if not fname.lower().startswith(prefix):
                        continue
                    fpath = os.path.join(download_dir, fname)
                    try:
                        os.remove(fpath)
                    except PermissionError:
                        remaining = True
                    except FileNotFoundError:
                        pass
                    except Exception:
                        remaining = True
            except Exception:
                break
            if remaining:
                time.sleep(delay)
            attempts += 1

    def _cleanup_partial_downloads(self, max_attempts=25, delay=0.2):
        with self._active_part_lock:
            targets = list(self._active_part_targets)
            self._active_part_targets.clear()
        for download_dir, temp_base in targets:
            self._cleanup_temp_files(download_dir, temp_base, max_attempts=max_attempts, delay=delay)

    def open_url(self, url):
        try:
            webbrowser.open(url, new=2)
        except Exception as e:
            logging.error(f"Failed to open URL: {e}")

    def open_downloads_folder(self):
        downloads_dir = self._display_path(self.config.get('download_location', self._default_download_dir()))
        try:
            os.makedirs(downloads_dir, exist_ok=True)
            if self._is_windows():
                os.startfile(downloads_dir)
            elif sys.platform == "darwin":
                subprocess.run(["open", downloads_dir], check=False)
            else:
                subprocess.run(["xdg-open", downloads_dir], check=False)
        except Exception as e:
            logging.error(f"Failed to open downloads folder: {e}")
            self.run_on_ui_thread(messagebox.showerror, "Error", "Failed to open the downloads folder.")

    def set_controls_state(self, enabled):
        self.run_on_ui_thread(self._set_controls_state, enabled)

    def mark_progress_complete(self):
        self.run_on_ui_thread(self._mark_progress_complete)

    def _mark_progress_complete(self):
        if self.progress and isinstance(self.progress, tk.Canvas):
            self._set_progress_style("complete")
            self._set_progress_value(100)
            self._set_progress_text("100%")

    def _reset_progress_bar(self):
        if self.progress and isinstance(self.progress, tk.Canvas):
            self._set_progress_style("normal")
            self._set_progress_value(0)
            self._set_progress_text("0%")

    def _set_progress_text(self, text):
        if self._last_progress_text == text:
            return
        self._last_progress_text = text
        self._update_progress_canvas()

    def _set_progress_value(self, value):
        try:
            val = float(value)
        except Exception:
            val = 0.0
        val = max(0.0, min(100.0, val))
        if getattr(self, "_progress_value", None) == val:
            return
        self._progress_value = val
        self._update_progress_canvas()

    def _set_progress_style(self, style_name):
        if not self.progress or not isinstance(self.progress, tk.Canvas):
            return
        theme = self.theme
        if style_name == "complete":
            self._progress_fill_color = theme["success"]
        elif style_name == "disabled":
            self._progress_fill_color = theme["disabled_fg"]
        else:
            self._progress_fill_color = theme["accent"]
        self._update_progress_canvas()

    def _update_progress_canvas(self):
        canvas = self.progress
        if not canvas or not isinstance(canvas, tk.Canvas) or not canvas.winfo_exists():
            return
        if not getattr(self, "progress_fill_id", None) or not getattr(self, "progress_text_id", None):
            return
        width = canvas.winfo_width()
        height = canvas.winfo_height()
        if width <= 1 or height <= 1:
            return
        value = getattr(self, "_progress_value", 0.0)
        fill_width = int(width * (value / 100.0))
        canvas.coords(self.progress_fill_id, 0, 0, fill_width, height)
        canvas.itemconfig(self.progress_fill_id, fill=self._progress_fill_color)
        canvas.coords(self.progress_text_id, width / 2, height / 2)
        text = self._last_progress_text
        if text is None:
            text = f"{int(value)}%"
        canvas.itemconfig(self.progress_text_id, text=text)
        text_color = self.theme["bg"] if value >= 50 else self.theme["text"]
        canvas.itemconfig(self.progress_text_id, fill=text_color)

    def _set_text_var(self, var, text):
        if var is None:
            return
        try:
            key = var._name
        except Exception:
            key = str(var)
        self._pending_text_vars[key] = (var, text)
        if self._pending_text_vars_scheduled:
            return
        self._pending_text_vars_scheduled = True
        self.run_on_ui_thread(self._flush_text_vars)

    def _flush_text_vars(self):
        pending = self._pending_text_vars
        self._pending_text_vars = {}
        self._pending_text_vars_scheduled = False
        for key, payload in pending.items():
            if isinstance(payload, tuple) and len(payload) == 2:
                var, text = payload
            elif hasattr(key, "set"):
                var, text = key, payload
            else:
                continue
            try:
                var.set(text)
            except Exception:
                pass
        if self._pending_text_vars and not self._pending_text_vars_scheduled:
            self._pending_text_vars_scheduled = True
            self.run_on_ui_thread(self._flush_text_vars)

    def _is_descendant(self, widget, ancestor):
        try:
            while widget:
                if widget == ancestor:
                    return True
                parent_name = widget.winfo_parent()
                if not parent_name:
                    break
                widget = widget._nametowidget(parent_name)
        except Exception:
            return False
        return False

    def _begin_transition(self):
        if getattr(self, "_transitioning", False):
            return
        self._transitioning = True
        try:
            if getattr(self, "_transition_overlay", None):
                try:
                    self._transition_overlay.destroy()
                except Exception:
                    pass
            self.root.update_idletasks()
            w = self.root.winfo_width()
            h = self.root.winfo_height()
            inset = 6
            overlay = tk.Frame(self.root, bg=self.theme["bg"])
            overlay.place(
                x=inset,
                y=inset,
                width=max(1, w - inset * 2),
                height=max(1, h - inset * 2),
            )
            overlay.lift()
            self._transition_overlay = overlay
            self._transition_height = max(1, h - inset * 2)
        except Exception:
            self._transition_overlay = None
            self._transitioning = False

    def _fade_in(self, steps=8, delay=10):
        if not getattr(self, "_transitioning", False):
            return
        def step(i):
            try:
                overlay = getattr(self, "_transition_overlay", None)
                if overlay:
                    total = getattr(self, "_transition_height", overlay.winfo_height())
                    remaining = max(0, int(total - (total * (i / steps))))
                    if remaining > 0:
                        overlay.place_configure(height=remaining)
            except Exception:
                self._transitioning = False
                return
            if i < steps:
                self._after(delay, lambda: step(i + 1))
            else:
                try:
                    overlay = getattr(self, "_transition_overlay", None)
                    if overlay:
                        overlay.destroy()
                except Exception:
                    pass
                self._transition_overlay = None
                self._transitioning = False
        step(0)

    def _ensure_view_container(self):
        if getattr(self, "view_container", None) and self.view_container.winfo_exists():
            return
        self.view_container = tk.Frame(self.root, bg=self.theme["bg"])
        self.view_container.pack(fill="both", expand=True)
        self.view_container.grid_rowconfigure(0, weight=1)
        self.view_container.grid_columnconfigure(0, weight=1)
        self.main_view = tk.Frame(self.view_container, bg=self.theme["bg"])
        self.settings_view = tk.Frame(self.view_container, bg=self.theme["bg"])
        self.main_view.grid(row=0, column=0, sticky="nsew")
        self.settings_view.grid(row=0, column=0, sticky="nsew")

    def _show_view(self, view):
        self._current_view = view
        if view == "settings":
            self.settings_view.tkraise()
        else:
            self.main_view.tkraise()

    def _set_controls_state(self, enabled):
        state = tk.NORMAL if enabled else tk.DISABLED
        theme = self.theme
        if not enabled:
            self.update_format_buttons()
        if getattr(self, 'paste_button', None):
            self.paste_button.config(state=state, cursor="hand2" if enabled else "")
        if hasattr(self, 'url_entry') and self.url_entry.winfo_exists():
            self.url_entry.config(state=state)
        if hasattr(self, 'url_text') and self.url_text.winfo_exists():
            self.url_text.config(state=state)
        for btn in getattr(self, 'format_buttons', {}).values():
            if enabled:
                btn.config(state=tk.NORMAL, cursor="hand2")
            else:
                btn.config(
                    state=tk.DISABLED,
                    cursor="",
                    bg=btn.cget("bg"),
                    fg=btn.cget("fg"),
                )
        if hasattr(self, 'quality_combo') and self.quality_combo.winfo_exists():
            if enabled:
                combo_state = "readonly" if self.selected_format.get() not in ("mp3", "wav") else "disabled"
            else:
                combo_state = "disabled"
            self.quality_combo.config(state=combo_state)
        if getattr(self, 'download_button', None):
            if self.download_button.cget("text") == "Download":
                if enabled:
                    self.download_button.config(
                        state=tk.NORMAL,
                        cursor="hand2",
                        bg=theme["success"],
                        fg=theme["bg"]
                    )
                else:
                    self.download_button.config(
                        state=tk.DISABLED,
                        cursor="",
                        bg=theme["disabled_bg"],
                        fg=theme["disabled_fg"]
                    )
            else:
                self.download_button.config(state=state, cursor="hand2" if enabled else "")
        if getattr(self, 'abort_button', None):
            if self.downloading:
                self.abort_button.config(
                    state=tk.NORMAL,
                    cursor="hand2",
                    bg=theme["danger"],
                    fg=theme["bg"]
                )
            else:
                self.abort_button.config(
                    state=tk.DISABLED,
                    cursor="",
                    bg=theme["disabled_bg"],
                    fg=theme["disabled_fg"]
                )
        if hasattr(self, 'gear_btn'):
            self.gear_btn.config(state=state, cursor="hand2" if enabled else "")

    def _show_reset_button(self):
        theme = self.theme
        if not getattr(self, 'download_button', None):
            return
        self.download_button.config(
            text="Reset",
            command=self.create_widgets,
            state=tk.NORMAL,
            bg=theme["surface_alt"],
            fg=theme["text"]
        )
        self.add_hover_effect(
            self.download_button,
            bg_normal=theme["surface_alt"],
            fg_normal=theme["text"],
            bg_hover=theme["surface_alt_hover"],
            fg_hover=theme["accent"]
        )

    def add_hover_effect(self, btn, *, is_selected_func=None, is_enabled_func=None, bg_normal=None, fg_normal=None, bg_hover=None, fg_hover=None, bg_selected=None, fg_selected=None, bg_disabled=None, fg_disabled=None, is_hover_enabled_func=None):
        theme = self.theme if hasattr(self, "theme") else THEME
        bg_normal = bg_normal or theme["surface_alt"]
        fg_normal = fg_normal or theme["text"]
        bg_hover = bg_hover or theme["surface_alt_hover"]
        fg_hover = fg_hover or theme["accent"]
        bg_selected = bg_selected or theme["accent"]
        fg_selected = fg_selected or theme["bg"]
        bg_disabled = bg_disabled or theme["disabled_bg"]
        fg_disabled = fg_disabled or theme["disabled_fg"]
        def is_widget_disabled():
            try:
                return str(btn.cget("state")) == "disabled"
            except Exception:
                return False
        def on_enter(e):
            if is_widget_disabled():
                return
            if is_hover_enabled_func and not is_hover_enabled_func():
                return
            if is_selected_func and is_selected_func():
                return
            if is_enabled_func and not is_enabled_func():
                return
            btn.config(bg=bg_hover, fg=fg_hover)
        def on_leave(e):
            if is_widget_disabled():
                return
            if is_enabled_func and not is_enabled_func():
                btn.config(bg=bg_disabled, fg=fg_disabled)
            elif is_selected_func and is_selected_func():
                btn.config(bg=bg_selected, fg=fg_selected)
            else:
                btn.config(bg=bg_normal, fg=fg_normal)
        btn.bind("<Enter>", on_enter)
        btn.bind("<Leave>", on_leave)

    def run_on_ui_thread(self, func, *args, **kwargs):
        if threading.current_thread() is threading.main_thread() and not getattr(self, "_resizing_ui", False):
            func(*args, **kwargs)
        else:
            self.gui_queue.put(lambda: func(*args, **kwargs))
            self._schedule_gui_poll()

    def _after(self, delay_ms, callback, *, widget=None):
        target = widget or self.root
        safe_delay = max(0, int(delay_ms))
        return target.after(safe_delay, callback)

    def process_gui_queue(self):
        if not self.status_polling:
            self._gui_poll_scheduled = False
            return
        try:
            processed = 0
            max_tasks = self._max_gui_tasks_per_tick
            while processed < max_tasks:
                func = self.gui_queue.get_nowait()
                try:
                    func()
                except Exception as e:
                    logging.error(f"Error running UI task: {e}")
                processed += 1
        except queue.Empty:
            pass
        if not self.gui_queue.empty():
            self._after(16, self.process_gui_queue)
        else:
            self._gui_poll_scheduled = False

    def _schedule_gui_poll(self):
        if not self.status_polling:
            return
        if self._gui_poll_scheduled:
            return
        self._gui_poll_scheduled = True
        self._after(16, self.process_gui_queue)

    def __init__(self, root):
        self.load_config()
        self.root = root
        self.theme = THEME
        self.fonts = {
            "title": ("Bahnschrift", 18, "bold"),
            "subtitle": ("Bahnschrift", 11),
            "label": ("Bahnschrift", 10, "bold"),
            "body": ("Bahnschrift", 12),
            "caption": ("Bahnschrift", 9),
            "button": ("Bahnschrift", 11, "bold"),
            "mono": ("Cascadia Mono", 10),
        }
        self._geometry_initialized = False
        self._active_part_targets = set()
        self._active_part_lock = threading.Lock()
        self._abort_notified = False
        self._percent_started = False
        self._batch_saved_links = None
        self._batch_wheel_bound = False
        self._batch_min_extra = 240
        self._resize_wrap_job = None
        self._resize_wrap_active = False
        self._console_wrap_before_resize = None
        self._resizing_ui = False
        self._last_progress_text = None
        self._progress_value = 0.0
        self._progress_fill_color = self.theme["accent"]
        self._closing = False
        self._pending_text_vars = {}
        self._pending_text_vars_scheduled = False
        self._current_view = None
        self._settings_enter_size = None
        self._settings_forced_size = None
        self._settings_user_resized = False
        self._batch_active = None
        self._batch_enter_size = None
        self._batch_forced_size = None
        self._batch_user_resized = False
        self._batch_resize_pending = False
        self._window_resizing_enabled = bool(self.config.get('enable_window_resizing', True))
        self.root.title("MediaCrate") #Version 1.0.0
        self.root.configure(bg=self.theme["bg"])
        self.root.resizable(self._window_resizing_enabled, self._window_resizing_enabled)
        self.configure_styles()
        self.configure_geometry(prefer_tall=self.config.get('allow_batch_downloads', False))
        self._last_user_size = None
        self._ignore_resize = False
        self._gui_poll_scheduled = False
        self._status_poll_scheduled = False
        self._progress_poll_scheduled = False
        queue_cap = self._normalize_ui_queue_cap(self.config.get('ui_queue_cap'))
        self._max_gui_tasks_per_tick = queue_cap
        self._max_status_tasks_per_tick = queue_cap
        self._max_progress_updates_per_tick = queue_cap
        if self._window_resizing_enabled:
            self.root.bind("<Configure>", self._on_root_configure)
        self.root.protocol("WM_DELETE_WINDOW", self._on_window_close)
        self.status_queue = queue.Queue()
        self.progress_queue = queue.Queue()
        self.gui_queue = queue.Queue()
        self.downloading = False
        self.status_polling = True
        self.ydl = None
        self.abort_event = threading.Event()
        self.show_splash()
        self._after(100, self.deferred_startup)

    def center_window(self, width, height):
        self.root.update_idletasks()
        sw, sh = self.root.winfo_screenwidth(), self.root.winfo_screenheight()
        offset = int(min(120, sh * 0.08))
        x = int((sw / 2) - (width / 2))
        y = int((sh / 2) - (height / 2)) - offset
        x = max(0, x)
        y = max(0, y)
        self.root.geometry(f"{width}x{height}+{x}+{y}")

    def configure_geometry(self, prefer_tall=False):
        min_w, min_h = self._base_minsize()
        self.root.minsize(min_w, min_h)
        if not self._geometry_initialized:
            self._set_geometry_safe(min_w, min_h, center=True)
            self._geometry_initialized = True
            self._last_user_size = (min_w, min_h)

    def _base_minsize(self):
        screen_w = self.root.winfo_screenwidth()
        screen_h = self.root.winfo_screenheight()
        min_w = int(max(480, screen_w * 0.3)) + 80
        min_h = int(max(500, screen_h * 0.45))
        return min_w, min_h

    def _set_geometry_safe(self, width, height, *, center=False, manage_ignore=True):
        if manage_ignore:
            self._ignore_resize = True
        if center:
            self.center_window(width, height)
        else:
            self.root.geometry(f"{width}x{height}")
        if manage_ignore:
            self._after(120, lambda: setattr(self, "_ignore_resize", False))

    def _on_root_configure(self, event):
        if not getattr(self, "_window_resizing_enabled", True):
            return
        if event.widget is not self.root:
            return
        if self._ignore_resize:
            return
        if getattr(self, "_transitioning", False):
            return
        if self.root.state() != "normal":
            return
        if event.width < 1 or event.height < 1:
            return
        new_size = (event.width, event.height)
        if self._last_user_size == new_size:
            return
        if getattr(self, "_current_view", None) == "settings":
            forced_size = getattr(self, "_settings_forced_size", None)
            if not getattr(self, "_settings_user_resized", False) and forced_size:
                if abs(new_size[0] - forced_size[0]) <= 2 and abs(new_size[1] - forced_size[1]) <= 2:
                    self._settings_forced_size = new_size
                    return
                self._settings_user_resized = True
                if getattr(self, "_batch_active", False):
                    self._batch_user_resized = True
        if getattr(self, "_current_view", None) == "main" and getattr(self, "_batch_active", False):
            if getattr(self, "_batch_resize_pending", False):
                return
            forced_size = getattr(self, "_batch_forced_size", None)
            if not getattr(self, "_batch_user_resized", False) and forced_size:
                if abs(new_size[0] - forced_size[0]) <= 2 and abs(new_size[1] - forced_size[1]) <= 2:
                    self._batch_forced_size = new_size
                    return
                self._batch_user_resized = True
        self._last_user_size = new_size
        self._begin_resize_wrap()

    def _begin_resize_wrap(self):
        self._resizing_ui = True
        if not self._resize_wrap_active:
            self._set_console_wrap_during_resize(True)
        if self._resize_wrap_job:
            self.root.after_cancel(self._resize_wrap_job)
        self._resize_wrap_job = self._after(200, self._end_resize_wrap)

    def _end_resize_wrap(self):
        self._resize_wrap_job = None
        self._set_console_wrap_during_resize(False)
        self._resizing_ui = False

    def _set_console_wrap_during_resize(self, active):
        console = getattr(self, "console", None)
        console_frame = getattr(self, "console_frame", None)
        if not console or not console.winfo_exists():
            self._resize_wrap_active = False
            return
        if not console_frame or not console_frame.winfo_exists():
            self._resize_wrap_active = False
            return
        try:
            if active:
                if not self._resize_wrap_active:
                    self._console_wrap_before_resize = console.cget("wrap")
                    self._resize_wrap_active = True
                if console.cget("wrap") != "none":
                    console.config(wrap="none")
            else:
                if self._resize_wrap_active:
                    console.config(wrap=self._console_wrap_before_resize or "word")
                self._resize_wrap_active = False
        except Exception:
            self._resize_wrap_active = False

    def _apply_window_constraints(self, *, min_extra=0):
        min_w, min_h = self._base_minsize()
        target_min_h = min_h + min_extra
        self._ignore_resize = True
        self.root.minsize(min_w, target_min_h)
        if self._last_user_size:
            target_w = max(self._last_user_size[0], min_w)
            target_h = max(self._last_user_size[1], target_min_h)
        else:
            target_w = max(self.root.winfo_width(), min_w)
            target_h = max(self.root.winfo_height(), target_min_h)
        current_w = self.root.winfo_width()
        current_h = self.root.winfo_height()
        if target_w != current_w or target_h != current_h:
            self._set_geometry_safe(target_w, target_h, manage_ignore=False)
        self._after(120, lambda: setattr(self, "_ignore_resize", False))

    def configure_styles(self):
        theme = self.theme
        fonts = self.fonts if hasattr(self, "fonts") else None
        style = ttk.Style(self.root)
        style.theme_use("clam")
        style.configure("TFrame", background=theme["bg"])
        style.configure("TLabel", background=theme["bg"], foreground=theme["text"])
        style.configure(
            "Modern.Horizontal.TProgressbar",
            troughcolor=theme["surface_alt"],
            bordercolor=theme["border"],
            background=theme["accent"],
            lightcolor=theme["accent"],
            darkcolor=theme["accent"],
            thickness=72,
        )
        style.configure(
            "Modern.Small.Horizontal.TProgressbar",
            troughcolor=theme["surface_alt"],
            bordercolor=theme["border"],
            background=theme["accent"],
            lightcolor=theme["accent"],
            darkcolor=theme["accent"],
            thickness=16,
        )
        style.configure(
            "Modern.Small.Complete.Horizontal.TProgressbar",
            troughcolor=theme["surface_alt"],
            bordercolor=theme["border"],
            background=theme["success"],
            lightcolor=theme["success"],
            darkcolor=theme["success"],
            thickness=16,
        )
        style.configure(
            "Modern.Small.Disabled.Horizontal.TProgressbar",
            troughcolor=theme["surface_alt"],
            bordercolor=theme["border"],
            background=theme["disabled_fg"],
            lightcolor=theme["disabled_fg"],
            darkcolor=theme["disabled_fg"],
            thickness=16,
        )
        style.configure(
            "Modern.Complete.Horizontal.TProgressbar",
            troughcolor=theme["surface_alt"],
            bordercolor=theme["border"],
            background=theme["success"],
            lightcolor=theme["success"],
            darkcolor=theme["success"],
            thickness=72,
        )
        style.layout("Modern.Horizontal.TProgressbar",
            [('Horizontal.Progressbar.trough',
              {'children': [('Horizontal.Progressbar.pbar',
                             {'side': 'left', 'sticky': 'ns'})],
               'sticky': 'nswe'})]
        )
        style.layout("Modern.Small.Horizontal.TProgressbar",
            [('Horizontal.Progressbar.trough',
              {'children': [('Horizontal.Progressbar.pbar',
                             {'side': 'left', 'sticky': 'ns'})],
               'sticky': 'nswe'})]
        )
        style.layout("Modern.Small.Complete.Horizontal.TProgressbar",
            [('Horizontal.Progressbar.trough',
              {'children': [('Horizontal.Progressbar.pbar',
                             {'side': 'left', 'sticky': 'ns'})],
               'sticky': 'nswe'})]
        )
        style.layout("Modern.Small.Disabled.Horizontal.TProgressbar",
            [('Horizontal.Progressbar.trough',
              {'children': [('Horizontal.Progressbar.pbar',
                             {'side': 'left', 'sticky': 'ns'})],
               'sticky': 'nswe'})]
        )
        style.layout("Modern.Complete.Horizontal.TProgressbar",
            [('Horizontal.Progressbar.trough',
              {'children': [('Horizontal.Progressbar.pbar',
                             {'side': 'left', 'sticky': 'ns'})],
               'sticky': 'nswe'})]
        )
        combo_font = None
        listbox_font = None
        if fonts:
            combo_font = fonts["button"]
            listbox_font = (fonts["body"][0], max(9, fonts["button"][1] - 1))
        style.configure(
            "WhiteOnBlack.TCombobox",
            fieldbackground=theme["surface_alt"],
            background=theme["surface_alt"],
            foreground=theme["text"],
            selectforeground=theme["text"],
            selectbackground=theme["surface_alt"],
            arrowcolor=theme["text"],
            bordercolor=theme["border"],
            borderwidth=1,
            padding=14,
            focuscolor=theme["surface_alt"],
            focusthickness=0,
            font=combo_font
        )
        style.map(
            "WhiteOnBlack.TCombobox",
            fieldbackground=[('readonly', theme["surface_alt"]), ('disabled', theme["disabled_bg"]), ('focus', theme["surface_alt"])],
            background=[('readonly', theme["surface_alt"]), ('disabled', theme["disabled_bg"]), ('focus', theme["surface_alt"])],
            foreground=[('readonly', theme["text"]), ('disabled', theme["disabled_fg"]), ('focus', theme["text"])],
            selectbackground=[('readonly', theme["surface_alt"])],
            selectforeground=[('readonly', theme["text"])],
            arrowcolor=[('readonly', theme["text"]), ('disabled', theme["disabled_fg"])],
            bordercolor=[('focus', theme["border"]), ('!focus', theme["border"])],
            lightcolor=[('focus', theme["surface_alt"]), ('!focus', theme["surface_alt"])],
            darkcolor=[('focus', theme["surface_alt"]), ('!focus', theme["surface_alt"])],
        )
        style.configure(
            "Modern.Vertical.TScrollbar",
            background=theme["surface_alt"],
            troughcolor=theme["surface"],
            bordercolor=theme["border"],
            arrowcolor=theme["text"],
            lightcolor=theme["surface_alt"],
            darkcolor=theme["surface_alt"],
        )
        style.map(
            "Modern.Vertical.TScrollbar",
            background=[("active", theme["surface_alt_hover"]), ("pressed", theme["surface_alt_hover"])],
            arrowcolor=[("active", theme["text"]), ("pressed", theme["text"])],
        )
        style.configure(
            "Modern.Horizontal.TScrollbar",
            background=theme["surface_alt"],
            troughcolor=theme["surface"],
            bordercolor=theme["border"],
            arrowcolor=theme["text"],
            lightcolor=theme["surface_alt"],
            darkcolor=theme["surface_alt"],
        )
        style.map(
            "Modern.Horizontal.TScrollbar",
            background=[("active", theme["surface_alt_hover"]), ("pressed", theme["surface_alt_hover"])],
            arrowcolor=[("active", theme["text"]), ("pressed", theme["text"])],
        )
        self.root.option_add("*TCombobox*Listbox*Background", theme["surface"])
        self.root.option_add("*TCombobox*Listbox*Foreground", theme["text"])
        self.root.option_add("*TCombobox*Listbox*selectBackground", theme["accent"])
        self.root.option_add("*TCombobox*Listbox*selectForeground", theme["bg"])
        if listbox_font:
            self.root.option_add("*TCombobox*Listbox*Font", listbox_font)

    def enforce_min_size(self):
        self.root.update_idletasks()
        req_w = self.root.winfo_reqwidth()
        req_h = self.root.winfo_reqheight()
        min_w, min_h = self.root.minsize()
        screen_w = self.root.winfo_screenwidth()
        screen_h = self.root.winfo_screenheight()
        self.root.minsize(
            min(max(min_w, req_w), screen_w),
            min(max(min_h, req_h), screen_h)
        )

    def _sync_card_heights(self, *cards):
        self.root.update_idletasks()
        heights = [card.winfo_reqheight() for card in cards if card.winfo_exists()]
        if not heights:
            return
        target = max(heights)
        for card in cards:
            if card.winfo_exists():
                card.configure(height=target)
                card.grid_propagate(False)

    def _configure_footer(self, footer, left_frame, right_frame, min_width=520):
        def layout(compact):
            if getattr(footer, "_compact", None) == compact:
                return
            for child in footer.grid_slaves():
                child.grid_forget()
            footer.grid_columnconfigure(0, weight=1)
            footer.grid_columnconfigure(1, weight=1 if not compact else 0)
            if compact:
                left_frame.grid(row=0, column=0, sticky="w")
                right_frame.grid(row=1, column=0, sticky="e", pady=(4, 0))
            else:
                left_frame.grid(row=0, column=0, sticky="w")
                right_frame.grid(row=0, column=1, sticky="e")
            footer._compact = compact

        def on_resize(event):
            if getattr(footer, "_resize_job", None):
                footer.after_cancel(footer._resize_job)
            footer._resize_job = self._after(60, lambda: layout(event.width < min_width), widget=footer)

        footer.bind("<Configure>", on_resize)
        self._after(0, lambda: layout(footer.winfo_width() < min_width), widget=footer)

    def show_splash(self):
        theme = self.theme
        fonts = self.fonts
        self.splash_frame = tk.Frame(self.root, bg=theme["bg"])
        self.splash_frame.pack(fill="both", expand=True)
        tk.Label(self.splash_frame, text="MediaCrate", font=fonts["title"], fg=theme["text"], bg=theme["bg"]).pack(pady=40)
        tk.Label(self.splash_frame, text="Loading, please wait...", font=fonts["subtitle"], fg=theme["muted"], bg=theme["bg"]).pack(pady=10)
        self.progress = ttk.Progressbar(self.splash_frame, mode="indeterminate", length=280, style="Modern.Small.Horizontal.TProgressbar")
        self.progress.pack(pady=20)
        self.progress.start(10)

    def deferred_startup(self):
        self.set_icon()
        def after_updates():
            self.show_main_ui()
        def after_nodejs():
            if self.config.get('auto_check_updates', True):
                self.check_for_updates(on_complete=after_updates)
            else:
                after_updates()
        def after_ffmpeg():
            self._nodejs_callback = after_nodejs
            self.check_nodejs()
        self._ffmpeg_callback = after_ffmpeg
        self.check_ffmpeg()

    def show_main_ui(self):
        if getattr(self, 'splash_frame', None):
            self.splash_frame.destroy()
        self.create_widgets()
        is_batch = self.config.get('allow_batch_downloads', False)
        self._batch_active = is_batch
        self._after(0, lambda: self._apply_window_constraints(
            min_extra=self._batch_min_extra if is_batch else 0
        ))

    def set_icon(self):
        if not self._is_windows():
            return
        script_dir = self._app_dir()
        icon_path = os.path.join(script_dir, "icon.ico")
        if os.path.exists(icon_path):
            try:
                self.root.iconbitmap(icon_path)
                return
            except Exception as e:
                logging.error(f"Failed to set application icon: {e}")
        def apply_icon():
            try:
                self.root.iconbitmap(icon_path)
            except Exception as e:
                logging.error(f"Failed to set application icon: {e}")
                messagebox.showerror("Error", "Failed to set the application's icon.")
        def is_admin():
            try:
                return ct.windll.shell32.IsUserAnAdmin()
            except Exception:
                return False
        def run_as_admin():
            try:
                exe = os.path.abspath(sys.argv[0])
                params = " ".join([f'"{arg}"' for arg in sys.argv[1:]])
                ct.windll.shell32.ShellExecuteW(None, "runas", sys.executable, f'"{exe}" {params}', None, 1)
                os._exit(0)
            except Exception as e:
                logging.error(f"Failed to relaunch as admin: {e}")
                self.run_on_ui_thread(messagebox.showerror, "Error", "Failed to request administrator privileges.")
                return False
        if messagebox.askyesno("Download Icon", "The application's icon is missing. Would you like to download and install it?"):
            if not is_admin():
                if not run_as_admin():
                    return
            def download_icon():
                try:
                    icon_url = "https://sourceforge.net/p/mediacrate/code/ci/master/tree/icon.ico?format=raw"
                    logging.info(f"Downloading icon from {icon_url} to {icon_path}")
                    response = requests.get(icon_url, stream=True, timeout=10)
                    response.raise_for_status()
                    with open(icon_path, "wb") as file:
                        for chunk in response.iter_content(chunk_size=1024):
                            if chunk: file.write(chunk)
                    self.run_on_ui_thread(apply_icon)
                except Exception as e:
                    logging.error(f"Failed to download or set application icon: {e}")
                    self.run_on_ui_thread(messagebox.showerror, "Error", "Failed to download or set the application's icon.")
            threading.Thread(target=download_icon, daemon=True).start()

    def check_ffmpeg(self):
        script_dir = self._app_dir()
        ffmpeg_name = "ffmpeg.exe" if self._is_windows() else "ffmpeg"
        ffmpeg_path = os.path.join(script_dir, ffmpeg_name)
        ffmpeg_in_script_dir = os.path.exists(ffmpeg_path)
        ffmpeg_in_path = self.is_ffmpeg_installed()
        if not ffmpeg_in_script_dir and not ffmpeg_in_path:
            self._after(0, lambda: self.prompt_ffmpeg_download(callback=getattr(self, '_ffmpeg_callback', None)))
        else:
            if hasattr(self, '_ffmpeg_callback') and self._ffmpeg_callback:
                self._after(0, self._ffmpeg_callback)

    def check_nodejs(self):
        node_name = "node.exe" if self._is_windows() else "node"
        node_path = os.path.join(self._app_dir(), node_name)
        node_in_script_dir = os.path.exists(node_path)
        node_in_path = shutil.which("node") is not None
        if not node_in_script_dir and not node_in_path:
            self._after(0, lambda: self.prompt_nodejs_download(callback=getattr(self, '_nodejs_callback', None)))
        else:
            if hasattr(self, '_nodejs_callback') and self._nodejs_callback:
                self._after(0, self._nodejs_callback)

    def is_ffmpeg_installed(self):
        ffmpeg_name = "ffmpeg.exe" if self._is_windows() else "ffmpeg"
        ffmpeg_path = os.path.join(self._app_dir(), ffmpeg_name)
        if os.path.isfile(ffmpeg_path):
            return True
        return shutil.which("ffmpeg") is not None

    def prompt_ffmpeg_download(self, callback=None):
        theme = self.theme
        fonts = self.fonts
        bg_main = theme["bg"]
        fg_label = theme["text"]
        bg_button = theme["surface_alt"]
        fg_button = theme["text"]
        active_bg_button = theme["surface_alt_hover"]
        active_fg_button = theme["text"]
        status_var = tk.StringVar(value="")

        if not self._is_windows():
            for widget in self.root.winfo_children():
                widget.destroy()
            message = (
                "FFmpeg is required for this application to function.\n\n"
                "Please install FFmpeg using your package manager:\n"
                "macOS: brew install ffmpeg\n"
                "Linux: sudo apt install ffmpeg\n\n"
                "You can also download it from the official site."
            )
            tk.Label(self.root, text=message, bg=bg_main, fg=fg_label, wraplength=420, justify="left", font=fonts["body"]).pack(pady=10)
            link = tk.Label(
                self.root,
                text="https://ffmpeg.org/download.html",
                bg=bg_main,
                fg=theme["accent"],
                cursor="hand2",
                wraplength=420,
                justify="center",
                anchor="center",
                font=(fonts["caption"][0], fonts["caption"][1], "underline")
            )
            link.pack(pady=5)
            link.bind("<Button-1>", lambda e: self.open_url("https://ffmpeg.org/download.html"))
            button_frame = tk.Frame(self.root, bg=bg_main)
            button_frame.pack(pady=10)
            continue_button = tk.Button(
                button_frame, text="Continue", command=lambda: self.clear_ffmpeg_prompt(callback),
                font=fonts["button"], bg=bg_button, fg=fg_button,
                activebackground=active_bg_button, activeforeground=active_fg_button,
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            continue_button.pack(side=tk.LEFT, padx=5)
            self.add_hover_effect(continue_button, bg_normal=bg_button, fg_normal=fg_button, bg_hover=active_bg_button, fg_hover=active_fg_button)
            exit_button = tk.Button(
                button_frame, text="Exit", command=self.abort,
                font=fonts["button"], bg=theme["danger"], fg=theme["bg"],
                activebackground=theme["danger_hover"], activeforeground=theme["bg"],
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            exit_button.pack(side=tk.LEFT, padx=5)
            self.add_hover_effect(exit_button, bg_normal=theme["danger"], fg_normal=theme["bg"], bg_hover=theme["danger_hover"], fg_hover=theme["bg"])
            return

        def on_confirm():
            if messagebox.askyesno(
                "FFmpeg Not Installed",
                "If you don't install FFmpeg, there's a high chance the application won't work.\n\nAre you sure you want to continue without installing FFmpeg?"
            ):
                self.clear_ffmpeg_prompt(callback)
            else:
                self.prompt_ffmpeg_download(callback)

        def on_download_choice():
            for widget in self.root.winfo_children():
                widget.destroy()

            tk.Label(
                self.root,
                text="Choose how to download FFmpeg:",
                bg=bg_main,
                fg=fg_label,
                wraplength=420,
                font=fonts["subtitle"],
                justify="center"
            ).pack(pady=10)

            tk.Label(
                self.root,
                text="Automatic (Recommended): The application will download and install FFmpeg after you are introduced to the legal disclaimer.\n\n"
                     "Manual: Follow the steps to download and install FFmpeg yourself.",
                bg=bg_main,
                fg=fg_label,
                wraplength=420,
                justify="left",
                font=fonts["body"]
            ).pack(pady=10)

            button_frame = tk.Frame(self.root, bg=bg_main)
            button_frame.pack(pady=10)

            auto_button = tk.Button(
                button_frame, text="Automatic", command=show_legal_disclaimer,
                font=fonts["button"],
                bg=bg_button, fg=fg_button,
                activebackground=active_bg_button, activeforeground=active_fg_button,
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            auto_button.pack(side=tk.LEFT, padx=5)
            self.add_hover_effect(auto_button, bg_normal=bg_button, fg_normal=fg_button, bg_hover=active_bg_button, fg_hover=active_fg_button)
            manual_button = tk.Button(
                button_frame, text="Manual", command=show_manual_steps,
                font=fonts["button"],
                bg=bg_button, fg=fg_button,
                activebackground=active_bg_button, activeforeground=active_fg_button,
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            manual_button.pack(side=tk.LEFT, padx=5)
            self.add_hover_effect(manual_button, bg_normal=bg_button, fg_normal=fg_button, bg_hover=active_bg_button, fg_hover=active_fg_button)

        def show_legal_disclaimer():
            for widget in self.root.winfo_children():
                widget.destroy()

            tk.Label(
                self.root,
                text="Legal Disclaimer:",
                bg=bg_main,
                fg=fg_label,
                font=fonts["subtitle"],
                justify="center"
            ).pack(pady=10)

            tk.Label(
                self.root,
                text="By proceeding, you acknowledge that FFmpeg is a third-party software.\n\n"
                     "The application will download FFmpeg from an official Windows build.\n\n"
                     "FFmpeg is licensed under the GNU Lesser General Public License (LGPL) version 2.1 or later.\n"
                     "For more details, visit:",
                bg=bg_main,
                fg=fg_label,
                wraplength=420,
                justify="left",
                font=fonts["body"]
            ).pack(pady=0)
            link = tk.Label(
                self.root,
                text="https://ffmpeg.org/legal.html",
                bg=bg_main,
                fg=theme["accent"],
                cursor="hand2",
                wraplength=360,
                justify="center",
                anchor="center",
                font=(fonts["caption"][0], fonts["caption"][1], "underline")
            )
            link.pack(pady=5)
            link.bind("<Button-1>", lambda e: self.open_url("https://ffmpeg.org/legal.html"))

            button_frame = tk.Frame(self.root, bg=bg_main)
            button_frame.pack(pady=10)

            self.proceed_button = tk.Button(
                button_frame, text="Proceed", command=lambda: [self.proceed_button.config(state=tk.DISABLED), on_download()],
                font=fonts["button"],
                bg=bg_button, fg=fg_button,
                activebackground=active_bg_button, activeforeground=active_fg_button,
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            self.proceed_button.pack(side=tk.LEFT, padx=5)
            self.add_hover_effect(self.proceed_button, bg_normal=bg_button, fg_normal=fg_button, bg_hover=active_bg_button, fg_hover=active_fg_button)
            cancel_button = tk.Button(
                button_frame, text="Cancel", command=on_confirm,
                font=fonts["button"],
                bg=theme["danger"], fg=theme["bg"],
                activebackground=theme["danger_hover"], activeforeground=theme["bg"],
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            cancel_button.pack(side=tk.LEFT, padx=5)
            self.add_hover_effect(cancel_button, bg_normal=theme["danger"], fg_normal=theme["bg"], bg_hover=theme["danger_hover"], fg_hover=theme["bg"])
            status_label = tk.Label(self.root, textvariable=status_var, bg=bg_main, fg=theme["muted"], wraplength=420, justify="left", font=fonts["caption"])
            status_label.pack(pady=(4, 0))

        def show_manual_steps():
            for widget in self.root.winfo_children():
                widget.destroy()

            tk.Label(
                self.root,
                text="Manual Download Steps:",
                bg=bg_main,
                fg=fg_label,
                font=fonts["subtitle"],
                justify="center"
            ).pack(pady=10)

            tk.Label(
                self.root,
                text="1. Visit the official FFmpeg build page:",
                bg=bg_main,
                fg=fg_label,
                wraplength=420,
                justify="center",
                font=fonts["body"]
            ).pack(pady=0)

            link = tk.Label(
                self.root,
                text="https://github.com/GyanD/codexffmpeg/releases/latest",
                bg=bg_main,
                fg=theme["accent"],
                cursor="hand2",
                wraplength=420,
                justify="center",
                anchor="center",
                font=(fonts["caption"][0], fonts["caption"][1], "underline")
            )
            link.pack(pady=0)
            link.bind("<Button-1>", lambda e: self.open_url("https://github.com/GyanD/codexffmpeg/releases/latest"))

            tk.Label(
                self.root,
                text="2. Download the file named 'ffmpeg-x.x.x-essentials_build.zip'.\n"
                     "3. Extract the downloaded ZIP file.\n"
                     "4. Locate the 'ffmpeg.exe' file within the extracted folder and its subfolders.\n"
                     "5. Move the 'ffmpeg.exe' file to the same directory as this application.",
                bg=bg_main,
                fg=fg_label,
                wraplength=420,
                justify="left",
                font=fonts["body"]
            ).pack(pady=5)

            tk.Label(
                self.root,
                text="Once you have completed these steps, restart the application.",
                bg=bg_main,
                fg=fg_label,
                wraplength=420,
                justify="left",
                font=fonts["caption"]
            ).pack(pady=10)

            ok_button = tk.Button(
                self.root, text="OK", command=self.terminate_program,
                font=fonts["button"],
                bg=bg_button, fg=fg_button,
                activebackground=active_bg_button, activeforeground=active_fg_button,
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            ok_button.pack(pady=10)
            self.add_hover_effect(ok_button, bg_normal=bg_button, fg_normal=fg_button, bg_hover=active_bg_button, fg_hover=active_fg_button)

        def on_download():
            def download_ffmpeg():
                try:
                    self.set_status("Downloading FFmpeg... (DO NOT CLOSE APPLICATION)")
                    download_url = "https://github.com/GyanD/codexffmpeg/releases/download/2026-01-14-git-6c878f8b82/ffmpeg-2026-01-14-git-6c878f8b82-essentials_build.zip"
                    script_dir = self._app_dir()
                    download_path = os.path.join(script_dir, "ffmpeg-essentials.zip")
                    extract_path = os.path.join(script_dir, "ffmpeg_temp")

                    logging.info(f"Downloading FFmpeg from {download_url} to {download_path}")
                    response = requests.get(download_url, stream=True, timeout=180)
                    response.raise_for_status()
                    total = int(response.headers.get('content-length') or 0)
                    downloaded = 0
                    with open(download_path, "wb") as file:
                        for chunk in response.iter_content(chunk_size=1024):
                            if chunk:
                                file.write(chunk)
                                downloaded += len(chunk)
                                if total:
                                    percent = int(downloaded * 100 / total)
                                    mb_done = downloaded / (1024 * 1024)
                                    mb_total = total / (1024 * 1024)
                                    self._set_text_var(status_var, f"Downloading FFmpeg... {percent}% ({mb_done:.1f}/{mb_total:.1f} MB)")
                                else:
                                    mb_done = downloaded / (1024 * 1024)
                                    self._set_text_var(status_var, f"Downloading FFmpeg... {mb_done:.1f} MB")

                    self.set_status("Extracting FFmpeg...")
                    self._set_text_var(status_var, "Extracting FFmpeg...")
                    logging.info(f"Extracting FFmpeg to {extract_path}")
                    os.makedirs(extract_path, exist_ok=True)
                    with zipfile.ZipFile(download_path, 'r') as zip_ref:
                        zip_ref.extractall(extract_path)

                    bin_folder = next(
                        (os.path.join(root, "ffmpeg.exe") for root, _, files in os.walk(extract_path) if "ffmpeg.exe" in files),
                        None
                    )
                    if bin_folder:
                        shutil.copy(bin_folder, script_dir)
                        logging.info(f"Copied ffmpeg.exe to {script_dir}")
                    else:
                        raise FileNotFoundError("ffmpeg.exe not found in the downloaded archive.")

                    os.remove(download_path)
                    shutil.rmtree(extract_path)

                    self.set_status("FFmpeg installed successfully!")
                    self._set_text_var(status_var, "FFmpeg installed successfully.")
                    def finish_install():
                        messagebox.showinfo("Success", "FFmpeg has been installed successfully. The app will now restart.")
                        self.restart_program()
                    self.run_on_ui_thread(finish_install)
                except requests.exceptions.Timeout:
                    self.set_status("FFmpeg download timed out.")
                    self._set_text_var(status_var, "FFmpeg download timed out.")
                    self.run_on_ui_thread(messagebox.showerror, "Error", "FFmpeg download timed out. Please check your connection or download it manually.")
                except requests.exceptions.RequestException as e:
                    self.set_status("FFmpeg download failed.")
                    self._set_text_var(status_var, "FFmpeg download failed.")
                    self.run_on_ui_thread(messagebox.showerror, "Error", f"FFmpeg download failed: {e}")
                except Exception as e:
                    self.set_status("FFmpeg installation failed.")
                    self._set_text_var(status_var, "FFmpeg installation failed.")
                    self.run_on_ui_thread(messagebox.showerror, "Error", f"Failed to download and install FFmpeg: {e}")
            threading.Thread(target=download_ffmpeg, daemon=True).start()

        for widget in self.root.winfo_children():
            widget.destroy()
        message = (
            "The FFmpeg framework, which is essential for this application to function, is missing from your system.\n\n"
            "Without this dependency, the application will not work.\n\n"
            "Would you like to download and install FFmpeg now?"
        )
        tk.Label(self.root, text=message, bg=bg_main, fg=fg_label, wraplength=420, justify="left", font=fonts["body"]).pack(pady=10)

        button_frame = tk.Frame(self.root, bg=bg_main)
        button_frame.pack(pady=10)

        proceed_button = tk.Button(button_frame, text="Yes", command=on_download_choice, font=fonts["button"], bg=bg_button, fg=fg_button, activebackground=active_bg_button, activeforeground=active_fg_button, relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2")
        proceed_button.pack(side=tk.LEFT, padx=5)
        self.add_hover_effect(proceed_button, bg_normal=bg_button, fg_normal=fg_button, bg_hover=active_bg_button, fg_hover=active_fg_button)
        confirm_button = tk.Button(button_frame, text="Cancel", command=on_confirm, font=fonts["button"], bg=theme["danger"], fg=theme["bg"], activebackground=theme["danger_hover"], activeforeground=theme["bg"], relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2")
        confirm_button.pack(side=tk.LEFT, padx=5)
        self.add_hover_effect(confirm_button, bg_normal=theme["danger"], fg_normal=theme["bg"], bg_hover=theme["danger_hover"], fg_hover=theme["bg"])

    def clear_ffmpeg_prompt(self, callback=None):
        for widget in self.root.winfo_children():
            widget.destroy()
        self.show_splash()
        if callback:
            callback()

    def prompt_nodejs_download(self, callback=None):
        theme = self.theme
        fonts = self.fonts
        bg_main = theme["bg"]
        fg_label = theme["text"]
        bg_button = theme["surface_alt"]
        fg_button = theme["text"]
        active_bg_button = theme["surface_alt_hover"]
        active_fg_button = theme["text"]
        status_var = tk.StringVar(value="")

        if not self._is_windows():
            for widget in self.root.winfo_children():
                widget.destroy()
            message = (
                "A JavaScript runtime (Node.js) is essential for reliable extraction and other features.\n"
                "Without it, some formats may be missing.\n\n"
                "Please install Node.js using your package manager:\n"
                "macOS: brew install node\n"
                "Linux: sudo apt install nodejs\n\n"
                "You can also download it from the official site."
            )
            tk.Label(self.root, text=message, bg=bg_main, fg=fg_label, wraplength=420, justify="left", font=fonts["body"]).pack(pady=10)
            link = tk.Label(
                self.root,
                text="https://nodejs.org/en/download",
                bg=bg_main,
                fg=theme["accent"],
                cursor="hand2",
                wraplength=420,
                justify="center",
                anchor="center",
                font=(fonts["caption"][0], fonts["caption"][1], "underline")
            )
            link.pack(pady=5)
            link.bind("<Button-1>", lambda e: self.open_url("https://nodejs.org/en/download"))
            button_frame = tk.Frame(self.root, bg=bg_main)
            button_frame.pack(pady=10)
            continue_button = tk.Button(
                button_frame, text="Continue", command=lambda: self.clear_nodejs_prompt(callback),
                font=fonts["button"], bg=bg_button, fg=fg_button,
                activebackground=active_bg_button, activeforeground=active_fg_button,
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            continue_button.pack(side=tk.LEFT, padx=5)
            self.add_hover_effect(continue_button, bg_normal=bg_button, fg_normal=fg_button, bg_hover=active_bg_button, fg_hover=active_fg_button)
            exit_button = tk.Button(
                button_frame, text="Exit", command=self.abort,
                font=fonts["button"], bg=theme["danger"], fg=theme["bg"],
                activebackground=theme["danger_hover"], activeforeground=theme["bg"],
                relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2"
            )
            exit_button.pack(side=tk.LEFT, padx=5)
            self.add_hover_effect(exit_button, bg_normal=theme["danger"], fg_normal=theme["bg"], bg_hover=theme["danger_hover"], fg_hover=theme["bg"])
            return

        def on_confirm():
            if messagebox.askyesno(
                "Node.js Not Installed",
                "A JavaScript runtime (Node.js) is essential for reliable extraction and some formats may be missing without it.\n\nAre you sure you want to continue without installing Node.js?"
            ):
                self.clear_nodejs_prompt(callback)
            else:
                self.prompt_nodejs_download(callback)

        def on_download():
            def set_buttons_state(state):
                proceed_button.config(state=state)
                confirm_button.config(state=state)
            set_buttons_state(tk.DISABLED)
            def download_nodejs():
                try:
                    self.set_status("Downloading Node.js... (DO NOT CLOSE APPLICATION)")
                    download_url = "https://nodejs.org/dist/v24.13.0/node-v24.13.0-win-x64.zip"
                    script_dir = self._app_dir()
                    download_path = os.path.join(script_dir, "nodejs.zip")
                    extract_path = os.path.join(script_dir, "nodejs_temp")

                    logging.info(f"Downloading Node.js from {download_url} to {download_path}")
                    response = requests.get(download_url, stream=True, timeout=180)
                    response.raise_for_status()
                    total = int(response.headers.get('content-length') or 0)
                    downloaded = 0
                    with open(download_path, "wb") as file:
                        for chunk in response.iter_content(chunk_size=1024):
                            if chunk:
                                file.write(chunk)
                                downloaded += len(chunk)
                                if total:
                                    percent = int(downloaded * 100 / total)
                                    mb_done = downloaded / (1024 * 1024)
                                    mb_total = total / (1024 * 1024)
                                    self._set_text_var(status_var, f"Downloading Node.js... {percent}% ({mb_done:.1f}/{mb_total:.1f} MB)")
                                else:
                                    mb_done = downloaded / (1024 * 1024)
                                    self._set_text_var(status_var, f"Downloading Node.js... {mb_done:.1f} MB")

                    self.set_status("Extracting Node.js...")
                    self._set_text_var(status_var, "Extracting Node.js...")
                    logging.info(f"Extracting Node.js to {extract_path}")
                    os.makedirs(extract_path, exist_ok=True)
                    with zipfile.ZipFile(download_path, 'r') as zip_ref:
                        zip_ref.extractall(extract_path)

                    node_binary = next(
                        (os.path.join(root, "node.exe") for root, _, files in os.walk(extract_path) if "node.exe" in files),
                        None
                    )
                    if node_binary:
                        shutil.copy(node_binary, script_dir)
                        logging.info(f"Copied node.exe to {script_dir}")
                    else:
                        raise FileNotFoundError("node.exe not found in the downloaded archive.")

                    os.remove(download_path)
                    shutil.rmtree(extract_path)

                    self.set_status("Node.js installed successfully!")
                    self._set_text_var(status_var, "Node.js installed successfully.")
                    def finish_install():
                        messagebox.showinfo("Success", "Node.js has been installed successfully.")
                        self.clear_nodejs_prompt(callback)
                    self.run_on_ui_thread(finish_install)
                except requests.exceptions.Timeout:
                    self.set_status("Node.js download timed out.")
                    self._set_text_var(status_var, "Node.js download timed out.")
                    self.run_on_ui_thread(set_buttons_state, tk.NORMAL)
                    self.run_on_ui_thread(messagebox.showerror, "Error", "Node.js download timed out. Please check your connection or download it manually.")
                except requests.exceptions.RequestException as e:
                    self.set_status("Node.js download failed.")
                    self._set_text_var(status_var, "Node.js download failed.")
                    self.run_on_ui_thread(set_buttons_state, tk.NORMAL)
                    self.run_on_ui_thread(messagebox.showerror, "Error", f"Node.js download failed: {e}")
                except Exception as e:
                    self.set_status("Node.js installation failed.")
                    self._set_text_var(status_var, "Node.js installation failed.")
                    self.run_on_ui_thread(set_buttons_state, tk.NORMAL)
                    self.run_on_ui_thread(messagebox.showerror, "Error", f"Failed to download and install Node.js: {e}")
            threading.Thread(target=download_nodejs, daemon=True).start()

        for widget in self.root.winfo_children():
            widget.destroy()
        message = (
            "A JavaScript runtime (Node.js) is essential for reliable extraction and other features.\n"
            "Without it, some formats may be missing.\n\n"
            "Would you like to download and install Node.js now?"
        )
        tk.Label(self.root, text=message, bg=bg_main, fg=fg_label, wraplength=420, justify="left", font=fonts["body"]).pack(pady=10)

        button_frame = tk.Frame(self.root, bg=bg_main)
        button_frame.pack(pady=10)

        proceed_button = tk.Button(button_frame, text="Yes", command=on_download, font=fonts["button"], bg=bg_button, fg=fg_button, activebackground=active_bg_button, activeforeground=active_fg_button, relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2")
        proceed_button.pack(side=tk.LEFT, padx=5)
        self.add_hover_effect(proceed_button, bg_normal=bg_button, fg_normal=fg_button, bg_hover=active_bg_button, fg_hover=active_fg_button)
        confirm_button = tk.Button(button_frame, text="Cancel", command=on_confirm, font=fonts["button"], bg=theme["danger"], fg=theme["bg"], activebackground=theme["danger_hover"], activeforeground=theme["bg"], relief="flat", bd=0, padx=12, pady=2, width=12, cursor="hand2")
        confirm_button.pack(side=tk.LEFT, padx=5)
        self.add_hover_effect(confirm_button, bg_normal=theme["danger"], fg_normal=theme["bg"], bg_hover=theme["danger_hover"], fg_hover=theme["bg"])
        status_label = tk.Label(self.root, textvariable=status_var, bg=bg_main, fg=theme["muted"], wraplength=420, justify="left", font=fonts["caption"])
        status_label.pack(pady=(4, 0))

    def clear_nodejs_prompt(self, callback=None):
        for widget in self.root.winfo_children():
            widget.destroy()
        self.show_splash()
        if callback:
            callback()

    def create_widgets(self, force_rebuild=True, switch_view=True):
        if switch_view:
            self._begin_transition()
        self._ensure_view_container()
        if not force_rebuild and getattr(self, "_main_built", False):
            is_batch = self.config.get('allow_batch_downloads', False)
            self._apply_window_constraints(min_extra=self._batch_min_extra if is_batch else 0)
            if switch_view:
                self._show_view("main")
                self._after(0, self._fade_in)
            return

        saved_url_entry = None
        saved_url_text = None
        if getattr(self, "url_entry", None) and self.url_entry.winfo_exists():
            saved_url_entry = self.url_entry.get()
        if getattr(self, "url_text", None) and self.url_text.winfo_exists():
            saved_url_text = self.url_text.get("1.0", tk.END).rstrip("\n")
        prev_format = self.selected_format.get() if getattr(self, "selected_format", None) else None
        prev_quality = self.selected_quality.get() if getattr(self, "selected_quality", None) else None

        for widget in self.main_view.winfo_children():
            widget.destroy()

        theme = self.theme
        fonts = self.fonts
        is_batch = self.config.get('allow_batch_downloads', False)
        self.configure_styles()
        self.configure_geometry(prefer_tall=is_batch)
        if not is_batch and self._batch_wheel_bound:
            self.root.unbind_all("<MouseWheel>")
            self.root.unbind_all("<Button-4>")
            self.root.unbind_all("<Button-5>")
            self._batch_wheel_bound = False

        outer = tk.Frame(self.main_view, bg=theme["bg"])
        outer.pack(fill="both", expand=True)
        outer.grid_columnconfigure(0, weight=1)
        outer.grid_rowconfigure(2, weight=1)

        header = tk.Frame(outer, bg=theme["bg"], padx=24, pady=10)
        header.grid(row=0, column=0, sticky="ew", pady=(18, 0))
        title = tk.Label(header, text="MediaCrate", font=fonts["title"], fg=theme["text"], bg=theme["bg"])
        subtitle_text = "Download video or audio from any media URL."
        if is_batch:
            subtitle_text = "Download multiple media URLs in one batch."
        subtitle = tk.Label(header, text=subtitle_text, font=fonts["subtitle"], fg=theme["muted"], bg=theme["bg"])
        title.pack(anchor="w")
        subtitle.pack(anchor="w", pady=(4, 0))

        separator = ttk.Separator(outer, orient="horizontal")
        separator.grid(row=1, column=0, sticky="ew", padx=24)

        self.main_frame = tk.Frame(outer, bg=theme["bg"], padx=24, pady=12)
        self.main_frame.grid(row=2, column=0, sticky="nsew")
        self.main_frame.grid_columnconfigure(0, weight=1, uniform="content")
        self.main_frame.grid_columnconfigure(1, weight=1, uniform="content")
        if is_batch:
            self.main_frame.grid_rowconfigure(0, weight=1, minsize=360)
            self.main_frame.grid_rowconfigure(4, weight=0, minsize=120)
        else:
            self.main_frame.grid_rowconfigure(4, weight=1, minsize=120)

        url_card = tk.Frame(
            self.main_frame,
            bg=theme["surface"],
            highlightthickness=1,
            highlightbackground=theme["border"],
            highlightcolor=theme["border"],
        )
        url_card_sticky = "nsew" if is_batch else "ew"
        url_card.grid(row=0, column=0, columnspan=2, sticky=url_card_sticky, pady=(0, 12))
        url_card.grid_columnconfigure(0, weight=1)
        url_card.grid_rowconfigure(0, weight=1)
        self.url_card = url_card

        url_left = tk.Frame(url_card, bg=theme["surface"])
        url_left.grid(row=0, column=0, sticky="nsew", padx=16, pady=14)
        url_title = "Media URLs" if is_batch else "Media URL"
        tk.Label(url_left, text=url_title, font=fonts["label"], fg=theme["muted"], bg=theme["surface"]).pack(anchor="w")

        if is_batch:
            url_text_frame = tk.Frame(
                url_left,
                bg=theme["surface_alt"],
                highlightthickness=1,
                highlightbackground=theme["border"],
                highlightcolor=theme["border"],
            )
            url_text_frame.pack(fill=tk.BOTH, expand=True, pady=(6, 0))
            url_text_frame.configure(height=360)
            url_text_frame.pack_propagate(False)
            url_text_frame.grid_columnconfigure(0, weight=1)
            url_text_frame.grid_rowconfigure(0, weight=1)
            text_row = tk.Frame(url_text_frame, bg=theme["surface_alt"])
            text_row.grid(row=0, column=0, sticky="nsew", padx=3, pady=(6, 0))
            self.url_text_frame = url_text_frame
            self.batch_line_numbers = tk.Text(
                text_row,
                font=fonts["body"],
                bg=theme["surface_alt"],
                fg=theme["muted"],
                relief="flat",
                bd=0,
                width=3,
                wrap="none",
                highlightthickness=0,
                state="disabled",
                takefocus=0
            )
            self.batch_line_numbers.pack(side=tk.LEFT, fill=tk.Y)
            self.batch_line_numbers.bind("<Button-1>", lambda e: "break")
            self.batch_line_numbers.bind("<Key>", lambda e: "break")
            self.url_text = tk.Text(
                text_row,
                font=fonts["body"],
                bg=theme["surface_alt"],
                fg=theme["text"],
                insertbackground=theme["text"],
                selectbackground=theme["accent"],
                selectforeground=theme["bg"],
                relief="flat",
                bd=0,
                height=4,
                wrap="none",
                highlightthickness=0,
                undo=True,
                autoseparators=True,
                maxundo=50,
            )
            self.url_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            text_seed = saved_url_text
            if not text_seed:
                text_seed = self._batch_saved_links or ""
            if text_seed:
                self.url_text.insert("1.0", text_seed)
            self._apply_batch_text_limits()
            def update_line_numbers():
                if not self.url_text.winfo_exists():
                    return
                line_count = int(self.url_text.index("end-1c").split(".")[0])
                lines = "\n".join(f"{i}." for i in range(1, line_count + 1))
                self.batch_line_numbers.config(state="normal")
                self.batch_line_numbers.delete("1.0", tk.END)
                self.batch_line_numbers.insert("1.0", lines)
                self.batch_line_numbers.config(state="disabled")
                first, _ = self.url_text.yview()
                self.batch_line_numbers.yview_moveto(first)
            def sync_line_numbers(first, last):
                try:
                    self.batch_line_numbers.yview_moveto(first)
                except Exception:
                    pass
            self.url_text.config(yscrollcommand=sync_line_numbers)
            def on_shift_mousewheel(event):
                if event.delta:
                    self.url_text.xview_scroll(int(-1*(event.delta/120)), "units")
                elif event.num == 5:
                    self.url_text.xview_scroll(1, "units")
                elif event.num == 4:
                    self.url_text.xview_scroll(-1, "units")
                return "break"
            def on_mousewheel(event):
                if event.state & 0x1:
                    return "break"
                if event.delta:
                    self.url_text.yview_scroll(int(-1*(event.delta/120)), "units")
                elif event.num == 5:
                    self.url_text.yview_scroll(1, "units")
                elif event.num == 4:
                    self.url_text.yview_scroll(-1, "units")
                return "break"
            self.url_text.bind("<MouseWheel>", on_mousewheel)
            self.url_text.bind("<Button-4>", on_mousewheel)
            self.url_text.bind("<Button-5>", on_mousewheel)
            self.batch_line_numbers.bind("<MouseWheel>", on_mousewheel)
            self.batch_line_numbers.bind("<Button-4>", on_mousewheel)
            self.batch_line_numbers.bind("<Button-5>", on_mousewheel)
            self.url_text.bind("<Shift-MouseWheel>", on_shift_mousewheel)
            self.url_text.bind("<Shift-Button-4>", on_shift_mousewheel)
            self.url_text.bind("<Shift-Button-5>", on_shift_mousewheel)
            self.batch_line_numbers.bind("<Shift-MouseWheel>", on_shift_mousewheel)
            self.batch_line_numbers.bind("<Shift-Button-4>", on_shift_mousewheel)
            self.batch_line_numbers.bind("<Shift-Button-5>", on_shift_mousewheel)
            def on_text_modified(event):
                self.url_text.edit_modified(False)
                self._apply_batch_text_limits()
                self.url_text.edit_modified(False)
                update_line_numbers()
            self.url_text.bind("<<Modified>>", on_text_modified)
            self._after(0, update_line_numbers)
            self.paste_button = None
            self.batch_progress_frame = None

            def batch_paste_handler(event):
                try:
                    clipboard = self.root.clipboard_get()
                except tk.TclError:
                    return "break"
                try:
                    self.url_text.edit_separator()
                except Exception:
                    pass
                max_lines = self._normalize_batch_line_limit(self.config.get('max_batch_lines'))
                disable_limits = self.config.get('disable_char_limits', False)
                existing = [line for line in self.url_text.get("1.0", "end-1c").splitlines() if line.strip()]
                for line in clipboard.splitlines():
                    line = line.strip()
                    if not line:
                        continue
                    if not disable_limits:
                        line = line[:256]
                    if len(existing) >= max_lines:
                        break
                    existing.append(line)
                self.url_text.delete("1.0", tk.END)
                if existing:
                    self.url_text.insert("1.0", "\n".join(existing))
                try:
                    self.url_text.edit_separator()
                except Exception:
                    pass
                self._apply_batch_text_limits()
                update_line_numbers()
                return "break"
            self.url_text.bind("<Control-v>", batch_paste_handler)
            self.url_text.bind("<Control-V>", batch_paste_handler)
        else:
            url_input_row = tk.Frame(url_left, bg=theme["surface"])
            url_input_row.pack(fill="x", pady=(6, 0))
            url_entry_frame = tk.Frame(
                url_input_row,
                bg=theme["surface_alt"],
                highlightthickness=1,
                highlightbackground=theme["border"],
                highlightcolor=theme["border"],
            )
            url_entry_frame.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.url_entry = tk.Entry(
                url_entry_frame,
                font=fonts["body"],
                bg=theme["surface_alt"],
                fg=theme["text"],
                insertbackground=theme["text"],
                selectbackground=theme["accent"],
                selectforeground=theme["bg"],
                relief="flat",
                bd=0,
                highlightthickness=0,
            )
            self.url_entry.pack(fill=tk.X, expand=True, ipady=6, padx=6, pady=4)
            if saved_url_entry:
                self.url_entry.insert(0, saved_url_entry)
            elif saved_url_text:
                first_line = next((line.strip() for line in saved_url_text.splitlines() if line.strip()), "")
                if first_line:
                    self.url_entry.insert(0, first_line)
            self.url_entry.bind("<KeyRelease>", lambda e: self._apply_single_url_limit())
            self.url_entry.bind("<<Paste>>", lambda e: self._after(0, self._apply_single_url_limit))
            self._apply_single_url_limit()
            self.paste_button = tk.Button(
                url_input_row,
                text="Paste",
                command=self.paste_url,
                font=fonts["button"],
                bg=theme["surface_alt"],
                fg=theme["text"],
                activebackground=theme["surface_alt_hover"],
                activeforeground=theme["text"],
                relief="flat",
                bd=0,
                padx=38,
                pady=7,
                cursor="hand2",
            )
            self.paste_button.pack(side=tk.LEFT, padx=(8, 0))
            self.add_hover_effect(
                self.paste_button,
                bg_normal=theme["surface_alt"],
                fg_normal=theme["text"],
                bg_hover=theme["surface_alt_hover"],
                fg_hover=theme["accent"],
                is_hover_enabled_func=lambda: not self.downloading
            )

        self.format_options = [
            ("mp4", "MP4"),
            ("mp3", "MP3"),
            ("mov", "MOV"),
            ("wav", "WAV")
        ]
        current_format = prev_format or "mp4"
        self.selected_format = tk.StringVar(value=current_format)
        self._prev_format = current_format
        format_card = tk.Frame(
            self.main_frame,
            bg=theme["surface"],
            highlightthickness=1,
            highlightbackground=theme["border"],
            highlightcolor=theme["border"],
        )
        format_card.grid(row=1, column=0, sticky="ew", pady=(0, 12), padx=(0, 6))
        format_card.grid_columnconfigure(0, weight=1)
        format_body = tk.Frame(format_card, bg=theme["surface"])
        format_body.grid(row=0, column=0, sticky="ew", padx=16, pady=12)
        tk.Label(format_body, text="Format", font=fonts["label"], fg=theme["muted"], bg=theme["surface"]).pack(anchor="w")
        format_row = tk.Frame(format_body, bg=theme["surface"])
        format_row.pack(anchor="w", pady=(6, 0))
        self.format_buttons = {}
        for fmt, label in self.format_options:
            btn = tk.Button(
                format_row, text=label, font=fonts["button"],
                bg=theme["surface_alt"], fg=theme["text"],
                activebackground=theme["surface_alt_hover"], activeforeground=theme["text"],
                relief="flat", bd=0, padx=12, pady=4, cursor="hand2",
                command=lambda f=fmt: self.try_format_change(f)
            )
            btn.pack(side=tk.LEFT, padx=4)
            self.add_hover_effect(
                btn,
                is_selected_func=lambda fmt=fmt: self.selected_format.get() == fmt,
                is_hover_enabled_func=lambda: not self.downloading
            )
            self.format_buttons[fmt] = btn
        self.update_format_buttons()

        self.quality_options = [
            ("BEST QUALITY", "BEST"),
            ("2160p", "2160p"),
            ("1440p", "1440p"),
            ("1080p", "1080p"),
            ("720p", "720p"),
            ("480p", "480p"),
            ("360p", "360p"),
            ("240p", "240p"),
            ("144p", "144p")
        ]
        current_quality = prev_quality or "BEST QUALITY"
        self.selected_quality = tk.StringVar(value=current_quality)
        self._prev_quality = current_quality
        quality_card = tk.Frame(
            self.main_frame,
            bg=theme["surface"],
            highlightthickness=1,
            highlightbackground=theme["border"],
            highlightcolor=theme["border"],
        )
        quality_card.grid(row=1, column=1, sticky="ew", pady=(0, 12), padx=(6, 0))
        quality_card.grid_columnconfigure(0, weight=1)
        quality_body = tk.Frame(quality_card, bg=theme["surface"])
        quality_body.grid(row=0, column=0, sticky="ew", padx=16, pady=12)
        tk.Label(quality_body, text="Quality", font=fonts["label"], fg=theme["muted"], bg=theme["surface"]).pack(anchor="w")
        quality_row = tk.Frame(quality_body, bg=theme["surface"])
        quality_row.pack(fill="x", expand=True, pady=(6, 0))
        self.quality_combo = ttk.Combobox(
            quality_row,
            textvariable=self.selected_quality,
            values=[q[0] for q in self.quality_options],
            style="WhiteOnBlack.TCombobox",
            height=7,
            font=fonts["button"],
            state="readonly",
        )
        self.quality_combo.configure(takefocus=0)
        self.quality_combo.pack(fill="x", expand=True)
        self.quality_combo.bind("<<ComboboxSelected>>", self.on_quality_selected)
        self.quality_combo.bind("<FocusIn>", self._clear_combo_selection)
        self.quality_combo.bind("<ButtonRelease-1>", self._clear_combo_selection)
        self.quality_combo.bind("<B1-Motion>", self._clear_combo_selection)
        self.quality_combo.bind("<FocusOut>", self._clear_combo_selection)
        self.update_quality_buttons()
        self._after(0, lambda: self._sync_card_heights(format_card, quality_card))
        btn_row = tk.Frame(self.main_frame, bg=theme["bg"])
        btn_row.grid(row=2, column=0, columnspan=2, sticky="ew", pady=(0, 12))
        btn_row.grid_columnconfigure(0, weight=1, uniform="action")
        btn_row.grid_columnconfigure(1, weight=1, uniform="action")
        self.download_button = tk.Button(
            btn_row, text="Download", command=self.start_download, font=fonts["button"],
            bg=theme["success"], fg=theme["bg"],
            activebackground=theme["success_hover"], activeforeground=theme["bg"],
            relief="flat", bd=0, padx=16, pady=6, cursor="hand2"
        )
        self.download_button.grid(row=0, column=0, sticky="ew", padx=(0, 6))
        self.add_hover_effect(
            self.download_button,
            bg_normal=theme["success"], fg_normal=theme["bg"],
            bg_hover=theme["success_hover"], fg_hover=theme["bg"],
            is_enabled_func=lambda: not self.downloading,
            is_hover_enabled_func=lambda: not self.downloading
        )
        self.abort_button = tk.Button(
            btn_row, text="STOP", command=self.abort, font=fonts["button"],
            bg=theme["danger"], fg=theme["bg"],
            activebackground=theme["danger_hover"], activeforeground=theme["bg"],
            relief="flat", bd=0, padx=16, pady=6, cursor="hand2"
        )
        self.abort_button.grid(row=0, column=1, sticky="ew", padx=(6, 0))
        self.add_hover_effect(
            self.abort_button,
            bg_normal=theme["danger"], fg_normal=theme["bg"],
            bg_hover=theme["danger_hover"], fg_hover=theme["bg"],
            is_hover_enabled_func=None
        )
        for btn in (self.download_button, self.abort_button):
            try:
                btn.config(disabledforeground=theme["disabled_fg"])
            except tk.TclError:
                pass
            try:
                btn.config(disabledbackground=theme["disabled_bg"])
            except tk.TclError:
                pass
        if not self.downloading:
            self.abort_button.config(state=tk.DISABLED, cursor="", bg=theme["disabled_bg"], fg=theme["disabled_fg"])

        if not is_batch:
            self.progress = tk.Canvas(
                self.main_frame,
                height=36,
                bg=theme["surface_alt"],
                highlightthickness=1,
                highlightbackground=theme["border"],
                highlightcolor=theme["border"],
                bd=0,
                relief="flat"
            )
            self.progress.grid(row=3, column=0, columnspan=2, sticky="ew", pady=(0, 12), ipady=4)
            self._progress_value = 0.0
            self._progress_fill_color = theme["accent"]
            self.progress_fill_id = self.progress.create_rectangle(0, 0, 0, 0, fill=self._progress_fill_color, width=0)
            self.progress_text_id = self.progress.create_text(
                0,
                0,
                text="0%",
                font=(fonts["caption"][0], fonts["caption"][1], "bold"),
                fill=theme["text"]
            )
            self.progress.bind("<Configure>", lambda _e: self._update_progress_canvas())
            self._last_progress_text = "0%"
            self._update_progress_canvas()
        else:
            self.progress = None
            self._last_progress_text = None
            self.progress_fill_id = None
            self.progress_text_id = None

        console_frame = tk.Frame(
            self.main_frame,
            bg=theme["surface"],
            highlightthickness=1,
            highlightbackground=theme["border"],
            highlightcolor=theme["border"],
        )
        self.console_frame = console_frame
        console_frame.grid(row=4, column=0, columnspan=2, sticky="nsew")
        self.console = tk.Text(
            console_frame,
            height=5,
            bg=theme["surface"],
            fg=theme["text"],
            insertbackground=theme["text"],
            selectbackground=theme["accent"],
            selectforeground=theme["bg"],
            highlightthickness=0,
            bd=0,
            state="normal",
            wrap="word",
            font=fonts["mono"],
        )
        self.console.pack(side="left", fill="both", expand=True)
        def _on_console_mousewheel(event):
            if event.delta:
                self.console.yview_scroll(int(-1 * (event.delta / 120)), "units")
            elif event.num == 5:
                self.console.yview_scroll(1, "units")
            elif event.num == 4:
                self.console.yview_scroll(-1, "units")
            return "break"
        self.console.bind("<MouseWheel>", _on_console_mousewheel)
        self.console.bind("<Button-4>", _on_console_mousewheel)
        self.console.bind("<Button-5>", _on_console_mousewheel)
        def _block_console_edit(event):
            if event.keysym in ("BackSpace", "Delete", "Return", "KP_Enter", "Tab"):
                return "break"
            if event.state & 0x4:
                if event.keysym.lower() in ("c", "a"):
                    return None
                return "break"
            if event.char and event.char >= " ":
                return "break"
            return None
        self.console.bind("<KeyPress>", _block_console_edit)
        self.console.bind("<<Paste>>", lambda e: "break")
        self.console.bind("<<Cut>>", lambda e: "break")
        self.console.bind("<<Clear>>", lambda e: "break")

        bottom_bar = tk.Frame(outer, bg=theme["bg"], padx=24, pady=8)
        bottom_bar.grid(row=3, column=0, sticky="ew")
        bottom_left = tk.Frame(bottom_bar, bg=theme["bg"])
        bottom_right = tk.Frame(bottom_bar, bg=theme["bg"])
        self.gear_btn = tk.Button(
            bottom_left, text="Settings", font=fonts["label"],
            bg=theme["bg"], fg=theme["muted"],
            activebackground=theme["bg"], activeforeground=theme["text"],
            relief="flat", bd=0, padx=8, pady=2, command=self.show_settings, cursor="hand2"
        )
        self.gear_btn.pack(side="left", anchor="w")
        self.add_hover_effect(
            self.gear_btn,
            bg_normal=theme["bg"], fg_normal=theme["muted"],
            bg_hover=theme["bg"], fg_hover=theme["accent"],
            is_hover_enabled_func=lambda: not self.downloading
        )
        if self.downloading:
            self.gear_btn.config(state=tk.DISABLED, cursor="")
        else:
            self.gear_btn.config(state=tk.NORMAL)
        downloads_link = tk.Label(bottom_right, text="Open downloads folder", font=fonts["caption"], fg=theme["accent"], bg=theme["bg"], cursor="hand2")
        downloads_link.pack(side="right", anchor="e", padx=(0, 8))
        downloads_link.bind("<Button-1>", lambda e: self.open_downloads_folder())
        self.add_hover_effect(
            downloads_link,
            bg_normal=theme["bg"], fg_normal=theme["accent"],
            bg_hover=theme["bg"], fg_hover=theme["text"]
        )
        official_link = tk.Label(bottom_right, text="Official page", font=fonts["caption"], fg=theme["accent"], bg=theme["bg"], cursor="hand2")
        official_link.pack(side="right", anchor="e", padx=(0, 8))
        official_link.bind("<Button-1>", lambda e: self.open_url("https://justagwas.com/projects/MediaCrate"))
        self.add_hover_effect(
            official_link,
            bg_normal=theme["bg"], fg_normal=theme["accent"],
            bg_hover=theme["bg"], fg_hover=theme["text"]
        )
        version_label = tk.Label(bottom_right, text="v1.0.0", font=fonts["caption"], fg=theme["muted"], bg=theme["bg"])
        version_label.pack(side="right", anchor="e", padx=(0, 8))
        self._configure_footer(bottom_bar, bottom_left, bottom_right, min_width=540)
        self.enforce_min_size()
        self._apply_window_constraints(min_extra=self._batch_min_extra if is_batch else 0)
        self.root.update_idletasks()
        if switch_view:
            self._show_view("main")
        self._main_built = True
        if switch_view:
            self._after(0, self._fade_in)

    def update_format_buttons(self):
        theme = self.theme
        for fmt, btn in self.format_buttons.items():
            if self.selected_format.get() == fmt:
                btn.config(bg=theme["accent"], fg=theme["bg"])
            else:
                btn.config(bg=theme["surface_alt"], fg=theme["text"])

    def _restore_main_size_after_settings(self):
        restored = False
        if self._settings_enter_size and not self._settings_user_resized:
            target_w, target_h = self._settings_enter_size
            self._set_geometry_safe(target_w, target_h)
            self._last_user_size = (target_w, target_h)
            restored = True
        self._settings_enter_size = None
        self._settings_forced_size = None
        self._settings_user_resized = False
        return restored

    def show_main_view(self):
        force_rebuild = getattr(self, "_pending_batch_refresh", False)
        self._pending_batch_refresh = False
        self.create_widgets(force_rebuild=force_rebuild, switch_view=True)
        self._restore_main_size_after_settings()
        is_batch = self.config.get('allow_batch_downloads', False)
        prev_batch = self._batch_active if self._batch_active is not None else is_batch
        if prev_batch != is_batch:
            if is_batch:
                if self._last_user_size:
                    self._batch_enter_size = self._last_user_size
                else:
                    self._batch_enter_size = (self.root.winfo_width(), self.root.winfo_height())
                self._batch_user_resized = False
                self._batch_forced_size = None
                self._batch_resize_pending = True
            else:
                if self._batch_enter_size and not self._batch_user_resized:
                    target_w, target_h = self._batch_enter_size
                    self._set_geometry_safe(target_w, target_h)
                    self._last_user_size = (target_w, target_h)
                self._batch_enter_size = None
                self._batch_forced_size = None
                self._batch_user_resized = False
                self._batch_resize_pending = False
        self._batch_active = is_batch
        self._apply_window_constraints(min_extra=self._batch_min_extra if is_batch else 0)
        if is_batch and self._batch_resize_pending:
            self.root.update_idletasks()
            self._batch_forced_size = (self.root.winfo_width(), self.root.winfo_height())
            if self._batch_enter_size:
                self._last_user_size = self._batch_enter_size
            self._batch_resize_pending = False

    def update_quality_buttons(self):
        is_audio = self.selected_format.get() in ("mp3", "wav")
        if is_audio:
            self.selected_quality.set("BEST QUALITY")
        if self.selected_quality.get() not in [q[0] for q in self.quality_options]:
            self.selected_quality.set("BEST QUALITY")
        if hasattr(self, 'quality_combo') and self.quality_combo.winfo_exists():
            combo_state = "disabled" if is_audio or self.downloading else "readonly"
            self.quality_combo.config(state=combo_state)

    def try_format_change(self, fmt):
        prev_fmt = self.selected_format.get()
        self._prev_format = prev_fmt
        if fmt in ("mov", "wav") and fmt != prev_fmt:
            if not self.prompt_format_confirmation(fmt):
                return
        self.selected_format.set(fmt)
        if fmt not in ("mp3", "wav"):
            if self.selected_quality.get() not in [q[0] for q in self.quality_options]:
                self.selected_quality.set("BEST QUALITY")
        self.update_format_buttons()
        self.update_quality_buttons()

    def try_quality_change(self, qual):
        prev_qual = self._prev_quality
        if qual != prev_qual:
            if not self.prompt_quality_change(qual):
                self.selected_quality.set(prev_qual)
                self.update_quality_buttons()
                return
        self.selected_quality.set(qual)
        self._prev_quality = qual
        self.update_quality_buttons()

    def on_quality_selected(self, _event=None):
        self.try_quality_change(self.selected_quality.get())

    def _clear_combo_selection(self, event=None):
        try:
            widget = event.widget if event else self.quality_combo
            widget.selection_clear()
        except Exception:
            pass

    def paste_url(self):
        try:
            self.url_entry.delete(0, tk.END)
            self.url_entry.insert(0, self.root.clipboard_get())
            self._apply_single_url_limit()
            theme = self.theme
            self._fade_entry_fg(self.url_entry, start_color=theme["accent"], end_color=theme["text"], steps=10, delay=40)
        except tk.TclError:
            messagebox.showerror("Error", "No URL found in clipboard")

    def _fade_entry_fg(self, entry, start_color, end_color, steps=10, delay=40):
        def hex_to_rgb(hex_color):
            hex_color = hex_color.lstrip('#')
            return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        def rgb_to_hex(rgb):
            return '#{:02x}{:02x}{:02x}'.format(*rgb)
        start_rgb = hex_to_rgb(start_color)
        end_rgb = hex_to_rgb(end_color)
        def step(i):
            ratio = i / steps
            curr_rgb = tuple(
                int(start_rgb[j] + (end_rgb[j] - start_rgb[j]) * ratio)
                for j in range(3)
            )
            entry.config(fg=rgb_to_hex(curr_rgb))
            if i < steps:
                self._after(delay, lambda: step(i+1), widget=entry)
        step(0)

    def sanitize_filename(self, name):
        return sanitize_filename(name).strip()

    def _is_valid_netloc(self, netloc):
        if not netloc:
            return False
        host_port = netloc.rsplit("@", 1)[-1]
        host = host_port.split(":", 1)[0]
        if not host or " " in host:
            return False
        if host == "localhost":
            return True
        if re.fullmatch(r"\d{1,3}(\.\d{1,3}){3}", host):
            return True
        return "." in host

    def sanitize_url(self, url):
        if not url:
            return None
        url = url.strip()
        parsed = urlparse(url)
        if parsed.scheme and parsed.netloc:
            if not self._is_valid_netloc(parsed.netloc):
                return None
            return url
        if not parsed.scheme and parsed.path:
            candidate = f"https://{url}"
            parsed_candidate = urlparse(candidate)
            if parsed_candidate.netloc and self._is_valid_netloc(parsed_candidate.netloc):
                return candidate
        return None

    def validate_url(self, url, *, show_error=False):
        sanitized = self.sanitize_url(url)
        if not sanitized and show_error:
            messagebox.showerror("Invalid URL", "The link is invalid.")
        return sanitized

    def _apply_single_url_limit(self):
        if self.config.get('disable_char_limits', False):
            return
        entry = getattr(self, "url_entry", None)
        if not entry or not entry.winfo_exists():
            return
        value = entry.get()
        if len(value) > 512:
            entry.delete(0, tk.END)
            entry.insert(0, value[:512])

    def _apply_batch_text_limits(self):
        if getattr(self, "_batch_enforcing", False):
            return
        text = getattr(self, "url_text", None)
        if not text or not text.winfo_exists():
            return
        self._batch_enforcing = True
        try:
            content = text.get("1.0", "end-1c")
            lines = content.splitlines()
            max_lines = self._normalize_batch_line_limit(self.config.get('max_batch_lines'))
            if len(lines) > max_lines:
                lines = lines[:max_lines]
            if not self.config.get('disable_char_limits', False):
                lines = [line[:256] for line in lines]
            new_content = "\n".join(lines)
            if new_content != content:
                insert_index = text.index(tk.INSERT)
                text.delete("1.0", tk.END)
                text.insert("1.0", new_content)
                try:
                    text.mark_set(tk.INSERT, insert_index)
                except Exception:
                    pass
        finally:
            self._batch_enforcing = False

    def _url_key(self, url):
        try:
            parsed = urlparse(url)
        except Exception:
            return url
        if not parsed.scheme or not parsed.netloc:
            return url
        return parsed._replace(scheme=parsed.scheme.lower(), netloc=parsed.netloc.lower(), fragment="").geturl()

    def _external_downloader_opts(self):
        return {}

    def prompt_quality_change(self, selected_quality):
        if self.config.get('disable_warnings', False):
            return True
        if selected_quality != "BEST QUALITY":
            result = messagebox.askyesno(
                "Quality Format Change",
                "The provided media URL might not support other formats. Do you want to proceed?")
            if not result:
                self.selected_quality.set(self._prev_quality)
                self.update_quality_buttons()
                return False
        return True


    def prompt_format_confirmation(self, selected_format):
        if self.config.get('disable_warnings', False):
            return True
        if selected_format in ("mp4", "mp3"): return True
        result = messagebox.askyesno(
            "Format Download Warning",
            f"Downloading {selected_format} may take significantly longer than MP4/MP3.\nDo you want to continue?")
        if not result:
            self.selected_format.set(self._prev_format)
            self.update_format_buttons()
            self.update_quality_buttons()
            return False
        return True

    def start_download(self):
        theme = self.theme
        fonts = self.fonts
        if self.progress and isinstance(self.progress, tk.Canvas):
            self._set_progress_style("normal")
            self._set_progress_value(0)
            self._set_progress_text("0%")
        if self.console:
            self.console.delete(1.0, tk.END)
        self._drain_queue(self.progress_queue)
        self.abort_event.clear()
        self._abort_notified = False
        self._percent_started = False

        if self.config.get('allow_batch_downloads', False):
            self.downloading = True
            self.set_controls_state(False)
            urls = []
            if hasattr(self, 'url_text') and self.url_text.winfo_exists():
                urls = [u.strip() for u in self.url_text.get("1.0", tk.END).splitlines() if u.strip()]
            max_lines = self._normalize_batch_line_limit(self.config.get('max_batch_lines'))
            if len(urls) > max_lines:
                urls = urls[:max_lines]
            if not urls:
                messagebox.showerror("Error", "Please enter one or more media URLs")
                self.downloading = False
                self.set_controls_state(True)
                return

            format_choice = self.selected_format.get()
            if not format_choice:
                messagebox.showerror("Error", "Please select a format")
                return
            quality_choice = self.selected_quality.get()
            if format_choice in ("mp3", "wav"):
                quality_choice = "BEST QUALITY"

            if self.config.get('preserve_batch_links', False):
                if hasattr(self, 'url_text') and self.url_text.winfo_exists():
                    self._batch_saved_links = self.url_text.get("1.0", tk.END).rstrip("\n")
            else:
                self._batch_saved_links = None

            if hasattr(self, "url_text_frame") and self.url_text_frame.winfo_exists():
                self.root.update_idletasks()
                self._batch_url_box_height = max(1, self.url_text_frame.winfo_height())
            else:
                self._batch_url_box_height = 360

            if hasattr(self, 'url_text') and self.url_text.winfo_exists():
                self.url_text.destroy()
            if hasattr(self, 'url_card') and self.url_card.winfo_exists():
                self.url_card.destroy()
            self.batch_progress_frame = tk.Frame(self.main_frame, bg=theme["surface"], highlightthickness=1, highlightbackground=theme["border"])
            self.batch_progress_frame.grid(row=0, column=0, columnspan=2, sticky="nsew", pady=(0, 12))
            header = tk.Frame(self.batch_progress_frame, bg=theme["surface"], padx=12, pady=8)
            header.pack(fill="x")
            header_left = tk.Label(header, text="Batch queue", font=fonts["label"], bg=theme["surface"], fg=theme["text"])
            header_left.pack(side="left")
            self.batch_summary_label = tk.Label(header, text="Preparing...", font=fonts["caption"], bg=theme["surface"], fg=theme["muted"])
            self.batch_summary_label.pack(side="right")
            target_height = max(200, getattr(self, "_batch_url_box_height", 360))
            canvas = tk.Canvas(self.batch_progress_frame, bg=theme["surface"], highlightthickness=0, height=target_height)
            scrollable_frame = tk.Frame(canvas, bg=theme["surface"])
            window_id = canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.pack(side="left", fill="both", expand=True)

            def _resize_canvas_window():
                canvas.itemconfigure(window_id, width=canvas.winfo_width())
            def _apply_scrollregion():
                bbox = canvas.bbox("all")
                if not bbox:
                    return
                x1, y1, x2, y2 = bbox
                canvas_h = max(1, canvas.winfo_height())
                height = max(y2 - y1, canvas_h)
                canvas.configure(scrollregion=(0, 0, x2 - x1, height))
                if (y2 - y1) <= canvas_h:
                    canvas.yview_moveto(0)
            def _schedule_scrollregion(_event=None):
                if getattr(canvas, "_scrollregion_job", None):
                    canvas.after_cancel(canvas._scrollregion_job)
                canvas._scrollregion_job = self._after(120, _apply_scrollregion, widget=canvas)
            def _schedule_canvas_resize(_event=None):
                if getattr(canvas, "_resize_job", None):
                    canvas.after_cancel(canvas._resize_job)
                canvas._resize_job = self._after(80, lambda: (_resize_canvas_window(), _schedule_scrollregion()), widget=canvas)
            scrollable_frame.bind("<Configure>", _schedule_scrollregion)
            canvas.bind("<Configure>", _schedule_canvas_resize)
            _resize_canvas_window()
            def _on_mousewheel(event):
                if event.delta:
                    canvas.yview_scroll(int(-1*(event.delta/120)), "units")
                elif event.num == 5:
                    canvas.yview_scroll(1, "units")
                elif event.num == 4:
                    canvas.yview_scroll(-1, "units")
                return "break"
            canvas.bind("<MouseWheel>", _on_mousewheel)
            canvas.bind("<Button-4>", _on_mousewheel)
            canvas.bind("<Button-5>", _on_mousewheel)
            scrollable_frame.bind("<MouseWheel>", _on_mousewheel)
            scrollable_frame.bind("<Button-4>", _on_mousewheel)
            scrollable_frame.bind("<Button-5>", _on_mousewheel)
            def _on_batch_wheel(event):
                if not self.batch_progress_frame or not self.batch_progress_frame.winfo_exists():
                    return
                if not self._is_descendant(event.widget, self.batch_progress_frame):
                    return
                return _on_mousewheel(event)
            self.root.bind_all("<MouseWheel>", _on_batch_wheel)
            self.root.bind_all("<Button-4>", _on_batch_wheel)
            self.root.bind_all("<Button-5>", _on_batch_wheel)
            self._batch_wheel_bound = True
            self.batch_link_widgets = []
            self.batch_progress_vars = []
            self.batch_status_labels = []
            self.batch_already_downloaded = []
            self.batch_progress_bars = []

            for idx, url in enumerate(urls):
                row = tk.Frame(scrollable_frame, bg=theme["surface"])
                row.pack(fill=tk.X, pady=1)
                row.grid_columnconfigure(1, weight=1)
                row.grid_columnconfigure(2, minsize=120)
                row.grid_columnconfigure(3, minsize=110)
                idx_label = tk.Label(
                    row,
                    text=f"{idx + 1}.",
                    font=fonts["caption"],
                    bg=theme["surface"],
                    fg=theme["muted"],
                    width=3,
                    anchor="e"
                )
                idx_label.grid(row=0, column=0, padx=(2, 4), sticky="e")
                display_url = url
                display_url = re.sub(r'^https?://(www\.)?', '', display_url, flags=re.IGNORECASE)
                link_label = tk.Label(row, text=display_url, font=fonts["mono"], bg=theme["surface_alt"], fg=theme["text"], anchor="w")
                link_label.grid(row=0, column=1, padx=(2, 2), sticky="ew")
                progress_var = tk.DoubleVar(value=0)
                progress_bar = ttk.Progressbar(row, variable=progress_var, maximum=100, length=110, style="Modern.Small.Disabled.Horizontal.TProgressbar")
                progress_bar.grid(row=0, column=2, padx=(0, 2), sticky="w")
                status_label = tk.Label(row, text="Checking...", font=fonts["caption"], bg=theme["surface"], fg=theme["muted"], width=12)
                status_label.grid(row=0, column=3, padx=(0, 2), sticky="w")
                self.batch_link_widgets.append((link_label, progress_bar))
                self.batch_progress_vars.append(progress_var)
                self.batch_status_labels.append(status_label)
                self.batch_already_downloaded.append(False)
                self.batch_progress_bars.append(progress_bar)

            self.root.update_idletasks()
            if len(urls) > 10:
                canvas.config(height=target_height)
            else:
                canvas.config(height=min(32 * len(urls) + 10, target_height))

            def check_links():
                def fast_check():
                    downloads_dir = self.config.get('download_location', self._default_download_dir())
                    media_dl_dir = downloads_dir
                    os.makedirs(media_dl_dir, exist_ok=True)
                    valid_links = [None] * len(urls)
                    safe_bases = [None] * len(urls)
                    redownload_indices = []
                    seen_links = set()

                    ydl_opts = {
                        'quiet': True,
                        'skip_download': True,
                        'no_warnings': True,
                        'simulate': True,
                    }
                    status_flags = [None] * len(urls)

                    def update_status(idx, text, fg):
                        self.run_on_ui_thread(self.batch_status_labels[idx].config, text=text, fg=fg)

                    def set_progress_active(idx):
                        bar = self.batch_progress_bars[idx]
                        if bar:
                            bar.config(style="Modern.Small.Horizontal.TProgressbar")
                        self.batch_progress_vars[idx].set(0)

                    def set_progress_inactive(idx):
                        bar = self.batch_progress_bars[idx]
                        if bar:
                            bar.config(style="Modern.Small.Disabled.Horizontal.TProgressbar")
                        self.batch_progress_vars[idx].set(100)

                    def set_progress_done(idx):
                        bar = self.batch_progress_bars[idx]
                        if bar:
                            bar.config(style="Modern.Small.Complete.Horizontal.TProgressbar")
                        self.batch_progress_vars[idx].set(100)

                    def check_one(idx, url):
                        if self.abort_event.is_set():
                            return
                        sanitized_url = self.validate_url(url)
                        if not sanitized_url:
                            update_status(idx, "Invalid", theme["danger"])
                            self.run_on_ui_thread(set_progress_inactive, idx)
                            status_flags[idx] = "invalid"
                            return
                        url_key = self._url_key(sanitized_url)
                        if url_key in seen_links:
                            update_status(idx, "Duplicate", theme["muted"])
                            self.run_on_ui_thread(set_progress_inactive, idx)
                            status_flags[idx] = "duplicate"
                            return
                        seen_links.add(url_key)
                        try:
                            with YoutubeDL(ydl_opts) as ydl:
                                info_dict = ydl.extract_info(sanitized_url, download=False, process=False)
                            if self.abort_event.is_set():
                                return
                            title = info_dict.get('title', '')
                            media_id = info_dict.get('id')
                            safe_base = self._build_base_filename(title, media_id)
                            safe_bases[idx] = safe_base
                            final_filename = f"{safe_base}.{format_choice}"
                            output_path_final = os.path.join(media_dl_dir, final_filename)
                            if os.path.exists(output_path_final):
                                update_status(idx, "File Exists", theme["success"])
                                self.run_on_ui_thread(set_progress_inactive, idx)
                                self.batch_already_downloaded[idx] = True
                                status_flags[idx] = "exists"
                                valid_links[idx] = None
                                if not self.config.get('disable_already_downloaded_prompts', False):
                                    redownload_indices.append(idx)
                            else:
                                update_status(idx, "Starting...", theme["success"])
                                self.run_on_ui_thread(set_progress_active, idx)
                                status_flags[idx] = "valid"
                                valid_links[idx] = sanitized_url
                        except Exception:
                            update_status(idx, "Invalid", theme["danger"])
                            self.run_on_ui_thread(set_progress_inactive, idx)
                            status_flags[idx] = "invalid"

                    threads = []
                    max_threads = min(len(urls), self._normalize_batch_concurrency(self.config.get('batch_concurrency')))
                    from queue import Queue
                    q = Queue()
                    for idx, url in enumerate(urls):
                        q.put((idx, url))
                    def worker():
                        while not q.empty():
                            try:
                                idx, url = q.get_nowait()
                            except Exception:
                                break
                            check_one(idx, url)
                            q.task_done()
                    for _ in range(max_threads):
                        t = threading.Thread(target=worker)
                        t.start()
                        threads.append(t)
                    q.join()
                    for t in threads:
                        t.join()

                    if getattr(self, "batch_summary_label", None):
                        counts = {
                            "valid": sum(1 for v in status_flags if v == "valid"),
                            "invalid": sum(1 for v in status_flags if v == "invalid"),
                            "duplicate": sum(1 for v in status_flags if v == "duplicate"),
                            "exists": sum(1 for v in status_flags if v == "exists"),
                        }
                        total = len(urls)
                        summary = (
                            f"Total: {total}  "
                            f"Valid: {counts['valid']}  "
                            f"Invalid: {counts['invalid']}  "
                            f"Duplicate: {counts['duplicate']}  "
                            f"Exists: {counts['exists']}"
                        )
                        self.run_on_ui_thread(self.batch_summary_label.config, text=summary)

                    def prompt_redownloads(redownload_indices, callback):
                        if self.abort_event.is_set():
                            callback([])
                            return
                        if not redownload_indices:
                            callback([])
                            return
                        redownload_links = []
                        def ask_next(i):
                            if self.abort_event.is_set():
                                callback([])
                                return
                            if i >= len(redownload_indices):
                                callback(redownload_links)
                                return
                            idx = redownload_indices[i]
                            link = urls[idx]
                            display_url = re.sub(r'^https?://(www\.)?', '', link, flags=re.IGNORECASE)
                            final_filename = f"{safe_bases[idx]}.{format_choice}" if safe_bases[idx] else ""
                            output_path_final = os.path.join(media_dl_dir, final_filename)
                            msg = f"File already exists:\n{self._display_path(output_path_final)}\n({display_url})\nDo you want to re-download it?"
                            res = messagebox.askyesno("Already Downloaded", msg)
                            if res:
                                if self.abort_event.is_set():
                                    callback([])
                                    return
                                self.batch_status_labels[idx].config(text="Downloading", fg=theme["accent"])
                                bar = self.batch_progress_bars[idx]
                                if bar:
                                    bar.config(style="Modern.Small.Horizontal.TProgressbar")
                                self.batch_progress_vars[idx].set(0)
                                redownload_links.append(idx)
                            else:
                                self.batch_status_labels[idx].config(text="Skipped", fg=theme["muted"])
                                bar = self.batch_progress_bars[idx]
                                if bar:
                                    bar.config(style="Modern.Small.Disabled.Horizontal.TProgressbar")
                                self.batch_progress_vars[idx].set(100)
                            ask_next(i+1)
                        ask_next(0)

                    def start_batch_downloads(redownload_links):
                        if self.abort_event.is_set():
                            self.downloading = False
                            self.set_controls_state(True)
                            return
                        self.downloading = True
                        self.set_controls_state(False)
                        self.append_console("Batch download started...\n")
                        self._batch_download_dir = media_dl_dir
                        self._batch_all_done = False
                        self._batch_done_set = set()
                        batch_jobs_lock = threading.Lock()
                        batch_jobs_remaining = 0

                        def finalize_batch():
                            if self._batch_all_done:
                                return
                            self.downloading = False
                            self.set_controls_state(True)
                            self._show_reset_button()
                            self._batch_all_done = True
                            self.append_console("Batch download finished.\n")

                        def mark_batch_done():
                            nonlocal batch_jobs_remaining
                            with batch_jobs_lock:
                                if batch_jobs_remaining <= 0:
                                    return
                                batch_jobs_remaining -= 1
                                if batch_jobs_remaining == 0:
                                    self.run_on_ui_thread(finalize_batch)

                        def batch_download_worker(idx, url, format_choice, quality_choice, safe_base):
                            if not url or not safe_base:
                                mark_batch_done()
                                return
                            max_attempts = self._normalize_batch_retries(self.config.get('batch_retry_attempts'))
                            def progress_hook(d):
                                if self.abort_event.is_set():
                                    raise DownloadCancelled()
                                if d['status'] == 'downloading':
                                    percent_str = d.get('_percent_str', '').strip()
                                    try:
                                        percent = float(percent_str.split('%')[0].strip()[-4:])
                                    except Exception:
                                        percent = 0
                                    self.run_on_ui_thread(self.batch_progress_vars[idx].set, percent)
                                    self.run_on_ui_thread(self.batch_status_labels[idx].config, text=f"{int(percent)}%", fg=theme["accent"])
                                elif d['status'] == 'finished':
                                    self.run_on_ui_thread(self.batch_progress_vars[idx].set, 100)
                                    self.run_on_ui_thread(set_progress_done, idx)
                                    self.run_on_ui_thread(self.batch_status_labels[idx].config, text="Done", fg=theme["success"])
                                    final_filename = f"{safe_base}.{format_choice}"
                                    final_path = os.path.join(media_dl_dir, final_filename)
                                    if final_path not in self._batch_done_set:
                                        self._batch_done_set.add(final_path)
                            final_filename = f"{safe_base}.{format_choice}"
                            temp_base = f"{safe_base}__{format_choice}_TEMP"
                            output_template = os.path.join(media_dl_dir, f'{temp_base}.%(ext)s')
                            self._register_active_temp(media_dl_dir, temp_base)

                            quality_format = {
                                "BEST QUALITY": "bestvideo+bestaudio/best",
                                "144p": "worstvideo[height<=144]+bestaudio/best[height<=144]",
                                "240p": "worstvideo[height<=240]+bestaudio/best[height<=240]",
                                "360p": "worstvideo[height<=360]+bestaudio/best[height<=360]",
                                "480p": "worstvideo[height<=480]+bestaudio/best[height<=480]",
                                "720p": "bestvideo[height<=720]+bestaudio/best[height<=720]",
                                "1080p": "bestvideo[height<=1080]+bestaudio/best[height<=1080]",
                                "1440p": "bestvideo[height<=1440]+bestaudio/best[height<=1440]",
                                "2160p": "bestvideo[height<=2160]+bestaudio/best[height<=2160]",
                                "2160p (4k)": "bestvideo[height<=2160]+bestaudio/best[height<=2160]",
                            }
                            if format_choice == "mp4":
                                quality_format = {
                                    "BEST QUALITY": "bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]",
                                    "144p": "bestvideo[ext=mp4][height<=144]+bestaudio[ext=m4a]/best[ext=mp4][height<=144]/best[ext=mp4]",
                                    "240p": "bestvideo[ext=mp4][height<=240]+bestaudio[ext=m4a]/best[ext=mp4][height<=240]/best[ext=mp4]",
                                    "360p": "bestvideo[ext=mp4][height<=360]+bestaudio[ext=m4a]/best[ext=mp4][height<=360]/best[ext=mp4]",
                                    "480p": "bestvideo[ext=mp4][height<=480]+bestaudio[ext=m4a]/best[ext=mp4][height<=480]/best[ext=mp4]",
                                    "720p": "bestvideo[ext=mp4][height<=720]+bestaudio[ext=m4a]/best[ext=mp4][height<=720]/best[ext=mp4]",
                                    "1080p": "bestvideo[ext=mp4][height<=1080]+bestaudio[ext=m4a]/best[ext=mp4][height<=1080]/best[ext=mp4]",
                                    "1440p": "bestvideo[ext=mp4][height<=1440]+bestaudio[ext=m4a]/best[ext=mp4][height<=1440]/best[ext=mp4]",
                                    "2160p": "bestvideo[ext=mp4][height<=2160]+bestaudio[ext=m4a]/best[ext=mp4][height<=2160]/best[ext=mp4]",
                                    "2160p (4k)": "bestvideo[ext=mp4][height<=2160]+bestaudio[ext=m4a]/best[ext=mp4][height<=2160]/best[ext=mp4]",
                                }

                            windows_hide_flag = self._is_windows()
                            if format_choice in ['mp3', 'wav']:
                                ydl_opts = {
                                    'format': 'bestaudio/best',
                                    'outtmpl': output_template,
                                    'progress_hooks': [progress_hook],
                                    'postprocessors': [{
                                        'key': 'FFmpegExtractAudio',
                                        'preferredcodec': format_choice,
                                        'preferredquality': '0',
                                    }],
                                    'concurrent_fragment_downloads': 8,
                                    'quiet': True,
                                    'windows_hide': windows_hide_flag,
                                }
                            else:
                                ydl_opts = {
                                    'format': quality_format.get(quality_choice, 'best'),
                                    'outtmpl': output_template,
                                    'progress_hooks': [progress_hook],
                                    'postprocessors': [{
                                        'key': 'FFmpegVideoConvertor',
                                        'preferedformat': 'mov',
                                        'ffmpeg_args': ['-preset', 'ultrafast'],
                                    }] if format_choice == 'mov' else [],
                                    'concurrent_fragment_downloads': 8,
                                    'quiet': True,
                                    'windows_hide': windows_hide_flag,
                                }
                                if format_choice in ("mp4", "mov"):
                                    ydl_opts['merge_output_format'] = format_choice
                            ffmpeg_location = self._resolve_ffmpeg_location()
                            if ffmpeg_location:
                                ydl_opts['ffmpeg_location'] = ffmpeg_location
                            js_runtime = self._resolve_js_runtime()
                            if js_runtime:
                                ydl_opts['js_runtimes'] = js_runtime
                            ydl_opts.update(self._external_downloader_opts())

                            try:
                                for attempt in range(1, max_attempts + 1):
                                    if self.abort_event.is_set():
                                        raise DownloadCancelled()
                                    if attempt > 1:
                                        self.run_on_ui_thread(self.batch_progress_vars[idx].set, 0)
                                        self.run_on_ui_thread(
                                            self.batch_status_labels[idx].config,
                                            text=f"Retry {attempt}/{max_attempts}",
                                            fg=theme["muted"]
                                        )
                                    try:
                                        with YoutubeDL(ydl_opts) as ydl:
                                            ydl.download([url])
                                        temp_files = [f for f in os.listdir(media_dl_dir) if f.startswith(temp_base + ".") and '_TEMP.' in f]
                                        for temp_file in temp_files:
                                            temp_path = os.path.join(media_dl_dir, temp_file)
                                            final_path = os.path.join(media_dl_dir, final_filename)
                                            if os.path.exists(final_path):
                                                try:
                                                    os.remove(final_path)
                                                except Exception:
                                                    pass
                                            os.rename(temp_path, final_path)
                                        self.run_on_ui_thread(set_progress_done, idx)
                                        self.run_on_ui_thread(self.batch_status_labels[idx].config, text="Done", fg=theme["success"])
                                        return
                                    except DownloadCancelled:
                                        raise
                                    except Exception:
                                        if attempt < max_attempts:
                                            self._cleanup_temp_files(media_dl_dir, temp_base, max_attempts=3, delay=0.1)
                                            continue
                                        self.run_on_ui_thread(self.batch_status_labels[idx].config, text="Error", fg=theme["danger"])
                                        self.append_console(f"[ERROR] {url}\n")
                            except DownloadCancelled:
                                self.run_on_ui_thread(self.batch_status_labels[idx].config, text="Aborted", fg=theme["muted"])
                                self._cleanup_temp_files(media_dl_dir, temp_base, max_attempts=60, delay=0.25)
                            finally:
                                self._unregister_active_temp(media_dl_dir, temp_base)
                                mark_batch_done()

                        def enqueue_jobs():
                            for idx, url in enumerate(valid_links):
                                safe_base = safe_bases[idx]
                                if url and safe_base:
                                    jobs.put((idx, url, safe_base))
                            for idx in redownload_links:
                                safe_base = safe_bases[idx]
                                link = urls[idx]
                                if safe_base:
                                    jobs.put((idx, link, safe_base))

                        def worker():
                            while not self.abort_event.is_set():
                                try:
                                    idx, url, safe_base = jobs.get_nowait()
                                except Exception:
                                    break
                                batch_download_worker(idx, url, format_choice, quality_choice, safe_base)
                                jobs.task_done()

                        jobs = queue.Queue()
                        enqueue_jobs()
                        batch_jobs_remaining = jobs.qsize()
                        if batch_jobs_remaining == 0:
                            finalize_batch()
                            return
                        worker_count = min(self._normalize_batch_concurrency(self.config.get('batch_concurrency')), batch_jobs_remaining)
                        for _ in range(max(1, worker_count)):
                            t = threading.Thread(target=worker, daemon=True)
                            t.start()

                    self.run_on_ui_thread(prompt_redownloads, redownload_indices, start_batch_downloads)
                threading.Thread(target=fast_check, daemon=True).start()
            check_links()
        else:
            url = self.url_entry.get().strip()
            if not url:
                messagebox.showerror("Error", "Please enter a media URL")
                return

            sanitized_url = self.validate_url(url, show_error=True)
            if not sanitized_url:
                self.downloading = False
                self.set_controls_state(True)
                self.run_on_ui_thread(self.download_button.config, state=tk.NORMAL)
                return
            format_choice = self.selected_format.get()
            if not format_choice:
                messagebox.showerror("Error", "Please select a format")
                return
            quality_choice = self.selected_quality.get()
            if format_choice in ("mp3", "wav"):
                quality_choice = "BEST QUALITY"
            self._process_total = 2
            self._process_done = 0
            self._download_finished = False
            self.append_console("Stages: 2 (download + post-processing)\n")
            self.downloading = True
            self.set_controls_state(False)
            self._schedule_progress_poll()
            def check_and_download():
                if self.abort_event.is_set():
                    return
                self.append_console("Checking media info...\n")
                downloads_dir = self.config.get('download_location', self._default_download_dir())
                media_dl_dir = downloads_dir
                os.makedirs(media_dl_dir, exist_ok=True)
                try:
                    ydl_opts = {
                        'quiet': True,
                        'skip_download': True,
                        'no_warnings': True,
                        'simulate': True,
                    }
                    with YoutubeDL(ydl_opts) as ydl:
                        info_dict = ydl.extract_info(sanitized_url, download=False)
                    if self.abort_event.is_set():
                        return
                    title = info_dict.get('title', '')
                    media_id = info_dict.get('id')
                    safe_base = self._build_base_filename(title, media_id)
                    final_filename = f"{safe_base}.{format_choice}"
                    output_path_final = os.path.join(media_dl_dir, final_filename)
                    if os.path.exists(output_path_final):
                        if self.abort_event.is_set():
                            return
                        if not self.config.get('disable_already_downloaded_prompts', False):
                            self.append_console(f"File already exists: {self._display_path(output_path_final)}\n")
                            def ask_redownload():
                                if self.abort_event.is_set():
                                    return
                                if messagebox.askyesno("File Exists", f"File already exists:\n{self._display_path(output_path_final)}\nDo you want to download it again?"):
                                    if self.abort_event.is_set():
                                        return
                                    self.download_thread = threading.Thread(target=self.download_video, args=(sanitized_url, format_choice, quality_choice, safe_base))
                                    self.download_thread.start()
                                else:
                                    self._download_finished = True
                                    self._process_done = self._process_total
                                    self.append_console("Download finished (already exists).\n")
                                    self.mark_progress_complete()
                                    self.downloading = False
                                    self.set_controls_state(True)
                                    self.download_button.config(state=tk.NORMAL)
                            self.run_on_ui_thread(ask_redownload)
                            return
                        else:
                            self._download_finished = True
                            self._process_done = self._process_total
                            self.append_console("Download finished (already exists).\n")
                            self.mark_progress_complete()
                            self.downloading = False
                            self.set_controls_state(True)
                            self.run_on_ui_thread(self.download_button.config, state=tk.NORMAL)
                            return
                except Exception as e:
                    if self.abort_event.is_set():
                        return
                    self.append_console("Failed to retrieve media info!\n")
                    self.run_on_ui_thread(messagebox.showerror, "Error", f"Failed to retrieve media info: {e}")
                    self.downloading = False
                    self.set_controls_state(True)
                    self.run_on_ui_thread(self.download_button.config, state=tk.NORMAL)
                    return
                if self.abort_event.is_set():
                    return
                self.download_thread = threading.Thread(target=self.download_video, args=(sanitized_url, format_choice, quality_choice, safe_base))
                self.download_thread.start()

            threading.Thread(target=check_and_download, daemon=True).start()

    def abort(self):
        if not self.downloading:
            return
        self.abort_event.set()
        self._drain_queue(self.progress_queue)
        if self.console:
            self.run_on_ui_thread(self._clear_console_output)
        self.run_on_ui_thread(self._reset_progress_bar)
        if self.ydl:
            try:
                if hasattr(self.ydl, "abort"):
                    self.ydl.abort()
            except Exception:
                pass
        if not self._abort_notified:
            self._abort_notified = True
            self.append_console("Download aborted!\n")
        if self._is_windows():
            try:
                startupinfo = subprocess.STARTUPINFO()
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
                creationflags = subprocess.CREATE_NO_WINDOW
                subprocess.run([
                    "taskkill", "/F", "/IM", "ffmpeg.exe"
                ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, startupinfo=startupinfo, creationflags=creationflags)
            except Exception:
                pass
        def finish_abort():
            thread = getattr(self, "download_thread", None)
            if thread and thread.is_alive():
                deadline = time.time() + 10
                while thread.is_alive() and time.time() < deadline:
                    thread.join(timeout=0.1)
            time.sleep(0.3)
            self._cleanup_partial_downloads(max_attempts=60, delay=0.25)
            self.downloading = False
            self.set_controls_state(True)
            if self.config.get('allow_batch_downloads', False) and getattr(self, "batch_progress_frame", None):
                self.run_on_ui_thread(self._show_reset_button)
        threading.Thread(target=finish_abort, daemon=True).start()

    def _on_window_close(self):
        self._closing = True
        if self.downloading:
            self.abort()
            self._after(50, lambda: self._check_close_after_abort(0))
        else:
            self.terminate_program()

    def _check_close_after_abort(self, attempts):
        if not self.downloading:
            self.terminate_program()
            return
        if attempts >= 200:
            self.terminate_program()
            return
        self._after(50, lambda: self._check_close_after_abort(attempts + 1))

    def terminate_program(self):
        self.status_polling = False
        try:
            self.root.destroy()
        except Exception:
            pass
        os._exit(0)

    def restart_program(self):
        try:
            if getattr(sys, 'frozen', False):
                args = [sys.executable] + sys.argv[1:]
                env = os.environ.copy()
                env.pop("_PYI_TEMP_PATH", None)
                env["PYINSTALLER_RESET_ENVIRONMENT"] = "1"
                subprocess.Popen(args, cwd=os.getcwd(), env=env)
            else:
                args = [sys.executable, os.path.abspath(sys.argv[0])] + sys.argv[1:]
                subprocess.Popen(args, cwd=os.getcwd())
        except Exception as e:
            logging.error(f"Failed to restart application: {e}")
        self.terminate_program()

    def download_video(self, url, format_choice, quality_choice, safe_base):
        self.append_console("Starting download...\n")
        downloads_dir = self.config.get('download_location', self._default_download_dir())
        media_dl_dir = downloads_dir
        os.makedirs(media_dl_dir, exist_ok=True)
        final_filename = f"{safe_base}.{format_choice}"
        output_path_final = os.path.join(media_dl_dir, final_filename)
        temp_base = f"{safe_base}__{format_choice}_TEMP"
        output_template = os.path.join(media_dl_dir, f'{temp_base}.%(ext)s')
        self._register_active_temp(media_dl_dir, temp_base)

        quality_format = {
            "BEST QUALITY": "bestvideo+bestaudio/best",
            "144p": "worstvideo[height<=144]+bestaudio/best[height<=144]",
            "240p": "worstvideo[height<=240]+bestaudio/best[height<=240]",
            "360p": "worstvideo[height<=360]+bestaudio/best[height<=360]",
            "480p": "worstvideo[height<=480]+bestaudio/best[height<=480]",
            "720p": "bestvideo[height<=720]+bestaudio/best[height<=720]",
            "1080p": "bestvideo[height<=1080]+bestaudio/best[height<=1080]",
            "1440p": "bestvideo[height<=1440]+bestaudio/best[height<=1440]",
            "2160p": "bestvideo[height<=2160]+bestaudio/best[height<=2160]",
            "2160p (4k)": "bestvideo[height<=2160]+bestaudio/best[height<=2160]",
        }
        if format_choice == "mp4":
            quality_format = {
                "BEST QUALITY": "bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]",
                "144p": "bestvideo[ext=mp4][height<=144]+bestaudio[ext=m4a]/best[ext=mp4][height<=144]/best[ext=mp4]",
                "240p": "bestvideo[ext=mp4][height<=240]+bestaudio[ext=m4a]/best[ext=mp4][height<=240]/best[ext=mp4]",
                "360p": "bestvideo[ext=mp4][height<=360]+bestaudio[ext=m4a]/best[ext=mp4][height<=360]/best[ext=mp4]",
                "480p": "bestvideo[ext=mp4][height<=480]+bestaudio[ext=m4a]/best[ext=mp4][height<=480]/best[ext=mp4]",
                "720p": "bestvideo[ext=mp4][height<=720]+bestaudio[ext=m4a]/best[ext=mp4][height<=720]/best[ext=mp4]",
                "1080p": "bestvideo[ext=mp4][height<=1080]+bestaudio[ext=m4a]/best[ext=mp4][height<=1080]/best[ext=mp4]",
                "1440p": "bestvideo[ext=mp4][height<=1440]+bestaudio[ext=m4a]/best[ext=mp4][height<=1440]/best[ext=mp4]",
                "2160p": "bestvideo[ext=mp4][height<=2160]+bestaudio[ext=m4a]/best[ext=mp4][height<=2160]/best[ext=mp4]",
                "2160p (4k)": "bestvideo[ext=mp4][height<=2160]+bestaudio[ext=m4a]/best[ext=mp4][height<=2160]/best[ext=mp4]",
            }

        windows_hide_flag = self._is_windows()
        if format_choice in ['mp3', 'wav']:
            ydl_opts = {
                'format': 'bestaudio/best',
                'outtmpl': output_template,
                'progress_hooks': [self.ydl_hook],
                'postprocessors': [{
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': format_choice,
                    'preferredquality': '0',
                }],
                'concurrent_fragment_downloads': 8,
                'quiet': True,
                'windows_hide': windows_hide_flag,
            }
        else:
            ydl_opts = {
                'format': quality_format.get(quality_choice, 'best'),
                'outtmpl': output_template,
                'progress_hooks': [self.ydl_hook],
                'postprocessors': [{
                    'key': 'FFmpegVideoConvertor',
                    'preferedformat': 'mov',
                    'ffmpeg_args': ['-preset', 'ultrafast'],
                }] if format_choice == 'mov' else [],
                'concurrent_fragment_downloads': 8,
                'quiet': True,
                'windows_hide': windows_hide_flag,
            }
            if format_choice in ("mp4", "mov"):
                ydl_opts['merge_output_format'] = format_choice
        ffmpeg_location = self._resolve_ffmpeg_location()
        if ffmpeg_location:
            ydl_opts['ffmpeg_location'] = ffmpeg_location
        js_runtime = self._resolve_js_runtime()
        if js_runtime:
            ydl_opts['js_runtimes'] = js_runtime
        ydl_opts.update(self._external_downloader_opts())

        start_time = time.time()
        with YoutubeDL(ydl_opts) as ydl:
            self.ydl = ydl
            try:
                ydl.download([url])
                temp_files = [f for f in os.listdir(media_dl_dir) if f.startswith(temp_base + ".") and '_TEMP.' in f]
                for temp_file in temp_files:
                    temp_path = os.path.join(media_dl_dir, temp_file)
                    final_path = os.path.join(media_dl_dir, final_filename)
                    if os.path.exists(final_path):
                        try:
                            os.remove(final_path)
                        except Exception:
                            pass
                    os.rename(temp_path, final_path)
                if self.progress:
                    self.run_on_ui_thread(self._mark_progress_complete)
                elapsed = time.time() - start_time
                file_size = os.path.getsize(output_path_final) if os.path.exists(output_path_final) else 0
                size_mb = file_size / (1024 * 1024)
                output_lines = []
                if getattr(self, "_process_total", 1) > 1:
                    self._process_done = self._process_total
                    output_lines.append(f"All processes complete ({self._process_done}/{self._process_total}).")
                output_lines.append(f"Saved as: {self._display_path(output_path_final)}")
                output_lines.append(f"File size: {size_mb:.2f} MB")
                output_lines.append(f"Time taken: {elapsed:.2f} seconds")
                output_lines.append("Download completed successfully!")
                self.append_console("\n".join(output_lines) + "\n")
            except DownloadCancelled:
                if not getattr(self, "_abort_notified", False):
                    self._abort_notified = True
                    self.append_console("Download aborted!\n")
                self._cleanup_temp_files(media_dl_dir, temp_base, max_attempts=60, delay=0.25)
            except Exception as e:
                if self.abort_event.is_set():
                    self.append_console("Download aborted!\n")
                else:
                    self.append_console("Download failed!\n")
                    self.run_on_ui_thread(messagebox.showerror, "Error", str(e))
            finally:
                self.downloading = False
                self.set_controls_state(True)
                self.ydl = None
                self._unregister_active_temp(media_dl_dir, temp_base)

    def ydl_hook(self, d):
        if self.abort_event.is_set():
            raise DownloadCancelled()
        if d['status'] == 'downloading':
            try:
                percent_str = d.get('_percent_str', '').strip()
                percent = percent_str.split('%')[0].strip()[-4:]
                try:
                    val = float(percent)
                except Exception:
                    val = 0
                self.progress_queue.put(val)
                self.run_on_ui_thread(self._schedule_progress_poll)
            except Exception:
                self.progress_queue.put(0)
                self.run_on_ui_thread(self._schedule_progress_poll)
        elif d['status'] == 'finished':
            self.progress_queue.put(100)
            self.run_on_ui_thread(self._schedule_progress_poll)


    def check_for_updates(self, manual=False, on_complete=None):#UPDATE CHECK
        def finish():
            if on_complete:
                self.run_on_ui_thread(on_complete)
        def update_check():
            try:
                current_version = "v1.0.0"
                rss_url = "https://sourceforge.net/projects/mediacrate/rss?path=/"
                response = requests.get(rss_url, timeout=10)
                if response.status_code == 200:
                    root = ET.fromstring(response.text)
                    latest_version = None
                    download_url = None

                    for item in root.findall(".//item"):
                        title = item.find("title").text
                        link = item.find("link").text
                        match = re.search(r"_v(\d+\.\d+\.\d+)", title)
                        if match:
                            version_str = f"v{match.group(1)}"
                            try:
                                if Version(version_str) > Version(current_version):
                                    latest_version = version_str
                                    download_url = link
                                    break
                            except InvalidVersion:
                                logging.error(f"Invalid version format: {version_str}")
                    
                    if latest_version and download_url:
                        prompt_message = (
                            f"A newer version - {latest_version} is available!\n"
                            f"Would you like to download it now?"
                        )
                        self.run_on_ui_thread(self._prompt_update, prompt_message, download_url, finish)
                        return
                    elif manual:
                        def show_up_to_date():
                            messagebox.showinfo("Up to Date", "You are already on the latest version.")
                            finish()
                        self.run_on_ui_thread(show_up_to_date)
                        return
                    finish()
                else:
                    logging.error(f"Failed to fetch SourceForge RSS feed: HTTP {response.status_code}")
                    if manual:
                        def show_failed():
                            messagebox.showerror("Update Check Failed", "Unable to check for updates. Please try again later.")
                            finish()
                        self.run_on_ui_thread(show_failed)
                        return
                    finish()
            except Exception as e:
                logging.error(f"Error during SourceForge update check: {e}")
                if manual:
                    def show_failed():
                        messagebox.showerror("Update Check Failed", "Unable to check for updates. Please try again later.")
                        finish()
                    self.run_on_ui_thread(show_failed)
                    return
                finish()

        threading.Thread(target=update_check, daemon=True).start()

    def _prompt_update(self, prompt_message, download_url, on_complete=None):
        theme = self.theme
        fonts = self.fonts
        bg_main = theme["bg"]
        fg_label = theme["text"]
        bg_button = theme["surface_alt"]
        fg_button = theme["text"]
        active_bg_button = theme["surface_alt_hover"]
        active_fg_button = theme["text"]
        if hasattr(self, 'update_overlay') and self.update_overlay.winfo_exists():
            self.update_overlay.destroy()
        self.update_overlay = tk.Frame(self.root, bg=bg_main)
        self.update_overlay.place(relx=0, rely=0, relwidth=1, relheight=1)
        dialog = tk.Frame(self.update_overlay, bg=theme["surface"], bd=0, highlightthickness=1, highlightbackground=theme["border"])
        dialog.place(relx=0.5, rely=0.5, anchor="center")
        tk.Label(
            dialog,
            text=prompt_message,
            bg=theme["surface"],
            fg=fg_label,
            wraplength=420,
            font=fonts["subtitle"],
            justify="center"
        ).pack(pady=(20, 10), padx=20)
        button_frame = tk.Frame(dialog, bg=theme["surface"])
        button_frame.pack(pady=15)
        def yes_action():
            self.open_url(download_url)
            self.update_overlay.destroy()
            self.terminate_program()
        def no_action():
            self.update_overlay.destroy()
            if on_complete:
                on_complete()
        yes_button = tk.Button(
            button_frame,
            text="Yes",
            command=yes_action,
            font=fonts["button"],
            bg=bg_button,
            fg=fg_button,
            activebackground=active_bg_button,
            activeforeground=active_fg_button,
            relief="flat",
            bd=0,
            padx=20,
            pady=5,
            width=10,
            cursor="hand2"
        )
        yes_button.pack(side="left", padx=10)
        self.add_hover_effect(
            yes_button,
            bg_normal=bg_button,
            fg_normal=fg_button,
            bg_hover=active_bg_button,
            fg_hover=active_fg_button
        )
        no_button = tk.Button(
            button_frame,
            text="No",
            command=no_action,
            font=fonts["button"],
            bg=theme["danger"],
            fg=theme["bg"],
            activebackground=theme["danger_hover"],
            activeforeground=theme["bg"],
            relief="flat",
            bd=0,
            padx=20,
            pady=5,
            width=10,
            cursor="hand2"
        )
        no_button.pack(side="right", padx=10)
        self.add_hover_effect(
            no_button,
            bg_normal=theme["danger"],
            fg_normal=theme["bg"],
            bg_hover=theme["danger_hover"],
            fg_hover=theme["bg"]
        )

    def poll_status_queue(self):
        if not self.status_polling:
            self._status_poll_scheduled = False
            return
        try:
            processed = 0
            max_tasks = self._max_status_tasks_per_tick
            while processed < max_tasks:
                msg = self.status_queue.get_nowait()
                self._append_console(msg + "\n")
                processed += 1
        except queue.Empty:
            pass
        if not self.status_queue.empty():
            self._after(16, self.poll_status_queue)
        else:
            self._status_poll_scheduled = False

    def _schedule_status_poll(self):
        if not self.status_polling:
            return
        if self._status_poll_scheduled:
            return
        self._status_poll_scheduled = True
        self._after(16, self.poll_status_queue)

    def poll_progress_queue(self):
        if not self.downloading:
            self._progress_poll_scheduled = False
            return
        if self.abort_event.is_set():
            self._drain_queue(self.progress_queue)
            self._progress_poll_scheduled = False
            return
        last_val = None
        try:
            while True:
                last_val = self.progress_queue.get_nowait()
        except queue.Empty:
            pass
        if last_val is not None:
            self.display_percent_in_console(last_val)
        if self.downloading and not self.progress_queue.empty():
            self._after(32, self.poll_progress_queue)
        else:
            self._progress_poll_scheduled = False

    def _schedule_progress_poll(self):
        if not self.downloading:
            return
        if self._progress_poll_scheduled:
            return
        self._progress_poll_scheduled = True
        self._after(16, self.poll_progress_queue)

    def set_status(self, msg):
        self.status_queue.put(msg)
        self._schedule_status_poll()

    def append_console(self, msg):
        self.run_on_ui_thread(self._append_console, msg)

    def _clear_console_output(self):
        console = getattr(self, "console", None)
        if console:
            console.delete("1.0", tk.END)

    def _drain_queue(self, queue_obj):
        try:
            while True:
                queue_obj.get_nowait()
        except queue.Empty:
            pass

    def _append_console(self, msg):
        console = getattr(self, "console", None)
        if console:
            timestamp = time.strftime("%H:%M:%S")
            lines = msg.splitlines()
            if not lines:
                lines = [""]
            stamped_lines = []
            for line in lines:
                if line.strip():
                    stamped_lines.append(f"{timestamp}: {line}")
                else:
                    stamped_lines.append("")
            stamped_msg = "\n".join(stamped_lines)
            if msg.endswith("\n"):
                stamped_msg += "\n"
            console.insert(tk.END, stamped_msg)
            lines = int(console.index('end-1c').split('.')[0])
            if lines > 200:
                console.delete("1.0", f"{lines-199}.0")
            console.see(tk.END)

    def display_percent_in_console(self, percent):
        self.run_on_ui_thread(self._display_percent_in_console, percent)

    def _display_percent_in_console(self, percent):
        if self.config.get('allow_batch_downloads', False):
            return
        if getattr(self, "_download_finished", False) and percent < 100:
            return
        if percent <= 0:
            if not getattr(self, "_percent_started", False):
                if self.progress and isinstance(self.progress, tk.Canvas):
                    self._set_progress_value(0)
                    self._set_progress_text("0%")
            return
        if percent > 0:
            self._percent_started = True
        if percent == 100 and not getattr(self, "_download_finished", False):
            self._download_finished = True
            total = getattr(self, "_process_total", 1)
            done = min(getattr(self, "_process_done", 0) + 1, total)
            self._process_done = done
            if total > 1:
                self.append_console(f"Download finished ({done}/{total}). Post-processing...\n")
            else:
                self.append_console(f"Process finished ({done}/{total}).\n")
        if self.progress and isinstance(self.progress, tk.Canvas):
            self._set_progress_value(percent)
        if percent > 0:
            self._set_progress_text(f"{int(percent)}%")

    def show_settings(self):
        if self.downloading:
            return
        if getattr(self, "_current_view", None) != "settings":
            self._settings_enter_size = (self.root.winfo_width(), self.root.winfo_height())
            self._settings_forced_size = None
            self._settings_user_resized = False
        self._begin_transition()
        self._ensure_view_container()
        for widget in self.settings_view.winfo_children():
            widget.destroy()
        theme = self.theme
        fonts = self.fonts
        self.settings_frame = self.settings_view
        self.settings_frame.configure(bg=theme["bg"])
        tk.Label(self.settings_frame, text="Settings", font=fonts["title"], fg=theme["text"], bg=theme["bg"]).pack(pady=(18, 30))
        def on_toggle_disable_char_limits():
            self.config['disable_char_limits'] = not self.config.get('disable_char_limits', False)
            self.save_config()
            char_limit_var.set(self.config['disable_char_limits'])
            self._apply_single_url_limit()
            self._apply_batch_text_limits()
        char_limit_var = tk.BooleanVar(value=self.config.get('disable_char_limits', False))
        disable_char_limits_cb = tk.Checkbutton(
            self.settings_frame,
            text="Disable URL length limits",
            variable=char_limit_var,
            command=on_toggle_disable_char_limits,
            font=fonts["body"],
            bg=theme["bg"],
            fg=theme["text"],
            selectcolor=theme["surface_alt"],
            activebackground=theme["surface_alt"],
            activeforeground=theme["text"],
            highlightthickness=0
        )
        disable_char_limits_cb.pack(anchor="w", padx=32, pady=(0, 20))
        def on_toggle_disable_warnings():
            self.config['disable_warnings'] = not self.config.get('disable_warnings', False)
            self.save_config()
            var.set(self.config['disable_warnings'])
        var = tk.BooleanVar(value=self.config.get('disable_warnings', False))
        disable_warnings_cb = tk.Checkbutton(
            self.settings_frame,
            text="Disable quality/format warnings",
            variable=var,
            command=on_toggle_disable_warnings,
            font=fonts["body"],
            bg=theme["bg"],
            fg=theme["text"],
            selectcolor=theme["surface_alt"],
            activebackground=theme["surface_alt"],
            activeforeground=theme["text"],
            highlightthickness=0
        )
        disable_warnings_cb.pack(anchor="w", padx=32, pady=(0, 20))
        def on_toggle_disable_already_downloaded_prompts():
            self.config['disable_already_downloaded_prompts'] = not self.config.get('disable_already_downloaded_prompts', False)
            self.save_config()
            already_var.set(self.config['disable_already_downloaded_prompts'])
        already_var = tk.BooleanVar(value=self.config.get('disable_already_downloaded_prompts', False))
        disable_already_downloaded_cb = tk.Checkbutton(
            self.settings_frame,
            text="Disable prompting for already downloaded files",
            variable=already_var,
            command=on_toggle_disable_already_downloaded_prompts,
            font=fonts["body"],
            bg=theme["bg"],
            fg=theme["text"],
            selectcolor=theme["surface_alt"],
            activebackground=theme["surface_alt"],
            activeforeground=theme["text"],
            highlightthickness=0
        )
        disable_already_downloaded_cb.pack(anchor="w", padx=32, pady=(0, 20))
        def on_toggle_window_resizing():
            new_value = bool(window_resize_var.get())
            current_value = bool(self.config.get('enable_window_resizing', True))
            if new_value == current_value:
                return
            if messagebox.askyesno("Restart Required", "Changing window resizing requires restarting the app. Restart now?"):
                self.config['enable_window_resizing'] = new_value
                self.save_config()
                messagebox.showinfo("Restarting", "The app will now restart to apply the change.")
                self.restart_program()
            else:
                window_resize_var.set(current_value)
        window_resize_var = tk.BooleanVar(value=self.config.get('enable_window_resizing', True))
        window_resize_cb = tk.Checkbutton(
            self.settings_frame,
            text="Enable window resizing",
            variable=window_resize_var,
            command=on_toggle_window_resizing,
            font=fonts["body"],
            bg=theme["bg"],
            fg=theme["text"],
            selectcolor=theme["surface_alt"],
            activebackground=theme["surface_alt"],
            activeforeground=theme["text"],
            highlightthickness=0
        )
        window_resize_cb.pack(anchor="w", padx=32, pady=(0, 20))
        def on_toggle_preserve_batch_links():
            self.config['preserve_batch_links'] = not self.config.get('preserve_batch_links', False)
            self.save_config()
            preserve_var.set(self.config['preserve_batch_links'])
            if not self.config['preserve_batch_links']:
                self._batch_saved_links = None
        preserve_var = tk.BooleanVar(value=self.config.get('preserve_batch_links', False))
        preserve_links_cb = tk.Checkbutton(
            self.settings_frame,
            text="Keep batch links after reset",
            variable=preserve_var,
            command=on_toggle_preserve_batch_links,
            font=fonts["body"],
            bg=theme["bg"],
            fg=theme["text"],
            selectcolor=theme["surface_alt"],
            activebackground=theme["surface_alt"],
            activeforeground=theme["text"],
            highlightthickness=0
        )
        preserve_links_cb.pack(anchor="w", padx=32, pady=(0, 20))
        def on_toggle_batch_downloads():
            self.config['allow_batch_downloads'] = not self.config.get('allow_batch_downloads', False)
            self.save_config()
            batch_var.set(self.config['allow_batch_downloads'])
            self._pending_batch_refresh = True
        batch_var = tk.BooleanVar(value=self.config.get('allow_batch_downloads', False))
        batch_downloads_cb = tk.Checkbutton(
            self.settings_frame,
            text="Allow Batch Downloads (multi-link notepad input)",
            variable=batch_var,
            command=on_toggle_batch_downloads,
            font=fonts["body"],
            bg=theme["bg"],
            fg=theme["text"],
            selectcolor=theme["surface_alt"],
            activebackground=theme["surface_alt"],
            activeforeground=theme["text"],
            highlightthickness=0
        )
        batch_downloads_cb.pack(anchor="w", padx=32, pady=(0, 20))
        def on_toggle_auto_updates():
            self.config['auto_check_updates'] = bool(auto_update_var.get())
            self.save_config()
        auto_update_var = tk.BooleanVar(value=self.config.get('auto_check_updates', True))
        updates_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        updates_row.pack(anchor="w", padx=32, pady=(0, 20), fill="x")
        auto_updates_cb = tk.Checkbutton(
            updates_row,
            text="Automatically check for updates",
            variable=auto_update_var,
            command=on_toggle_auto_updates,
            font=fonts["body"],
            bg=theme["bg"],
            fg=theme["text"],
            selectcolor=theme["surface_alt"],
            activebackground=theme["surface_alt"],
            activeforeground=theme["text"],
            highlightthickness=0
        )
        auto_updates_cb.pack(side="left")
        check_updates_btn = tk.Button(
            updates_row,
            text="Check now",
            font=fonts["label"],
            bg=theme["surface_alt"],
            fg=theme["text"],
            activebackground=theme["surface_alt_hover"],
            activeforeground=theme["text"],
            relief="flat",
            bd=0,
            padx=10,
            pady=2,
            command=lambda: self.check_for_updates(manual=True)
        )
        check_updates_btn.pack(side="left", padx=(12, 0))
        self.add_hover_effect(
            check_updates_btn,
            bg_normal=theme["surface_alt"],
            fg_normal=theme["text"],
            bg_hover=theme["surface_alt_hover"],
            fg_hover=theme["accent"]
        )
        def on_queue_cap_change():
            value = self._normalize_ui_queue_cap(queue_cap_var.get())
            self.config['ui_queue_cap'] = value
            self.save_config()
            queue_cap_var.set(str(value))
            self._max_gui_tasks_per_tick = value
            self._max_status_tasks_per_tick = value
            self._max_progress_updates_per_tick = value
        queue_cap_default = self._default_ui_queue_cap()
        queue_cap_var = tk.StringVar(value=str(self._normalize_ui_queue_cap(self.config.get('ui_queue_cap'))))
        tk.Label(self.settings_frame, text="UI queue cap (tasks per tick):", font=fonts["label"], bg=theme["bg"], fg=theme["text"]).pack(anchor="w", padx=32, pady=(0, 4))
        queue_cap_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        queue_cap_row.pack(anchor="w", padx=32, pady=(0, 6), fill="x")
        queue_cap_spin = tk.Spinbox(
            queue_cap_row,
            from_=1,
            to=500,
            textvariable=queue_cap_var,
            font=fonts["body"],
            bg=theme["surface_alt"],
            fg=theme["text"],
            relief="flat",
            bd=0,
            width=6,
            highlightthickness=1,
            highlightbackground=theme["border"],
            highlightcolor=theme["border"]
        )
        queue_cap_spin.pack(side="left")
        try:
            queue_cap_spin.config(
                buttonbackground="black",
                buttonforeground="white"
            )
        except tk.TclError:
            pass
        queue_cap_spin.config(command=on_queue_cap_change)
        queue_cap_spin.bind("<FocusOut>", lambda e: on_queue_cap_change())
        queue_cap_spin.bind("<Return>", lambda e: on_queue_cap_change())
        tk.Label(
            self.settings_frame,
            text=f"Drains UI/status queues per tick. Default: {queue_cap_default} (max 500).",
            font=fonts["caption"],
            bg=theme["bg"],
            fg=theme["muted"]
        ).pack(anchor="w", padx=32, pady=(0, 20))
        def on_max_lines_change():
            value = self._normalize_batch_line_limit(max_lines_var.get())
            self.config['max_batch_lines'] = value
            self.save_config()
            max_lines_var.set(str(value))
            self._apply_batch_text_limits()
        max_lines_default = self._default_batch_line_limit()
        max_lines_var = tk.StringVar(value=str(self._normalize_batch_line_limit(self.config.get('max_batch_lines'))))
        tk.Label(self.settings_frame, text="Max batch links:", font=fonts["label"], bg=theme["bg"], fg=theme["text"]).pack(anchor="w", padx=32, pady=(0, 4))
        max_lines_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        max_lines_row.pack(anchor="w", padx=32, pady=(0, 6), fill="x")
        max_lines_spin = tk.Spinbox(
            max_lines_row,
            from_=1,
            to=1024,
            textvariable=max_lines_var,
            font=fonts["body"],
            bg=theme["surface_alt"],
            fg=theme["text"],
            relief="flat",
            bd=0,
            width=6,
            highlightthickness=1,
            highlightbackground=theme["border"],
            highlightcolor=theme["border"]
        )
        max_lines_spin.pack(side="left")
        try:
            max_lines_spin.config(
                buttonbackground="black",
                buttonforeground="white"
            )
        except tk.TclError:
            pass
        max_lines_spin.config(command=on_max_lines_change)
        max_lines_spin.bind("<FocusOut>", lambda e: on_max_lines_change())
        max_lines_spin.bind("<Return>", lambda e: on_max_lines_change())
        tk.Label(
            self.settings_frame,
            text=f"Limits batch input lines. Default: {max_lines_default} (max 1024).",
            font=fonts["caption"],
            bg=theme["bg"],
            fg=theme["muted"]
        ).pack(anchor="w", padx=32, pady=(0, 20))
        def on_concurrency_change():
            value = self._normalize_batch_concurrency(concurrency_var.get())
            self.config['batch_concurrency'] = value
            self.save_config()
            concurrency_var.set(str(value))
        concurrency_default = self._default_batch_concurrency()
        concurrency_var = tk.StringVar(value=str(self._normalize_batch_concurrency(self.config.get('batch_concurrency'))))
        tk.Label(self.settings_frame, text="Batch download concurrency:", font=fonts["label"], bg=theme["bg"], fg=theme["text"]).pack(anchor="w", padx=32, pady=(0, 4))
        concurrency_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        concurrency_row.pack(anchor="w", padx=32, pady=(0, 6), fill="x")
        concurrency_spin = tk.Spinbox(
            concurrency_row,
            from_=1,
            to=64,
            textvariable=concurrency_var,
            font=fonts["body"],
            bg=theme["surface_alt"],
            fg=theme["text"],
            relief="flat",
            bd=0,
            width=6,
            highlightthickness=1,
            highlightbackground=theme["border"],
            highlightcolor=theme["border"]
        )
        concurrency_spin.pack(side="left")
        try:
            concurrency_spin.config(
                buttonbackground="black",
                buttonforeground="white"
            )
        except tk.TclError:
            pass
        concurrency_spin.config(command=on_concurrency_change)
        concurrency_spin.bind("<FocusOut>", lambda e: on_concurrency_change())
        concurrency_spin.bind("<Return>", lambda e: on_concurrency_change())
        tk.Label(
            self.settings_frame,
            text=f"Higher values use more CPU/bandwidth. Recommended default: {concurrency_default}.",
            font=fonts["caption"],
            bg=theme["bg"],
            fg=theme["muted"]
        ).pack(anchor="w", padx=32, pady=(0, 20))
        def on_retry_change():
            value = self._normalize_batch_retries(retry_var.get())
            self.config['batch_retry_attempts'] = value
            self.save_config()
            retry_var.set(str(value))
        retry_var = tk.StringVar(value=str(self._normalize_batch_retries(self.config.get('batch_retry_attempts'))))
        tk.Label(self.settings_frame, text="Batch retry attempts per link:", font=fonts["label"], bg=theme["bg"], fg=theme["text"]).pack(anchor="w", padx=32, pady=(0, 4))
        retry_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        retry_row.pack(anchor="w", padx=32, pady=(0, 6), fill="x")
        retry_spin = tk.Spinbox(
            retry_row,
            from_=1,
            to=5,
            textvariable=retry_var,
            font=fonts["body"],
            bg=theme["surface_alt"],
            fg=theme["text"],
            relief="flat",
            bd=0,
            width=6,
            highlightthickness=1,
            highlightbackground=theme["border"],
            highlightcolor=theme["border"]
        )
        retry_spin.pack(side="left")
        try:
            retry_spin.config(
                buttonbackground="black",
                buttonforeground="white"
            )
        except tk.TclError:
            pass
        retry_spin.config(command=on_retry_change)
        retry_spin.bind("<FocusOut>", lambda e: on_retry_change())
        retry_spin.bind("<Return>", lambda e: on_retry_change())
        tk.Label(
            self.settings_frame,
            text="Retries happen when a link fails during download.",
            font=fonts["caption"],
            bg=theme["bg"],
            fg=theme["muted"]
        ).pack(anchor="w", padx=32, pady=(0, 20))
        def on_change_download_location():
            from tkinter import filedialog
            new_dir = filedialog.askdirectory(
                title="Browse",
                initialdir=self.config.get('download_location', self._default_download_dir())
           
            )
            if new_dir:
                self.config['download_location'] = new_dir
                self.save_config()
                download_location_var.set(self._display_path(new_dir))
        download_location_var = tk.StringVar(value=self._display_path(self.config.get('download_location', self._default_download_dir())))
        tk.Label(self.settings_frame, text="Download Location:", font=fonts["label"], bg=theme["bg"], fg=theme["text"]).pack(anchor="w", padx=32, pady=(0, 4))
        download_location_row = tk.Frame(self.settings_frame, bg=theme["bg"])
        download_location_row.pack(anchor="w", padx=32, pady=(0, 20), fill="x")
        download_entry = tk.Entry(
            download_location_row,
            textvariable=download_location_var,
            font=fonts["body"],
            bg=theme["surface_alt"],
            fg=theme["text"],
            selectbackground=theme["surface_alt"],
            selectforeground=theme["text"],
            relief="flat",
            bd=0,
            width=48,
            state="readonly",
            readonlybackground=theme["surface_alt"]
        )
        download_entry.pack(side="left", padx=(0, 8), fill="x", expand=True, ipady=7)
        browse_btn = tk.Button(
            download_location_row,
            text="Browse...",
            font=fonts["button"],
            bg=theme["surface_alt"],
            fg=theme["text"],
            activebackground=theme["surface_alt_hover"],
            activeforeground=theme["text"],
            relief="flat",
            bd=0,
            padx=8,
            pady=2,
            command=on_change_download_location
        )
        browse_btn.pack(side="left")
        self.add_hover_effect(
            browse_btn,
            bg_normal=theme["surface_alt"],
            fg_normal=theme["text"],
            bg_hover=theme["surface_alt_hover"],
            fg_hover=theme["accent"]
        )
        bottom_bar = tk.Frame(self.settings_frame, bg=theme["bg"], padx=24, pady=8)
        bottom_bar.pack(side="bottom", fill="x")
        bottom_left = tk.Frame(bottom_bar, bg=theme["bg"])
        bottom_right = tk.Frame(bottom_bar, bg=theme["bg"])
        back_btn = tk.Button(
            bottom_left, text="Back", font=fonts["label"],
            bg=theme["bg"], fg=theme["muted"],
            activebackground=theme["bg"], activeforeground=theme["text"],
            relief="flat", bd=0, padx=8, pady=2, command=self.show_main_view, cursor="hand2"
        )
        back_btn.pack(side="left", anchor="w", padx=(0, 8))
        self.add_hover_effect(back_btn, bg_normal=theme["bg"], fg_normal=theme["muted"], bg_hover=theme["bg"], fg_hover=theme["accent"])

        def on_reset_defaults():
            if messagebox.askyesno("Reset Settings", "Are you sure you want to reset all settings to their defaults? This cannot be undone."):
                default_config = {
                    'WARNING:': "This file is generated by MediaCrate. DO NOT CHANGE the contents of this file unless you know what you are doing.",
                    'disable_warnings': False,
                    'allow_batch_downloads': False,
                    'disable_already_downloaded_prompts': False,
                    'auto_check_updates': True,
                    'enable_window_resizing': False,
                    'ui_queue_cap': self._default_ui_queue_cap(),
                    'download_location': self._default_download_dir(),
                    'batch_concurrency': self._default_batch_concurrency(),
                    'batch_retry_attempts': 1,
                    'preserve_batch_links': False,
                    'max_batch_lines': self._default_batch_line_limit(),
                    'disable_char_limits': False
                }
                self.config = default_config
                self.save_config()
                messagebox.showinfo("Settings Reset", "Settings have been reset to defaults. The app will now restart.")
                self.restart_program()
        reset_btn = tk.Button(
            bottom_left, text="Reset to defaults", font=fonts["label"],
            bg=theme["bg"], fg=theme["muted"],
            activebackground=theme["bg"], activeforeground=theme["text"],
            relief="flat", bd=0, padx=8, pady=2, command=on_reset_defaults, cursor="hand2"
        )
        reset_btn.pack(side="left", anchor="w")
        self.add_hover_effect(reset_btn, bg_normal=theme["bg"], fg_normal=theme["muted"], bg_hover=theme["bg"], fg_hover=theme["accent"])
        downloads_link = tk.Label(bottom_right, text="Open downloads folder", font=fonts["caption"], fg=theme["accent"], bg=theme["bg"], cursor="hand2")
        downloads_link.pack(side="right", anchor="e", padx=(0, 12))
        downloads_link.bind("<Button-1>", lambda e: self.open_downloads_folder())
        self.add_hover_effect(
            downloads_link,
            bg_normal=theme["bg"], fg_normal=theme["accent"],
            bg_hover=theme["bg"], fg_hover=theme["text"]
        )
        official_link = tk.Label(bottom_right, text="Official page", font=fonts["caption"], fg=theme["accent"], bg=theme["bg"], cursor="hand2")
        official_link.pack(side="right", anchor="e", padx=(0, 12))
        official_link.bind("<Button-1>", lambda e: self.open_url("https://justagwas.com/projects/MediaCrate"))
        self.add_hover_effect(
            official_link,
            bg_normal=theme["bg"], fg_normal=theme["accent"],
            bg_hover=theme["bg"], fg_hover=theme["text"]
        )
        version_label = tk.Label(bottom_right, text="v1.0.0 ", font=fonts["caption"], fg=theme["muted"], bg=theme["bg"])
        version_label.pack(side="right", anchor="e", padx=(0, 2))
        self._configure_footer(bottom_bar, bottom_left, bottom_right, min_width=540)
        self.enforce_min_size()
        self._apply_window_constraints(min_extra=440)
        self.root.update_idletasks()
        self._settings_forced_size = (self.root.winfo_width(), self.root.winfo_height())
        self._show_view("settings")
        self._after(0, self._fade_in)

if __name__ == "__main__":
    enable_high_dpi()
    root = tk.Tk()
    try:
        dpi = root.winfo_fpixels("1i")
        root.tk.call("tk", "scaling", dpi / 72.0)
    except Exception:
        pass
    app = MediaDownloader(root)
    root.mainloop()